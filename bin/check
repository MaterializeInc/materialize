#!/usr/bin/env bash

# Copyright 2019 Materialize, Inc. All rights reserved.
#
# This file is part of Materialize. Materialize may not be used or
# distributed without the express permission of Materialize, Inc.
#
# check — runs `cargo clippy` on a clean build.
#
# This script may be unnecessary after an upstream bug [0] is fixed.
# [0]: https://github.com/rust-lang/rust-clippy/issues/2604

set -euo pipefail

cd "$(dirname "$0")/.."

run() {
    echo "$@"
    "$@"
}

# Add lints to this list freely, but please add a comment with justification
# along with the lint. The goal is to ever-so-slightly increase the barrier to
# turning off a lint.
disabled_lints=(
    # Upstream description: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_stmt
    #
    # clippy::block_in_if_condition_stmt prohibits complicated blocks in `if`
    # statements, like:
    #
    #     if { let difficult_answer = big_computation(); difficult_answer == 42 } { .. }
    #
    # Unfortunately it also fires incorrectly on perfectly readable
    # constructions, like:
    #
    #    assert!(vec.iter().all(|item| {
    #        // ...
    #    }))
    clippy::block_in_if_condition_stmt

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#large_enum_variant
    #
    # clippy::large_enum_variant complains when enum variants have divergent
    # sizes, as the size of an enum is determined by the size of its largest
    # element. Obeying this lint is nearly always a premature optimization,
    # and the suggested solution—boxing the large variant—might actually result
    # in slower code due to the allocation.
    clippy::large_enum_variant

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#let_and_return
    #
    # clippy::let_and_return protects against creating a let binding that is
    # returned from a block without otherwise being used, like so:
    #     {
    #       let x = String::new();
    #       // TODO(frank): figure out why sorting here is broken.
    #       // x.sort()
    #       x
    #     }
    #
    # This situation can arise naturally when commenting out intermediate code,
    # like in the example above, and working around the lint requires corrupting
    # the original intent of the code.
    clippy::let_and_return

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#match_bool
    #
    # clippy::match_bool prohibits matching in bools, like so
    #
    #     match cond {
    #       true => (),
    #       false => (),
    #     }
    #
    # and instead mandates use of an if/else statement. This is needlessly
    # nitpicky. For one, matching on bools uses one fewer lines than using an
    # if/else statement; for another, the author may be maintaining a consistent
    # style with similar blocks of nearby code.
    clippy::match_bool

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#needless_range_loop
    #
    # clippy::needless_range_loop encourages use of `for item in collection`
    # instead of `for i in 0..collection.len()`. The lint is overly aggressive,
    # however, and often forces the creation of complicated stacks of iterators
    # when the for loop is clearer.
    clippy::needless_range_loop

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#redundant_closure
    #
    # clippy::redundant_closure prohibits using closures when the closure
    # delegates to a function that could be called directly. For example, it
    # would require that
    #
    #     collection.iter().map(|item| item.to_string())
    #
    # be rewritten as:
    #
    #     collection.iter().map(ToString::to_string)
    #
    # This lint is needlessly nitpicky. The author may be maintaining a
    # consistent style with the surrounding code by introducing the closure,
    # especially when closures of various arities are in close proximity,
    # as only closures of zero or one arguments can be rewritten to delegate
    # to the inner function directly. Besides, the needless closure will be
    # trivially optimized away by LLVM.
    clippy::redundant_closure

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#type_complexity
    #
    # clippy::type_complexity disallows types that are excessively nested.
    # Unfortunately Frank McSherry loves highly nested types, and, indeed,
    # sometimes extracting the type alias that Clippy demands makes the types
    # less readable.
    clippy::type_complexity

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#unneeded_field_pattern
    #
    # clippy::unneeded_field_patterns disallows wildcard struct patterns, like
    # `obj { field1, field2: _ }`, in favor of using `obj { field1, .. }`. This
    # lint is actively harmful. Explicitly matching on every extant field
    # ensures that when a new field is added to the struct in the future,
    # whoever adds the field will be forced to inspect the match site. Using
    # `..`, while sometimes convenient, can cause match sites that need to be
    # updated for the new field to be overlooked.
    clippy::unneeded_field_pattern
)

extra_lints=(
    # Upstream description: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#bare-trait-object
    #
    # Omitting `dyn` on a trait object will become deprecated in the near future
    bare_trait_objects

    # We never want to have to back up and thread Debug through all our types again
    # missing_debug_implementations
)

# NOTE(benesch): we ignore some ShellCheck complaints about sloppy word
# splitting below. It's substantially clearer than doing things "properly,"
# and the inputs to this script are trusted.

pkgspec=$(sed -nE 's,.*"src/([^"]+)".*,-p \1,p' Cargo.toml)
# shellcheck disable=SC2086
run cargo clean $pkgspec
# shellcheck disable=SC2046
run cargo clippy -- -D warnings $(printf -- "-D %s " "${extra_lints[@]}") $(printf -- "-A %s " "${disabled_lints[@]}")
