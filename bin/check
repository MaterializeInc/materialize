#!/usr/bin/env bash

# Copyright 2019 Materialize, Inc. All rights reserved.
#
# This file is part of Materialize. Materialize may not be used or
# distributed without the express permission of Materialize, Inc.
#
# check — runs `cargo clippy` on a clean build.
#
# This script may be unnecessary after an upstream bug [0] is fixed.
# [0]: https://github.com/rust-lang/rust-clippy/issues/2604

set -euo pipefail

cd "$(dirname "$0")/.."
source misc/shlib/shlib.bash

usage() {
    # shellcheck disable=SC2006
    die "usage: $0 [`uf --[no-]force-build`]

Run cargo clippy with our CI flags

Args:

  Both of these override the 'MZ_CHECK_FORCE_BUILD=[yn]'  environment var:

    `uf -f --force-build`        Force clippy to build every project, not just changed ones (default)
    `uf -n --no-force-build`     Run clippy on just files that have been changed since the last
                                 time it was run (do not force a full rebuild)"
}

main() {
    set_args "$@"
    run_clippy
}

# Args
MZ_CHECK_FORCE_BUILD=${MZ_CHECK_FORCE_BUILD:-y}
set_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -n|--no-force-build)
                MZ_CHECK_FORCE_BUILD=n
                shift
                ;;
            -f|--force-build)
                MZ_CHECK_FORCE_BUILD=y
                shift
                ;;
            *) usage ;;
        esac
    done
}

# Add lints to this list freely, but please add a comment with justification
# along with the lint. The goal is to ever-so-slightly increase the barrier to
# turning off a lint.
disabled_lints=(
    # Upstream description: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_stmt
    #
    # clippy::block_in_if_condition_stmt prohibits complicated blocks in `if`
    # statements, like:
    #
    #     if { let difficult_answer = big_computation(); difficult_answer == 42 } { .. }
    #
    # Unfortunately it also fires incorrectly on perfectly readable
    # constructions, like:
    #
    #    assert!(vec.iter().all(|item| {
    #        // ...
    #    }))
    clippy::block_in_if_condition_stmt

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#large_enum_variant
    #
    # clippy::large_enum_variant complains when enum variants have divergent
    # sizes, as the size of an enum is determined by the size of its largest
    # element. Obeying this lint is nearly always a premature optimization,
    # and the suggested solution—boxing the large variant—might actually result
    # in slower code due to the allocation.
    clippy::large_enum_variant

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#let_and_return
    #
    # clippy::let_and_return protects against creating a let binding that is
    # returned from a block without otherwise being used, like so:
    #     {
    #       let x = String::new();
    #       // TODO(frank): figure out why sorting here is broken.
    #       // x.sort()
    #       x
    #     }
    #
    # This situation can arise naturally when commenting out intermediate code,
    # like in the example above, and working around the lint requires corrupting
    # the original intent of the code.
    clippy::let_and_return

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#match_bool
    #
    # clippy::match_bool prohibits matching in bools, like so
    #
    #     match cond {
    #       true => (),
    #       false => (),
    #     }
    #
    # and instead mandates use of an if/else statement. This is needlessly
    # nitpicky. For one, matching on bools uses one fewer lines than using an
    # if/else statement; for another, the author may be maintaining a consistent
    # style with similar blocks of nearby code.
    clippy::match_bool

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#needless_range_loop
    #
    # clippy::needless_range_loop encourages use of `for item in collection`
    # instead of `for i in 0..collection.len()`. The lint is overly aggressive,
    # however, and often forces the creation of complicated stacks of iterators
    # when the for loop is clearer.
    clippy::needless_range_loop

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity
    # 
    # Clippy's cognitive complexity is too easily reached.
    clippy::cognitive-complexity

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#redundant_closure
    #
    # clippy::redundant_closure prohibits using closures when the closure
    # delegates to a function that could be called directly. For example, it
    # would require that
    #
    #     collection.iter().map(|item| item.to_string())
    #
    # be rewritten as:
    #
    #     collection.iter().map(ToString::to_string)
    #
    # This lint is needlessly nitpicky. The author may be maintaining a
    # consistent style with the surrounding code by introducing the closure,
    # especially when closures of various arities are in close proximity,
    # as only closures of zero or one arguments can be rewritten to delegate
    # to the inner function directly. Besides, the needless closure will be
    # trivially optimized away by LLVM.
    clippy::redundant_closure

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#type_complexity
    #
    # clippy::type_complexity disallows types that are excessively nested.
    # Unfortunately Frank McSherry loves highly nested types, and, indeed,
    # sometimes extracting the type alias that Clippy demands makes the types
    # less readable.
    clippy::type_complexity

    # Upstream description: https://rust-lang.github.io/rust-clippy/master/#unneeded_field_pattern
    #
    # clippy::unneeded_field_patterns disallows wildcard struct patterns, like
    # `obj { field1, field2: _ }`, in favor of using `obj { field1, .. }`. This
    # lint is actively harmful. Explicitly matching on every extant field
    # ensures that when a new field is added to the struct in the future,
    # whoever adds the field will be forced to inspect the match site. Using
    # `..`, while sometimes convenient, can cause match sites that need to be
    # updated for the new field to be overlooked.
    clippy::unneeded_field_pattern

    # Upsteam description: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes
    #
    # Lifetime elision sometimes gives surprising results, and especially in unsafe code it's useful to
    # spell out lifetimes explicitly to be sure
    clippy::needless-lifetimes
)

extra_lints=(
    # Upstream description: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#bare-trait-object
    #
    # Omitting `dyn` on a trait object will become deprecated in the near future
    bare_trait_objects

    # We never want to have to back up and thread Debug through all our types again
    # missing_debug_implementations
)

run_clippy() {
    # NOTE(benesch): we ignore some ShellCheck complaints about sloppy word
    # splitting below. It's substantially clearer than doing things "properly,"
    # and the inputs to this script are trusted.

    # shellcheck disable=SC2086
    if [[ $MZ_CHECK_FORCE_BUILD == y ]]; then
        pkgspec=$(sed -nE 's,.*"src/([^"]+)".*,src/\1,p' Cargo.toml)
        echo -n "run> touch"
        for pkg in $pkgspec; do
            for fname in lib.rs main.rs; do
                path="$pkg/$fname"
                if [[ -f "$path"  ]]; then
                    touch "$path"
                    echo -n " $path"
                fi
            done
        done
        echo
    fi
    # shellcheck disable=SC2046
    runv cargo clippy -- -D warnings $(printf -- "-D %s " "${extra_lints[@]}") $(printf -- "-A %s " "${disabled_lints[@]}")
}

main "$@"
