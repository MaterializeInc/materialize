#!/usr/bin/env python3

# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

import glob
import os
import re

BUF_YAML_FILE_PATH = "./src/buf.yaml"
BUF_YAML_TEMPLATE_FILE_PATH = f"{BUF_YAML_FILE_PATH}.template"

SOURCE_DIR = "src/"
PROTO_FILE_GLOB = f"{SOURCE_DIR}**/*.proto"

GENERATION_COMMENT = "File generated by generate-buf-config.py - DO NOT EDIT"
BUF_INSTRUCTION_PREFIX = "// buf breaking:"

# matched examples:
#
# * "ignore"
# * "check"
# * "ignore (database-issues#1000 must be fixed)"
# * "check (we durably persist these protobufs in foobar)"
#
BUF_ACTION_COMMAND = re.compile(r"(ignore|check)( \((.*)\))?")


class ProtoFile:
    def __init__(self, path: str):
        self.path = path
        self.ignore_reason: str | None = None

    def is_ignore(self) -> bool:
        return self.ignore_reason is not None


def collect_proto_files() -> list[ProtoFile]:
    print(f"Working dir: {os.getcwd()}")
    proto_file_paths = glob.glob(PROTO_FILE_GLOB, recursive=True)
    return [ProtoFile(path) for path in proto_file_paths]


def load_buf_instructions(files: list[ProtoFile]) -> None:
    errors = []
    for file in files:
        result = load_buf_instructions_for_file(file)
        if result is not None:
            errors.append(result)

    if len(errors) > 0:
        msg = "\n".join([f"{path}: {error}" for path, error in errors])
        raise RuntimeError(msg)


def load_buf_instructions_for_file(file: ProtoFile) -> tuple[str, str] | None:
    with open(file.path) as lines:
        buf_instruction = None
        for line in lines:
            if line.startswith(BUF_INSTRUCTION_PREFIX):
                if buf_instruction is not None:
                    error = "found multiple buf instructions"
                    return str(file.path), error
                buf_instruction = line

    if buf_instruction is None:
        error = f"no buf instruction found, please specify '{BUF_INSTRUCTION_PREFIX} (check|ignore)'"
        return str(file.path), error
    else:
        return handle_buf_instruction_in_proto_file(file, buf_instruction)


def handle_buf_instruction_in_proto_file(file: ProtoFile, line: str) -> None:
    command = line.removeprefix(BUF_INSTRUCTION_PREFIX).strip()
    match = BUF_ACTION_COMMAND.search(command)

    if not match:
        raise RuntimeError(f"Unsupported buf instruction in {file.path}: {line}")
    elif len(match.groups()) < 2:
        raise RuntimeError(
            f"Must specify either 'buf breaking: ignore' or 'buf breaking: check' in {file.path}"
        )

    action = match.group(1)
    if action == "ignore":
        has_ignore_reason = len(match.groups()) == 3 and match.group(3)
        # groups are not zero-based because group 0 contains the whole match
        file.ignore_reason = (
            match.group(3) if has_ignore_reason else "no reason specified"
        )
    elif action == "check":
        # Nothing to do, let `buf` check this file as normal.
        pass
    else:
        raise RuntimeError(f"Unrecognized buf action '{action}' in {file.path}")


def generate_buf_ignore_section(ignored_files: list[ProtoFile]) -> str:
    ignore_entry_lines = []

    ignored_files = sorted(ignored_files, key=lambda file: file.path)

    for ignored_file in ignored_files:
        relative_path = ignored_file.path.removeprefix(SOURCE_DIR)
        ignore_entry_lines.append(f"    # reason: {ignored_file.ignore_reason}")
        ignore_entry_lines.append(f"    - {relative_path}")

    if len(ignore_entry_lines) == 0:
        ignore_entry_lines.append("     # none")

    return "\n".join(ignore_entry_lines).strip()


def write_buf_configuration(
    template_path: str, target_path: str, ignored_files: list[ProtoFile]
) -> None:

    with open(template_path) as input_file:
        content = input_file.read()
        content = content.replace("${generation-comment}", GENERATION_COMMENT)
        content = content.replace(
            "${ignore-entries}", generate_buf_ignore_section(ignored_files)
        )

    with open(target_path, "w") as output_file:
        output_file.write(content)


def main() -> None:
    proto_files = collect_proto_files()
    print(f"Collected {len(proto_files)} proto files.")

    load_buf_instructions(proto_files)
    ignored_proto_files = [file for file in proto_files if file.is_ignore()]
    print(f"{len(ignored_proto_files)} proto files to be ignored from breaking check.")

    write_buf_configuration(
        BUF_YAML_TEMPLATE_FILE_PATH, BUF_YAML_FILE_PATH, ignored_proto_files
    )
    print(f"Written buf configuration to '{BUF_YAML_FILE_PATH}'.")


if __name__ == "__main__":
    main()
