#!/usr/bin/env python3

# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

import fileinput
import re
import sys
from enum import Enum


class ParserState(Enum):
    NONE = 0
    FIELDS = 1
    HEADER = 2
    SEPARATOR = 3


HEADER_SEPARATOR_RE = re.compile(r"\|?(\s*-+\s*)(\|\s*-+\s*){2}\|?")
# Field names are enclosed in backticks
FIELD_NAME_RE = re.compile(r"`(.*)`")
# Field types are enclosed in backticks and optionally in square brackets
FIELD_TYPE_RE = re.compile(r"\[?`(.*)`\]?")
# Documentation links are not preserved in the SQL comments. We capture the
# text of [..](..) and [..][..] type links and keep only the link text.
DOC_LINK_TYPE1_RE = re.compile(r"\[([^\]]+)\]\([^)]+\)")
DOC_LINK_TYPE2_RE = re.compile(r"\[([^\]]+)\]\[[^]]+\]")
RELATION_MARKER_RE = re.compile(r"RELATION_SPEC (\w+)\.(\w+)")
UNDOCUMENTED_RELATION_MARKER = re.compile(r"RELATION_SPEC_UNDOCUMENTED (\w+)\.(\w+)")

HEADER = """
# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

# This file is auto-generated by ci/test/lint-docs-catalog.py

mode cockroach

simple conn=mz_system,user=mz_system
ALTER SYSTEM SET unsafe_enable_unstable_dependencies = true
----
COMPLETE 0

statement ok
CREATE VIEW objects AS
  SELECT
    schema.name AS schema,
    objects.name AS object,
    columns.position,
    columns.name,
    columns.type,
    comments.comment
  FROM
    mz_catalog.mz_columns AS columns
    JOIN mz_catalog.mz_objects AS objects ON columns.id = objects.id
    JOIN mz_catalog.mz_schemas AS schema ON objects.schema_id = schema.id
    LEFT JOIN mz_internal.mz_comments AS comments ON columns.id = comments.id AND columns.position = comments.object_sub_id

statement ok
CREATE INDEX objects_idx ON objects(schema, object)
"""


def main() -> None:
    print(HEADER)

    state = ParserState.NONE
    position = 1
    objects = []
    schemas = set()
    for line in fileinput.input(sys.argv):
        if state == ParserState.NONE:
            undocumented = UNDOCUMENTED_RELATION_MARKER.search(line)
            if undocumented:
                schema = undocumented.group(1)
                object_name = undocumented.group(2)
                objects.append(object_name)
                schemas.add(f"'{schema}'")
                continue
            marker_match = RELATION_MARKER_RE.search(line)
            if marker_match:
                schema = marker_match.group(1)
                object_name = marker_match.group(2)
                print("query TTT")
                print(
                    f"SELECT name, type, comment FROM objects WHERE schema = '{schema}' AND object = '{object_name}' ORDER BY position"
                )
                print("----")
                state = ParserState.HEADER
                objects.append(object_name)
                schemas.add(f"'{schema}'")
        elif state == ParserState.HEADER:
            if HEADER_SEPARATOR_RE.match(line):
                state = ParserState.FIELDS
        elif state == ParserState.FIELDS:
            line = line.strip()
            if line.startswith("|"):
                line = line[1:]
            fields = [field.strip() for field in line.split("|")]
            if len(fields) >= 3:
                field = FIELD_NAME_RE.search(fields[0]).group(1)
                type_name = FIELD_TYPE_RE.search(fields[1]).group(1)
                documentation = DOC_LINK_TYPE1_RE.sub(r"\1", fields[2])
                documentation = DOC_LINK_TYPE2_RE.sub(r"\1", documentation)
                # We currently cannot determine the type of lists from the catalog.
                if type_name == "mz_aclitem array":
                    type_name = "mz_aclitem[]"
                elif type_name == "text array":
                    type_name = "text[]"
                elif "list" in type_name:
                    type_name = "list"
                elif "array" in type_name:
                    type_name = "array"
                type_name = type_name.replace(" ", "␠")
                documentation = documentation.replace(" ", "␠")
                print("  ".join([field, type_name, documentation]))
                position += 1
            else:
                print()
                state = ParserState.NONE
                position = 1

    if objects:
        print("query T")
        schemas_str = ",".join(schemas)
        print(
            f"SELECT DISTINCT object FROM objects WHERE schema IN ({schemas_str}) ORDER BY object"
        )
        print("----")
        for object_name in sorted(objects):
            print(object_name)


if __name__ == "__main__":
    main()
