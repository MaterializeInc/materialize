# User-defined functions: SQL language

## Summary

Let users name and parameterize arbitrary SQL queries as functions, i.e. support
[`CREATE FUNCTION ... LANGUAGE
SQL`](https://www.postgresql.org/docs/current/sql-createfunction.html).

This document is largely adapted from @benesch's original issue,
[#5112](https://github.com/MaterializeInc/materialize/issues/5112).

## Goals

- Support `CREATE FUNCTION ... LANGUAGE SQL` for scalar expressions.
- Store created functions in the catalog to match Postgres' semantics for
  user-created functions.
- Support `DROP FUNCTION`.

## Non-Goals

  * Named function parameters. Our current parameter expressions do not support
    named values, only positional references (e.g. `$1`), so the V1
    implementation will similarly not support named parameters. <sup>1</sup>
  * Variadic functions. PG variadic semantics convert all variadic parameters to
    elements of an array; `sql_op!` doesn't currently support that.<sup>1</sup>
  * Polymorphic functions. Polymorphic types are not yet in the catalog, which I
    think will be necessary to support this, though it's possible to have a
    hacky workaround if this becomes crucial.<sup>1</sup>
  * Updates to functions.
  * Any language other than SQL.
  * WASM/arbitrary code execution.
  * `OUT` parameters.
  *  Default arguments.
  * `RETURNS TABLE`, i.e. we will only support scalar expressions, not
    table-generating expressions. However, `RETURNS SETOF` should work.
  * `WINDOW` functions.
  * `STABLE` or `VOLATILE` functions.
  * `SECURITY INVOKER` and `SECURITY DEFINER`.
  * Any of the other parameters that inform the PostgreSQL optimizer about the
    function's behavior, like `COST` or `ROWS`.

<sup>1</sup> While these are non-goals for V1, nothing precludes adding them in
the near-future after V1.

## Description

As of [#5547](https://github.com/MaterializeInc/materialize/pull/5547), SQL
functions are stored in the catalog. To support UDFs, we'll simply insert a new
function with a structure equivalent to a function that uses the `sql_op!` macro
into the catalog. For examples of approximately how this will work, see
`src/sql/src/func.rs`. The tl;dr is that it will essentially inline the
query at each invocation.

#### Required code changes

- Creating `sql::func::Func::Scalar` (i.e `sql::func::FuncImpl<HirScalarExpr>`)
  from user input, which includes generating...
  - `Operation<HirScalarExpr>` using `sql_op!`, which already exists.
  - `ParamList`, by resolving type names to `ScalarType`, then `ParamType`, then
    `ParamList`.

- Modifying `coord::catalog::Func` to permit serde on UDFs. Right now, the
  struct only supports built-in functions, which are _not_ serialized to the
  catalog (they are instead inserted into the catalog on each boot). This
  probably means adding something like `create_sql: Option<String>` and allowing
  structs whose value is `None` to skip serialization.

Everything else (parsing, invocation) is very straightforward.

## Alternatives

No alternative designs have been seriously considered.

## Open questions

All open questions we've had revolve around subsequent iterations of this
feature, which are out of the scope of this design doc.
