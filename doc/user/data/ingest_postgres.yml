- name: before-you-begin
  content: |
    - Make sure you are running PostgreSQL 11 or higher.

    - Make sure you have access to your PostgreSQL instance via [`psql`](https://www.postgresql.org/docs/current/app-psql.html),
      or your preferred SQL client.

- name: create-a-cluster
  content: |
    In Materialize, a [cluster](/concepts/clusters/) is an isolated environment,
    similar to a virtual warehouse in Snowflake. When you create a cluster, you
    choose the size of its compute resource allocation based on the work you need
    the cluster to do, whether ingesting data from a source, computing
    always-up-to-date query results, serving results to external clients, or a
    combination.

    In this step, you'll create a dedicated cluster for ingesting source data from
    your PostgreSQL database.

    1. In the [SQL Shell](/console/), or your preferred SQL
       client connected to Materialize, use the [`CREATE CLUSTER`](/sql/create-cluster/)
       command to create the new cluster:

        ```mzsql
        CREATE CLUSTER ingest_postgres (SIZE = '50cc');

        SET CLUSTER = ingest_postgres;
        ```

        A cluster of [size](/sql/create-cluster/#size) `50cc` should be enough to
        accommodate multiple PostgreSQL sources, depending on the source
        characteristics (e.g., sources with [`ENVELOPE UPSERT`](/sql/create-source/kafka/#upsert-envelope)
        or [`ENVELOPE DEBEZIUM`](/sql/create-source/kafka/#debezium-envelope) will be more
        memory-intensive) and the upstream traffic patterns. You can readjust the
        size of the cluster at any time using the [`ALTER CLUSTER`](/sql/alter-cluster) command:

        ```mzsql
        ALTER CLUSTER <cluster_name> SET ( SIZE = <new_size> );
        ```

- name: create-a-publication-aws
  content: |
    Once logical replication is enabled, create a publication with the tables that
    you want to replicate to Materialize. You'll also need a user for Materialize
    with sufficient privileges to manage replication.

    1. As a _superuser_, use `psql` (or your preferred SQL client) to connect to
       your database.

    1. For each table that you want to replicate to Materialize, set the
       [replica identity](https://www.postgresql.org/docs/current/sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY)
       to `FULL`:

        ```postgres
        ALTER TABLE <table1> REPLICA IDENTITY FULL;
        ```

        ```postgres
        ALTER TABLE <table2> REPLICA IDENTITY FULL;
        ```

        `REPLICA IDENTITY FULL` ensures that the replication stream includes the
        previous data of changed rows, in the case of `UPDATE` and `DELETE`
        operations. This setting enables Materialize to ingest PostgreSQL data with
        minimal in-memory state. However, you should expect increased disk usage in
        your PostgreSQL database.

    1. Create a [publication](https://www.postgresql.org/docs/current/logical-replication-publication.html)
       with the tables you want to replicate:

        _For specific tables:_

        ```postgres
        CREATE PUBLICATION mz_source FOR TABLE <table1>, <table2>;
        ```

        _For all tables in the database:_

        ```postgres
        CREATE PUBLICATION mz_source FOR ALL TABLES;
        ```

        The `mz_source` publication will contain the set of change events generated
        from the specified tables, and will later be used to ingest the replication
        stream.

        Be sure to include only the tables you need. If the publication includes
        additional tables, Materialize will waste resources on ingesting and then
        immediately discarding the data.

    1. Create a user for Materialize, if you don't already have one:

        ```postgres
        CREATE USER materialize PASSWORD '<password>';
        ```

    1. Grant the user permission to manage replication:

        ```postgres
        GRANT rds_replication TO materialize;
        ```

    1. Grant the user the required permissions on the tables you want to replicate:

        ```postgres
        GRANT CONNECT ON DATABASE <dbname> TO materialize;
        ```

        ```postgres
        GRANT USAGE ON SCHEMA <schema> TO materialize;
        ```

        ```postgres
        GRANT SELECT ON <table1> TO materialize;
        ```

        ```postgres
        GRANT SELECT ON <table2> TO materialize;
        ```

        Once connected to your database, Materialize will take an initial snapshot
        of the tables in your publication. `SELECT` privileges are required for
        this initial snapshot.

        If you expect to add tables to your publication, you can grant `SELECT` on
        all tables in the schema instead of naming the specific tables:

        ```postgres
        GRANT SELECT ON ALL TABLES IN SCHEMA <schema> TO materialize;
        ```

- name: create-a-publication-other
  content: |
    Once logical replication is enabled, the next step is to create a publication
    with the tables that you want to replicate to Materialize. You'll also need a
    user for Materialize with sufficient privileges to manage replication.

    1. For each table that you want to replicate to Materialize, set the
       [replica identity](https://www.postgresql.org/docs/current/sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY)
       to `FULL`:

        ```postgres
        ALTER TABLE <table1> REPLICA IDENTITY FULL;
        ```

        ```postgres
        ALTER TABLE <table2> REPLICA IDENTITY FULL;
        ```

        `REPLICA IDENTITY FULL` ensures that the replication stream includes the
        previous data of changed rows, in the case of `UPDATE` and `DELETE`
        operations. This setting enables Materialize to ingest PostgreSQL data with
        minimal in-memory state. However, you should expect increased disk usage in
        your PostgreSQL database.

    1. Create a [publication](https://www.postgresql.org/docs/current/logical-replication-publication.html)
       with the tables you want to replicate:

        _For specific tables:_

        ```postgres
        CREATE PUBLICATION mz_source FOR TABLE <table1>, <table2>;
        ```

        _For all tables in the database:_

        ```postgres
        CREATE PUBLICATION mz_source FOR ALL TABLES;
        ```

        The `mz_source` publication will contain the set of change events generated
        from the specified tables, and will later be used to ingest the replication
        stream.

        Be sure to include only the tables you need. If the publication includes
        additional tables, Materialize will waste resources on ingesting and then
        immediately discarding the data.

    1. Create a user for Materialize, if you don't already have one:

        ```postgres
        CREATE USER materialize PASSWORD '<password>';
        ```

    1. Grant the user permission to manage replication:

        ```postgres
        ALTER ROLE materialize WITH REPLICATION;
        ```

    1. Grant the user the required permissions on the tables you want to replicate:

        ```postgres
        GRANT CONNECT ON DATABASE <dbname> TO materialize;
        ```

        ```postgres
        GRANT USAGE ON SCHEMA <schema> TO materialize;
        ```

        ```postgres
        GRANT SELECT ON <table1> TO materialize;
        ```

        ```postgres
        GRANT SELECT ON <table2> TO materialize;
        ```

        Once connected to your database, Materialize will take an initial snapshot
        of the tables in your publication. `SELECT` privileges are required for
        this initial snapshot.

        If you expect to add tables to your publication, you can grant `SELECT` on
        all tables in the schema instead of naming the specific tables:

        ```postgres
        GRANT SELECT ON ALL TABLES IN SCHEMA <schema> TO materialize;
        ```

- name: check-the-ingestion-status
  content: |
    Before it starts consuming the replication stream, Materialize takes a snapshot
    of the relevant tables in your publication. Until this snapshot is complete,
    Materialize won't have the same view of your data as your PostgreSQL database.

    In this step, you'll first verify that the source is running and then check the
    status of the snapshotting process.

    1. Back in the SQL client connected to Materialize, use the
       [`mz_source_statuses`](/sql/system-catalog/mz_internal/#mz_source_statuses)
       table to check the overall status of your source:

        ```mzsql
        WITH
          source_ids AS
          (SELECT id FROM mz_sources WHERE name = 'mz_source')
        SELECT *
        FROM
          mz_internal.mz_source_statuses
            JOIN
              (
                SELECT referenced_object_id
                FROM mz_internal.mz_object_dependencies
                WHERE
                  object_id IN (SELECT id FROM source_ids)
                UNION SELECT id FROM source_ids
              )
              AS sources
            ON mz_source_statuses.id = sources.referenced_object_id;
        ```

        For each `subsource`, make sure the `status` is `running`. If you see
        `stalled` or `failed`, there's likely a configuration issue for you to fix.
        Check the `error` field for details and fix the issue before moving on.
        Also, if the `status` of any subsource is `starting` for more than a few
        minutes, [contact our team](/support/).

    2. Once the source is running, use the [`mz_source_statistics`](/sql/system-catalog/mz_internal/#mz_source_statistics)
       table to check the status of the initial snapshot:

        ```mzsql
        WITH
          source_ids AS
          (SELECT id FROM mz_sources WHERE name = 'mz_source')
        SELECT sources.referenced_object_id AS id, mz_sources.name, snapshot_committed
        FROM
          mz_internal.mz_source_statistics
            JOIN
              (
                SELECT object_id, referenced_object_id
                FROM mz_internal.mz_object_dependencies
                WHERE
                  object_id IN (SELECT id FROM source_ids)
                UNION SELECT id, id FROM source_ids
              )
              AS sources
            ON mz_source_statistics.id = sources.referenced_object_id
            JOIN mz_sources ON mz_sources.id = sources.referenced_object_id;
        ```
        <p></p>

        ```nofmt
        object_id | snapshot_committed
        ----------|------------------
         u144     | t
        (1 row)
        ```

        Once `snapshot_commited` is `t`, move on to the next step. Snapshotting can
        take between a few minutes to several hours, depending on the size of your
        dataset and the size of the cluster the source is running in.

- name: right-size-the-cluster
  content: |
    After the snapshotting phase, Materialize starts ingesting change events from
    the PostgreSQL replication stream. For this work, Materialize generally
    performs well with an `100cc` replica, so you can resize the cluster
    accordingly.

    1. Still in a SQL client connected to Materialize, use the [`ALTER CLUSTER`](/sql/alter-cluster/)
       command to downsize the cluster to `100cc`:

        ```mzsql
        ALTER CLUSTER ingest_postgres SET (SIZE '100cc');
        ```

        Behind the scenes, this command adds a new `100cc` replica and removes the
        `50cc` replica.

    1. Use the [`SHOW CLUSTER REPLICAS`](/sql/show-cluster-replicas/) command to
       check the status of the new replica:

        ```mzsql
        SHOW CLUSTER REPLICAS WHERE cluster = 'ingest_postgres';
        ```
        <p></p>

        ```nofmt
             cluster     | replica |  size  | ready
        -----------------+---------+--------+-------
         ingest_postgres | r1      | 100cc  | t
        (1 row)
        ```

    1. Going forward, you can verify that your new cluster size is sufficient as
    follows:

        1. In Materialize, get the replication slot name associated with your
        PostgreSQL source from the [`mz_internal.mz_postgres_sources`](/sql/system-catalog/mz_internal/#mz_postgres_sources)
        table:

            ```mzsql
            SELECT
                d.name AS database_name,
                n.name AS schema_name,
                s.name AS source_name,
                pgs.replication_slot
            FROM
                mz_sources AS s
                JOIN mz_internal.mz_postgres_sources AS pgs ON s.id = pgs.id
                JOIN mz_schemas AS n ON n.id = s.schema_id
                JOIN mz_databases AS d ON d.id = n.database_id;
            ```

        1. In PostgreSQL, check the replication slot lag, using the replication slot
           name from the previous step:

            ```postgres
            SELECT
                pg_size_pretty(pg_current_wal_lsn() - confirmed_flush_lsn)
                AS replication_lag_bytes
            FROM pg_replication_slots
            WHERE slot_name = '<slot_name>';
            ```

            The result of this query is the amount of data your PostgreSQL cluster
            must retain in its replication log because of this replication slot.
            Typically, this means Materialize has not yet communicated back to
            PostgreSQL that it has committed this data. A high value can indicate
            that the source has fallen behind and that you might need to scale up
            your ingestion cluster.

- name: next-steps
  content: |
    With Materialize ingesting your PostgreSQL data into durable storage, you can
    start exploring the data, computing real-time results that stay up-to-date as
    new data arrives, and serving results efficiently.

    - Explore your data with [`SHOW SOURCES`](/sql/show-sources) and [`SELECT`](/sql/select/).

    - Compute real-time results in memory with [`CREATE VIEW`](/sql/create-view/)
      and [`CREATE INDEX`](/sql/create-index/) or in durable
      storage with [`CREATE MATERIALIZED VIEW`](/sql/create-materialized-view/).

    - Serve results to a PostgreSQL-compatible SQL client or driver with [`SELECT`](/sql/select/)
      or [`SUBSCRIBE`](/sql/subscribe/) or to an external message broker with
      [`CREATE SINK`](/sql/create-sink/).

    - Check out the [tools and integrations](/integrations/) supported by
      Materialize.
