The in-memory sizes of indexes are proportional to the current size of the
source or view they represent. The actual amount of memory required depends on
several details related to the rate of compaction and the representation of the
types of data in the source or view.

Creating an index may also force the first materialization of a view, which may
cause Materialize to install a dataflow to determine and maintain the results of
the view. This dataflow may have a memory footprint itself, in addition to that
of the index.
