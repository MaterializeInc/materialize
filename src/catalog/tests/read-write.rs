// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(unknown_lints)]
#![allow(clippy::style)]
#![allow(clippy::complexity)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::mutable_key_type)]
#![allow(clippy::stable_sort_primitive)]
#![allow(clippy::map_entry)]
#![allow(clippy::box_default)]
#![allow(clippy::drain_collect)]
#![warn(clippy::bool_comparison)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::no_effect)]
#![warn(clippy::unnecessary_unwrap)]
#![warn(clippy::dbg_macro)]
#![warn(clippy::todo)]
#![warn(clippy::wildcard_dependencies)]
#![warn(clippy::zero_prefixed_literal)]
#![warn(clippy::borrowed_box)]
#![warn(clippy::deref_addrof)]
#![warn(clippy::double_must_use)]
#![warn(clippy::double_parens)]
#![warn(clippy::extra_unused_lifetimes)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_question_mark)]
#![warn(clippy::needless_return)]
#![warn(clippy::redundant_pattern)]
#![warn(clippy::redundant_slicing)]
#![warn(clippy::redundant_static_lifetimes)]
#![warn(clippy::single_component_path_imports)]
#![warn(clippy::unnecessary_cast)]
#![warn(clippy::useless_asref)]
#![warn(clippy::useless_conversion)]
#![warn(clippy::builtin_type_shadow)]
#![warn(clippy::duplicate_underscore_argument)]
#![warn(clippy::double_neg)]
#![warn(clippy::unnecessary_mut_passed)]
#![warn(clippy::wildcard_in_or_patterns)]
#![warn(clippy::crosspointer_transmute)]
#![warn(clippy::excessive_precision)]
#![warn(clippy::overflow_check_conditional)]
#![warn(clippy::as_conversions)]
#![warn(clippy::match_overlapping_arm)]
#![warn(clippy::zero_divided_by_zero)]
#![warn(clippy::must_use_unit)]
#![warn(clippy::suspicious_assignment_formatting)]
#![warn(clippy::suspicious_else_formatting)]
#![warn(clippy::suspicious_unary_op_formatting)]
#![warn(clippy::mut_mutex_lock)]
#![warn(clippy::print_literal)]
#![warn(clippy::same_item_push)]
#![warn(clippy::useless_format)]
#![warn(clippy::write_literal)]
#![warn(clippy::redundant_closure)]
#![warn(clippy::redundant_closure_call)]
#![warn(clippy::unnecessary_lazy_evaluations)]
#![warn(clippy::partialeq_ne_impl)]
#![warn(clippy::redundant_field_names)]
#![warn(clippy::transmutes_expressible_as_ptr_casts)]
#![warn(clippy::unused_async)]
#![warn(clippy::disallowed_methods)]
#![warn(clippy::disallowed_macros)]
#![warn(clippy::disallowed_types)]
#![warn(clippy::from_over_into)]
// END LINT CONFIG

use itertools::Itertools;
use mz_audit_log::{
    CreateClusterReplicaV1, EventDetails, EventType, EventV1, IdNameV1, StorageUsageV1,
    VersionedEvent, VersionedStorageUsage,
};
use mz_catalog::objects::{Config, DurableType, IdAlloc, IntrospectionSourceIndex};
use mz_catalog::objects::{SystemObjectDescription, SystemObjectUniqueIdentifier};
use mz_catalog::{
    debug_bootstrap_args, debug_stash_backed_catalog_state, persist_backed_catalog_state,
    CatalogError, Cluster, ClusterConfig, ClusterReplica, ClusterVariant, Comment, Database,
    DefaultPrivilege, DurableCatalogError, Item, OpenableDurableCatalogState, ReplicaConfig,
    ReplicaLocation, Role, Schema, SystemConfiguration, SystemObjectMapping, TimelineTimestamp,
    DATABASE_ID_ALLOC_KEY, SCHEMA_ID_ALLOC_KEY, USER_ITEM_ALLOC_KEY, USER_ROLE_ID_ALLOC_KEY,
};
use mz_controller::clusters::ReplicaLogging;
use mz_controller_types::{ClusterId, ReplicaId};
use mz_ore::collections::CollectionExt;
use mz_ore::now::SYSTEM_TIME;
use mz_persist_client::PersistClient;
use mz_proto::RustType;
use mz_repr::adt::mz_acl_item::{AclMode, MzAclItem};
use mz_repr::role_id::RoleId;
use mz_repr::GlobalId;
use mz_sql::catalog::{
    CatalogItemType, DefaultPrivilegeAclItem, DefaultPrivilegeObject, ObjectType, RoleAttributes,
    RoleMembership,
};
use mz_sql::names::{CommentObjectId, DatabaseId, SchemaId};
use mz_stash::DebugStashFactory;
use mz_stash_types::objects::proto;
use mz_storage_types::sources::Timeline;
use std::time::Duration;
use uuid::Uuid;

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_confirm_leadership() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state1 = debug_stash_backed_catalog_state(&debug_factory);
    let openable_state2 = debug_stash_backed_catalog_state(&debug_factory);
    test_confirm_leadership(openable_state1, openable_state2).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_confirm_leadership() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state1 =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    let openable_state2 = persist_backed_catalog_state(persist_client, organization_id).await;
    test_confirm_leadership(openable_state1, openable_state2).await;
}

async fn test_confirm_leadership(
    openable_state1: impl OpenableDurableCatalogState,
    openable_state2: impl OpenableDurableCatalogState,
) {
    let mut state1 = Box::new(openable_state1)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    assert!(state1.confirm_leadership().await.is_ok());

    let mut state2 = Box::new(openable_state2)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    assert!(state2.confirm_leadership().await.is_ok());

    let err = state1.confirm_leadership().await.unwrap_err();
    assert!(matches!(
        err,
        CatalogError::Durable(DurableCatalogError::Fence(_))
    ));

    // Test that state1 can't start a transaction.
    let err = match state1.transaction().await {
        Ok(_) => panic!("unexpected Ok"),
        Err(e) => e,
    };
    assert!(matches!(
        err,
        CatalogError::Durable(DurableCatalogError::Fence(_))
    ));
    Box::new(state1).expire().await;
    Box::new(state2).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_catalog_content_version() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_catalog_content_version(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_catalog_content_version() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_catalog_content_version(openable_state).await;
}

async fn test_catalog_content_version(openable_state: impl OpenableDurableCatalogState) {
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    assert!(state.get_catalog_content_version().await.unwrap().is_none());
    state.set_catalog_content_version("foo").await.unwrap();
    assert_eq!(
        state.get_catalog_content_version().await.unwrap().unwrap(),
        "foo"
    );
    assert_eq!(
        state
            .snapshot()
            .await
            .unwrap()
            .settings
            .get(&proto::SettingKey {
                name: "catalog_content_version".to_string()
            })
            .unwrap()
            .value,
        "foo".to_string()
    );
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_get_and_prune_storage_usage() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_get_and_prune_storage_usage(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_get_and_prune_storage_usage() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_get_and_prune_storage_usage(openable_state).await;
}

async fn test_get_and_prune_storage_usage(openable_state: impl OpenableDurableCatalogState) {
    let old_event = VersionedStorageUsage::V1(StorageUsageV1 {
        id: 1,
        shard_id: Some("recent".to_string()),
        size_bytes: 42,
        collection_timestamp: 10,
    });
    let recent_event = VersionedStorageUsage::V1(StorageUsageV1 {
        id: 1,
        shard_id: Some("recent".to_string()),
        size_bytes: 42,
        collection_timestamp: 20,
    });
    let boot_ts = mz_repr::Timestamp::new(23);

    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let mut txn = state.transaction().await.unwrap();
    txn.insert_storage_usage_event(old_event.clone());
    txn.insert_storage_usage_event(recent_event.clone());
    txn.commit().await.unwrap();

    // Test with no retention period.
    let events = state
        .get_and_prune_storage_usage(None, boot_ts)
        .await
        .unwrap();
    assert_eq!(events.len(), 2);
    assert!(events.contains(&old_event));
    assert!(events.contains(&recent_event));

    // Test with some retention period.
    let events = state
        .get_and_prune_storage_usage(Some(Duration::from_millis(10)), boot_ts)
        .await
        .unwrap();
    assert_eq!(events.len(), 1);
    assert_eq!(events.into_element(), recent_event);
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_system_items() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_system_items(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_system_items() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_system_items(openable_state).await;
}

async fn test_system_items(openable_state: impl OpenableDurableCatalogState) {
    let mappings = [
        SystemObjectMapping {
            description: SystemObjectDescription {
                schema_name: "foo".to_string(),
                object_type: CatalogItemType::Table,
                object_name: "bar".to_string(),
            },
            unique_identifier: SystemObjectUniqueIdentifier {
                id: GlobalId::System(42),
                fingerprint: "abcd".to_string(),
            },
        },
        SystemObjectMapping {
            description: SystemObjectDescription {
                schema_name: "public".to_string(),
                object_type: CatalogItemType::View,
                object_name: "v".to_string(),
            },
            unique_identifier: SystemObjectUniqueIdentifier {
                id: GlobalId::System(43),
                fingerprint: "hsokj".to_string(),
            },
        },
    ];
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();

    state.set_system_items(mappings.to_vec()).await.unwrap();

    assert_eq!(state.get_system_items().await.unwrap(), mappings.to_vec());
    let snapshot_mappings: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .system_object_mappings
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| SystemObjectMapping::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    assert_eq!(snapshot_mappings, mappings.to_vec());
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_introspection_source_indexes() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_introspection_source_indexes(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_introspection_source_indexes() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_introspection_source_indexes(openable_state).await;
}

async fn test_introspection_source_indexes(openable_state: impl OpenableDurableCatalogState) {
    let mappings = [
        IntrospectionSourceIndex {
            cluster_id: ClusterId::User(1),
            name: "foo".to_string(),
            index_id: GlobalId::System(1),
        },
        IntrospectionSourceIndex {
            cluster_id: ClusterId::User(2),
            name: "bar".to_string(),
            index_id: GlobalId::System(2),
        },
    ];
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();

    state
        .set_introspection_source_indexes(mappings.to_vec())
        .await
        .unwrap();

    assert_eq!(
        state
            .get_introspection_source_indexes(mappings[0].cluster_id)
            .await
            .unwrap()
            .get(&mappings[0].name)
            .unwrap(),
        &mappings[0].index_id
    );
    assert_eq!(
        state
            .get_introspection_source_indexes(mappings[1].cluster_id)
            .await
            .unwrap()
            .get(&mappings[1].name)
            .unwrap(),
        &mappings[1].index_id
    );
    let snapshot_mappings: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .introspection_sources
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| IntrospectionSourceIndex::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    assert_eq!(snapshot_mappings, mappings.to_vec());
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_replicas() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_replicas(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_replicas() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_replicas(openable_state).await;
}

async fn test_replicas(openable_state: impl OpenableDurableCatalogState) {
    let replica = ClusterReplica {
        cluster_id: ClusterId::User(1),
        replica_id: ReplicaId::User(1),
        name: "foo".to_string(),
        config: ReplicaConfig {
            location: ReplicaLocation::Managed {
                size: "1".to_string(),
                availability_zone: None,
                disk: false,
                internal: false,
                billed_as: None,
            },
            logging: ReplicaLogging::default(),
            idle_arrangement_merge_effort: None,
        },
        owner_id: RoleId::User(1),
    };
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();

    state
        .set_replica_config(
            replica.replica_id.clone(),
            replica.cluster_id.clone(),
            replica.name.clone(),
            replica.config.clone(),
            replica.owner_id.clone(),
        )
        .await
        .unwrap();

    let persisted_replicas = state.get_cluster_replicas().await.unwrap();
    assert!(persisted_replicas.contains(&replica));
    let snapshot_replicas: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .cluster_replicas
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| ClusterReplica::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    assert!(snapshot_replicas.contains(&replica));
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_timestamps() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_timestamps(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_timestamps() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_timestamps(openable_state).await;
}

async fn test_timestamps(openable_state: impl OpenableDurableCatalogState) {
    let timeline_timestamp = TimelineTimestamp {
        timeline: Timeline::User("Mars".to_string()),
        ts: mz_repr::Timestamp::new(42),
    };
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();

    state
        .set_timestamp(&timeline_timestamp.timeline, timeline_timestamp.ts)
        .await
        .unwrap();

    assert_eq!(
        state
            .get_timestamp(&timeline_timestamp.timeline)
            .await
            .unwrap()
            .unwrap(),
        timeline_timestamp.ts
    );
    let persisted_timestamps = state.get_timestamps().await.unwrap();
    assert!(persisted_timestamps.contains(&timeline_timestamp),);
    let snapshot_timeline_timestamps: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .timestamps
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| TimelineTimestamp::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    assert!(snapshot_timeline_timestamps.contains(&timeline_timestamp));
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_deploy_generation() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_deploy_generation(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_deploy_generation() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_deploy_generation(openable_state).await;
}

async fn test_deploy_generation(openable_state: impl OpenableDurableCatalogState) {
    let deploy_generation = 42;
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();

    state
        .set_deploy_generation(deploy_generation)
        .await
        .unwrap();

    let snapshot_configs: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .configs
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| Config::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    assert!(snapshot_configs.contains(&Config {
        key: "deploy_generation".to_string(),
        value: deploy_generation
    }));
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_allocate_id() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_allocate_id(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_allocate_id() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_allocate_id(openable_state).await;
}

async fn test_allocate_id(openable_state: impl OpenableDurableCatalogState) {
    let id_type = USER_ITEM_ALLOC_KEY;
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();

    let start_id = state.get_next_id(id_type).await.unwrap();
    let ids = state.allocate_id(id_type, 3).await.unwrap();
    assert_eq!(ids, (start_id..(start_id + 3)).collect::<Vec<_>>());

    let snapshot_id_allocs: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .id_allocator
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| IdAlloc::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    assert!(snapshot_id_allocs.contains(&IdAlloc {
        name: id_type.to_string(),
        next_id: start_id + 3,
    }));
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_clusters() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_clusters(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_clusters() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_clusters(openable_state).await;
}

async fn test_clusters(openable_state: impl OpenableDurableCatalogState) {
    let clusters = [
        Cluster {
            id: ClusterId::User(10),
            name: "foo".to_string(),
            linked_object_id: None,
            owner_id: RoleId::User(1),
            privileges: Vec::new(),
            config: ClusterConfig {
                variant: ClusterVariant::Unmanaged,
            },
        },
        Cluster {
            id: ClusterId::User(20),
            name: "bar".to_string(),
            linked_object_id: None,
            owner_id: RoleId::User(2),
            privileges: Vec::new(),
            config: ClusterConfig {
                variant: ClusterVariant::Unmanaged,
            },
        },
    ];
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();

    let mut txn = state.transaction().await.unwrap();
    for cluster in &clusters {
        txn.insert_user_cluster(
            cluster.id,
            &cluster.name,
            cluster.linked_object_id,
            Vec::new(),
            cluster.owner_id,
            cluster.privileges.clone(),
            cluster.config.clone(),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_clusters = state.get_clusters().await.unwrap();
    for cluster in &clusters {
        assert!(persisted_clusters.contains(cluster));
    }

    let snapshot_clusters: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .clusters
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| Cluster::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for cluster in &clusters {
        assert!(snapshot_clusters.contains(cluster));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_databases() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_databases(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_databases() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_databases(openable_state).await;
}

async fn test_databases(openable_state: impl OpenableDurableCatalogState) {
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let database_id = state.get_next_id(DATABASE_ID_ALLOC_KEY).await.unwrap();
    let databases = [
        Database {
            id: DatabaseId::User(database_id),
            name: "foo".to_string(),
            owner_id: RoleId::User(1),
            privileges: Vec::new(),
        },
        Database {
            id: DatabaseId::User(database_id + 1),
            name: "bar".to_string(),
            owner_id: RoleId::User(1),
            privileges: Vec::new(),
        },
    ];

    let mut txn = state.transaction().await.unwrap();
    for database in &databases {
        txn.insert_user_database(
            &database.name,
            database.owner_id,
            database.privileges.clone(),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_databases = state.get_databases().await.unwrap();
    for database in &databases {
        assert!(persisted_databases.contains(database));
    }

    let snapshot_databases: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .databases
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| Database::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for database in &databases {
        assert!(snapshot_databases.contains(database));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_schemas() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_schemas(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_schemas() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_schemas(openable_state).await;
}

async fn test_schemas(openable_state: impl OpenableDurableCatalogState) {
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let schema_id = state.get_next_id(SCHEMA_ID_ALLOC_KEY).await.unwrap();
    let schemas = [
        Schema {
            id: SchemaId::User(schema_id),
            name: "foo".to_string(),
            database_id: Some(DatabaseId::User(1)),
            owner_id: RoleId::User(1),
            privileges: Vec::new(),
        },
        Schema {
            id: SchemaId::User(schema_id + 1),
            name: "bar".to_string(),
            database_id: Some(DatabaseId::User(1)),
            owner_id: RoleId::User(1),
            privileges: Vec::new(),
        },
    ];

    let mut txn = state.transaction().await.unwrap();
    for schema in &schemas {
        txn.insert_user_schema(
            schema.database_id.clone().expect("set above"),
            &schema.name,
            schema.owner_id,
            schema.privileges.clone(),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_schemas = state.get_schemas().await.unwrap();
    for schema in &schemas {
        assert!(persisted_schemas.contains(schema));
    }

    let snapshot_schemas: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .schemas
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| Schema::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for schema in &schemas {
        assert!(snapshot_schemas.contains(schema));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_roles() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_roles(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_roles() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_roles(openable_state).await;
}

async fn test_roles(openable_state: impl OpenableDurableCatalogState) {
    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let role_id = state.get_next_id(USER_ROLE_ID_ALLOC_KEY).await.unwrap();
    let roles = [
        Role {
            id: RoleId::User(role_id),
            name: "foo".to_string(),
            attributes: RoleAttributes::new(),
            membership: RoleMembership {
                map: Default::default(),
            },
            vars: Default::default(),
        },
        Role {
            id: RoleId::User(role_id + 1),
            name: "bar".to_string(),
            attributes: RoleAttributes::new(),
            membership: RoleMembership {
                map: Default::default(),
            },
            vars: Default::default(),
        },
    ];

    let mut txn = state.transaction().await.unwrap();
    for role in &roles {
        txn.insert_user_role(
            role.name.clone(),
            role.attributes.clone(),
            role.membership.clone(),
            role.vars.clone(),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_roles = state.get_roles().await.unwrap();
    for role in &roles {
        assert!(persisted_roles.contains(role));
    }

    let snapshot_roles: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .roles
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| Role::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for role in &roles {
        assert!(snapshot_roles.contains(role));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_default_privileges() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_default_privileges(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_default_privileges() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_default_privileges(openable_state).await;
}

async fn test_default_privileges(openable_state: impl OpenableDurableCatalogState) {
    let default_privileges = [
        DefaultPrivilege {
            object: DefaultPrivilegeObject {
                role_id: RoleId::User(1),
                database_id: None,
                schema_id: None,
                object_type: ObjectType::Table,
            },
            acl_item: DefaultPrivilegeAclItem {
                grantee: RoleId::User(2),
                acl_mode: AclMode::all(),
            },
        },
        DefaultPrivilege {
            object: DefaultPrivilegeObject {
                role_id: RoleId::User(3),
                database_id: None,
                schema_id: None,
                object_type: ObjectType::View,
            },
            acl_item: DefaultPrivilegeAclItem {
                grantee: RoleId::User(4),
                acl_mode: AclMode::CREATE,
            },
        },
    ];

    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let mut txn = state.transaction().await.unwrap();
    for default_privilege in &default_privileges {
        txn.set_default_privilege(
            default_privilege.object.role_id,
            default_privilege.object.database_id,
            default_privilege.object.schema_id,
            default_privilege.object.object_type,
            default_privilege.acl_item.grantee,
            Some(default_privilege.acl_item.acl_mode),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_default_privileges = state.get_default_privileges().await.unwrap();
    for default_privilege in &default_privileges {
        assert!(persisted_default_privileges.contains(default_privilege));
    }

    let snapshot_default_privileges: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .default_privileges
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| DefaultPrivilege::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for default_privilege in &default_privileges {
        assert!(snapshot_default_privileges.contains(default_privilege));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_system_privileges() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_system_privileges(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_system_privileges() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_system_privileges(openable_state).await;
}

async fn test_system_privileges(openable_state: impl OpenableDurableCatalogState) {
    let system_privileges = [
        MzAclItem {
            grantee: RoleId::User(1),
            grantor: RoleId::User(2),
            acl_mode: AclMode::CREATE_ROLE,
        },
        MzAclItem {
            grantee: RoleId::User(3),
            grantor: RoleId::User(4),
            acl_mode: AclMode::CREATE_CLUSTER,
        },
    ];

    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let mut txn = state.transaction().await.unwrap();
    for system_privilege in &system_privileges {
        txn.set_system_privilege(
            system_privilege.grantee,
            system_privilege.grantor,
            Some(system_privilege.acl_mode),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_system_privileges = state.get_system_privileges().await.unwrap();
    for system_privilege in &system_privileges {
        assert!(persisted_system_privileges.contains(system_privilege));
    }

    let snapshot_system_privileges: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .system_privileges
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| MzAclItem::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for system_privilege in &system_privileges {
        assert!(snapshot_system_privileges.contains(system_privilege));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_system_configurations() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_system_configurations(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_system_configurations() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_system_configurations(openable_state).await;
}

async fn test_system_configurations(openable_state: impl OpenableDurableCatalogState) {
    let system_configurations = [
        SystemConfiguration {
            name: "foo".to_string(),
            value: "bar".to_string(),
        },
        SystemConfiguration {
            name: "vewasdewd".to_string(),
            value: "asiewvw".to_string(),
        },
    ];

    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let mut txn = state.transaction().await.unwrap();
    for system_configuration in &system_configurations {
        txn.upsert_system_config(
            &system_configuration.name,
            system_configuration.value.clone(),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_system_configurations = state.get_system_configurations().await.unwrap();
    for system_configuration in &system_configurations {
        assert!(persisted_system_configurations.contains(system_configuration));
    }

    let snapshot_system_configurations: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .system_configurations
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| SystemConfiguration::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for system_configuration in &system_configurations {
        assert!(snapshot_system_configurations.contains(system_configuration));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_comments() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_comments(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_comments() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_comments(openable_state).await;
}

async fn test_comments(openable_state: impl OpenableDurableCatalogState) {
    let comments = [
        Comment {
            object_id: CommentObjectId::Database(DatabaseId::User(1)),
            sub_component: None,
            comment: "cool".to_string(),
        },
        Comment {
            object_id: CommentObjectId::View(GlobalId::User(1)),
            sub_component: Some(1),
            comment: "nice".to_string(),
        },
    ];

    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let mut txn = state.transaction().await.unwrap();
    for comment in &comments {
        txn.update_comment(
            comment.object_id.clone(),
            comment.sub_component.clone(),
            Some(comment.comment.clone()),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let persisted_comments = state.get_comments().await.unwrap();
    for comment in &comments {
        assert!(persisted_comments.contains(comment));
    }

    let snapshot_comments: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .comments
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| Comment::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for comment in &comments {
        assert!(snapshot_comments.contains(comment));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_audit_logs() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_audit_logs(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_audit_logs() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_audit_logs(openable_state).await;
}

async fn test_audit_logs(openable_state: impl OpenableDurableCatalogState) {
    let audit_logs = [
        VersionedEvent::V1(EventV1 {
            id: 100,
            event_type: EventType::Create,
            object_type: mz_audit_log::ObjectType::ClusterReplica,
            details: EventDetails::CreateClusterReplicaV1(CreateClusterReplicaV1 {
                cluster_id: "1".to_string(),
                cluster_name: "foo".to_string(),
                replica_id: Some("1".to_string()),
                replica_name: "bar".to_string(),
                logical_size: "1".to_string(),
                disk: false,
                billed_as: None,
                internal: false,
            }),
            user: Some("joe".to_string()),
            occurred_at: 100,
        }),
        VersionedEvent::V1(EventV1 {
            id: 200,
            event_type: EventType::Drop,
            object_type: mz_audit_log::ObjectType::View,
            details: EventDetails::IdNameV1(IdNameV1 {
                id: "2".to_string(),
                name: "v".to_string(),
            }),
            user: Some("mike".to_string()),
            occurred_at: 200,
        }),
    ];

    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let mut txn = state.transaction().await.unwrap();
    for audit_log in &audit_logs {
        txn.insert_audit_log_event(audit_log.clone());
    }
    txn.commit().await.unwrap();

    let persisted_audit_logs = state.get_audit_logs().await.unwrap();
    for audit_log in &audit_logs {
        assert!(persisted_audit_logs.contains(audit_log));
    }
    Box::new(state).expire().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_stash_items() {
    let debug_factory = DebugStashFactory::new().await;
    let openable_state = debug_stash_backed_catalog_state(&debug_factory);
    test_items(openable_state).await;
    debug_factory.drop().await;
}

#[mz_ore::test(tokio::test)]
#[cfg_attr(miri, ignore)] //  unsupported operation: can't call foreign function `TLS_client_method` on OS `linux`
async fn test_persist_items() {
    let persist_client = PersistClient::new_for_tests().await;
    let organization_id = Uuid::new_v4();
    let openable_state =
        persist_backed_catalog_state(persist_client.clone(), organization_id).await;
    test_items(openable_state).await;
}

async fn test_items(openable_state: impl OpenableDurableCatalogState) {
    let items = [
        Item {
            id: GlobalId::User(100),
            schema_id: SchemaId::User(1),
            name: "foo".to_string(),
            create_sql: "CREATE VIEW v AS SELECT 1".to_string(),
            owner_id: RoleId::User(1),
            privileges: vec![],
        },
        Item {
            id: GlobalId::User(200),
            schema_id: SchemaId::User(1),
            name: "bar".to_string(),
            create_sql: "CREATE MATERIALIZED VIEW mv AS SELECT 2".to_string(),
            owner_id: RoleId::User(2),
            privileges: vec![],
        },
    ];

    let mut state = Box::new(openable_state)
        .open(SYSTEM_TIME.clone(), &debug_bootstrap_args(), None)
        .await
        .unwrap();
    let mut txn = state.transaction().await.unwrap();
    for item in &items {
        txn.insert_item(
            item.id,
            item.schema_id,
            &item.name,
            item.create_sql.clone(),
            item.owner_id,
            item.privileges.clone(),
        )
        .unwrap();
    }
    txn.commit().await.unwrap();

    let snapshot_items: Vec<_> = state
        .snapshot()
        .await
        .unwrap()
        .items
        .into_iter()
        .map(RustType::from_proto)
        .map_ok(|(k, v)| Item::from_key_value(k, v))
        .collect::<Result<_, _>>()
        .unwrap();
    for item in &items {
        assert!(snapshot_items.contains(item));
    }
    Box::new(state).expire().await;
}
