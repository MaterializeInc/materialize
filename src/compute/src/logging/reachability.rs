// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

//! Logging dataflows for events generated by timely dataflow.

use std::collections::BTreeMap;
use std::convert::TryInto;
use std::rc::Rc;
use std::time::Duration;

use columnar::Index;
use mz_compute_client::logging::LoggingConfig;
use mz_ore::cast::CastFrom;
use mz_repr::{Datum, Diff, Row, Timestamp};
use mz_timely_util::columnar::builder::ColumnBuilder;
use mz_timely_util::columnar::{Col2ValBatcher, Column, columnar_exchange};
use mz_timely_util::replay::MzReplay;
use timely::dataflow::Scope;
use timely::dataflow::channels::pact::{ExchangeCore, Pipeline};
use timely::dataflow::operators::Operator;
use timely::dataflow::operators::generic::operator::empty;

use crate::extensions::arrange::MzArrangeCore;
use crate::logging::initialize::ReachabilityEvent;
use crate::logging::{EventQueue, LogCollection, LogVariant, TimelyLog, consolidate_and_pack};
use crate::row_spine::RowRowBuilder;
use crate::typedefs::RowRowSpine;

/// The return type of [`construct`].
pub(super) struct Return {
    /// Collections to export.
    pub collections: BTreeMap<LogVariant, LogCollection>,
}

/// Constructs the logging dataflow fragment for reachability logs.
///
/// Params
/// * `scope`: The Timely scope hosting the log analysis dataflow.
/// * `config`: Logging configuration
/// * `event_queue`: The source to read log events from.
pub(super) fn construct<G: Scope<Timestamp = Timestamp>>(
    mut scope: G,
    config: &LoggingConfig,
    event_queue: EventQueue<Column<(Duration, ReachabilityEvent)>, 3>,
) -> Return {
    let collections = scope.scoped("timely reachability logging", move |scope| {
        let enable_logging = config.enable_logging;
        let interval_ms = std::cmp::max(1, config.interval.as_millis());
        type UpdatesKey = (bool, usize, usize, usize, Timestamp);

        type CB = ColumnBuilder<((UpdatesKey, ()), Timestamp, Diff)>;
        let (logs, token) = if enable_logging {
            event_queue.links.mz_replay(
                scope,
                "reachability logs",
                config.interval,
                event_queue.activator,
            )
        } else {
            let token: Rc<dyn std::any::Any> = Rc::new(Box::new(()));
            (empty(scope), token)
        };
        let logs = logs.unary::<CB, _, _, _>(Pipeline, "FlatMapReachability", move |_,_| move |input, output| {
            input.for_each_time(|time, data| {
                output.session_with_builder(&time)
                    .give_iterator(data.flat_map(|d|
                        d.borrow().into_index_iter().flat_map(move |(time, (operator_id, massaged))| {
                            let time_ms = ((time.as_millis() / interval_ms) + 1) * interval_ms;
                            let time_ms: Timestamp = time_ms.try_into().expect("must fit");
                            massaged.into_iter().map(move |(source, port, update_type, ts, diff)| {
                                let datum = (update_type, operator_id, source, port, ts);
                                ((datum, ()), time_ms, diff)
                            })
                        }
                    )));
            });
        });

        // Restrict results by those logs that are meant to be active.
        let logs_active = [LogVariant::Timely(TimelyLog::Reachability)];
        let worker_id = scope.index();

        let updates = consolidate_and_pack::<_, Col2ValBatcher<UpdatesKey, _, _, _>, ColumnBuilder<_>, _, _>(
            &logs,
            TimelyLog::Reachability,
            move |data, packer, session| {
                for ((datum, ()), time, diff) in data.iter() {
                    let (update_type, operator_id, source, port, ts) = datum;
                    let update_type = if *update_type { "source" } else { "target" };
                    let data = packer.pack_slice(&[
                        Datum::UInt64(u64::cast_from(*operator_id)),
                        Datum::UInt64(u64::cast_from(worker_id)),
                        Datum::UInt64(u64::cast_from(*source)),
                        Datum::UInt64(u64::cast_from(*port)),
                        Datum::String(update_type),
                        Datum::from(*ts),
                    ]);
                    session.give((data, time, diff));
                }
            }
        );

        let mut result = BTreeMap::new();
        for variant in logs_active {
            if config.index_logs.contains_key(&variant) {
                let trace = updates
                    .mz_arrange_core::<_, Col2ValBatcher<_, _, _, _>, RowRowBuilder<_, _>, RowRowSpine<_, _>>(
                        ExchangeCore::<ColumnBuilder<_>, _>::new_core(columnar_exchange::<Row, Row, Timestamp, Diff>),
                        &format!("Arrange {variant:?}"),
                    )
                    .trace;
                let collection = LogCollection {
                    trace,
                    token: Rc::clone(&token),
                };
                result.insert(variant, collection);
            }
        }
        result
    });

    Return { collections }
}
