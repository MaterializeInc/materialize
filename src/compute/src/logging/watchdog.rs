// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

//! Logging dataflows for watchdog events generated by clusterd.

use crate::extensions::arrange::MzArrange;
use crate::logging::Update;
use crate::typedefs::spines::{ColKeyBuilder, ColValBatcher, ColValBuilder};
use crate::typedefs::{KeyBatcher, KeySpine, KeyValSpine};
use differential_dataflow::operators::CountTotal;
use differential_dataflow::AsCollection;
use std::cell::RefCell;
use std::collections::BTreeSet;
use std::rc::Rc;
use timely::dataflow::operators::Concat;
use timely::dataflow::{Scope, Stream};

pub(super) struct Streams<S: Scope> {
    /// operator id, diff in bytes
    pub(super) arrangement_heap_size: Stream<S, Update<(usize, ())>>,
    /// operator id, diff in bytes
    pub(super) batcher_heap_size: Stream<S, Update<(usize, ())>>,
    /// Operator id to dataflow id
    pub(super) operator_to_dataflow: Stream<S, Update<(usize, usize)>>,
    /// Dataflow -> limit in bytes
    pub(super) heap_size_limits: Stream<S, Update<(usize, u64)>>,
    pub(super) dataflows_exceeding_heap_size_limit: Rc<RefCell<BTreeSet<usize>>>,
}

pub(super) fn construct<S: Scope<Timestamp = mz_repr::Timestamp>>(
    _scope: S,
    streams: Streams<S>,
) -> () {
    let Streams {
        arrangement_heap_size,
        batcher_heap_size,
        operator_to_dataflow,
        heap_size_limits,
        dataflows_exceeding_heap_size_limit,
    } = streams;

    // The following dataflow computes:
    // ```
    // arrangement_heap_size    batcher_heap_size  operator_to_dataflow   heap_size_limits
    //           |                    |                    |                    |
    //           |----->concat<------ |                 arrange              arrange
    //                    |                                |                    |
    //               arrange: op_to_heap_size              |                    |
    //                    |                                |                    |
    //                    |-->join: dataflow_to_heap_size<-|                    |
    //                                    |                                     |
    //                                arrange                                   |
    //                                    |                                     |
    //                               count_total_core                           |
    //                                    |                                     |
    //                                arrange                                   |
    //                                    |                                     |
    //                                    |------------>join<-------------------|
    //                                                    |
    //                                                result
    // ```

    let operator_to_heap_size = arrangement_heap_size.concat(&batcher_heap_size);
    let operator_to_heap_size = operator_to_heap_size
        .as_collection()
        .mz_arrange::<KeyBatcher<_, _, _>, ColKeyBuilder<_, _, _>, KeySpine<_, _, _>>(
            "operator_to_heap_size",
        );

    let operator_to_dataflow = operator_to_dataflow
        .as_collection()
        .mz_arrange::<ColValBatcher<_, _, _, _>, ColValBuilder<_, _, _, _>, KeyValSpine<_, _, _, _>>(
            "operator_to_dataflow",
        );

    let dataflow_to_heap_size = operator_to_heap_size
        .join_core(&operator_to_dataflow, |_op, (), dataflow| {
            Some((*dataflow, ()))
        });

    let heap_size_limits = heap_size_limits
        .as_collection()
        .mz_arrange::<ColValBatcher<_, _, _, _>, ColValBuilder<_, _, _, _>, KeyValSpine<_, _, _, _>>("heap_size_limits");

    let dataflow_to_heap_size_limit =  dataflow_to_heap_size
        .mz_arrange::<KeyBatcher<_, _, _>, ColKeyBuilder<_, _, _>, KeySpine<_, _, _>>(
            "dataflow_to_heap_size",
        )
        .count_total_core::<mz_repr::Diff>()
        .mz_arrange::<ColValBatcher<_, _, _, _>, ColValBuilder<_, _, _, _>, KeyValSpine<_, _, _, _>>(
            "dataflow_to_heap_size_count",
        )
        .join_core(&heap_size_limits, |dataflow, size, limit| {
            if *size >= (*limit).try_into().expect("must fit") {
                Some(*dataflow)
            } else {
                None
            }
        });

    dataflow_to_heap_size_limit.inspect(move |(dataflow_id, _, _)| {
        dataflows_exceeding_heap_size_limit
            .borrow_mut()
            .insert(*dataflow_id);
    });
}
