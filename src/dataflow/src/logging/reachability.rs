// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

//! Logging dataflows for events generated by timely dataflow.

use std::convert::TryFrom;
use std::time::Duration;

use differential_dataflow::operators::arrange::arrangement::ArrangeByKey;
use timely::communication::Allocate;
use timely::dataflow::operators::capture::EventLink;
use timely::logging::WorkerIdentifier;

use super::{LogVariant, TimelyLog};
use crate::arrangement::KeysValsHandle;
use crate::render::datum_vec::DatumVec;
use dataflow_types::logging::LoggingConfig;
use repr::{Datum, Row, Timestamp};

/// Constructs the logging dataflows and returns a logger and trace handles.
pub fn construct<A: Allocate>(
    worker: &mut timely::worker::Worker<A>,
    config: &LoggingConfig,
    linked: std::rc::Rc<
        EventLink<
            Timestamp,
            (
                Duration,
                WorkerIdentifier,
                (Vec<usize>, usize, usize, bool, Option<Timestamp>, isize),
            ),
        >,
    >,
) -> std::collections::HashMap<LogVariant, (Vec<usize>, KeysValsHandle)> {
    let granularity_ms = std::cmp::max(1, config.granularity_ns / 1_000_000) as Timestamp;

    // A dataflow for multiple log-derived arrangements.
    let traces = worker.dataflow_named("Dataflow: timely reachability logging", move |scope| {
        use differential_dataflow::collection::AsCollection;
        use timely::dataflow::operators::capture::Replay;

        let logs = Some(linked).replay_core(
            scope,
            Some(Duration::from_nanos(config.granularity_ns as u64)),
        );

        use timely::dataflow::operators::generic::builder_rc::OperatorBuilder;

        let mut flatten = OperatorBuilder::new(
            "Timely Reachability Logging Flatten ".to_string(),
            scope.clone(),
        );

        use timely::dataflow::channels::pact::Pipeline;
        let mut input = flatten.new_input(&logs, Pipeline);

        let (mut updates_out, updates) = flatten.new_output();

        let mut buffer = Vec::new();
        flatten.build(move |_capability| {
            let mut row_packer = Row::default();
            move |_frontiers| {
                let mut updates = updates_out.activate();

                input.for_each(|time, data| {
                    data.swap(&mut buffer);

                    let mut updates_session = updates.session(&time);

                    for (time, worker, (mut addr, source, port, update_type, ts, diff)) in
                        buffer.drain(..)
                    {
                        let time_ms = (((time.as_millis() as Timestamp / granularity_ms) + 1)
                            * granularity_ms) as Timestamp;
                        let update_type = if update_type { "source" } else { "target" };

                        addr.push(source);
                        row_packer.push_list(addr.into_iter().map(|id| Datum::Int64(id as i64)));
                        row_packer.push(Datum::Int64(port as i64));
                        row_packer.push(Datum::Int64(worker as i64));
                        row_packer.push(Datum::String(&update_type));
                        row_packer.push(Datum::from(ts.and_then(|ts| i64::try_from(ts).ok())));
                        updates_session.give((row_packer.finish_and_reuse(), time_ms, diff));
                    }
                });
            }
        });

        let updates = updates.as_collection();

        // Restrict results by those logs that are meant to be active.
        let logs = vec![(LogVariant::Timely(TimelyLog::Reachability), updates)];

        let mut result = std::collections::HashMap::new();
        for (variant, collection) in logs {
            if config.active_logs.contains_key(&variant) {
                let key = variant.index_by();
                let key_clone = key.clone();
                let trace = collection
                    .map({
                        let mut row_packer = Row::default();
                        let mut datums = DatumVec::new();
                        move |row| {
                            let datums = datums.borrow_with(&row);
                            row_packer.extend(key.iter().map(|k| datums[*k]));
                            ::std::mem::drop(datums);
                            (row_packer.finish_and_reuse(), row)
                        }
                    })
                    .arrange_by_key_named(&format!("ArrangeByKey {:?}", variant))
                    .trace;
                result.insert(variant, (key_clone, trace));
            }
        }
        result
    });

    traces
}
