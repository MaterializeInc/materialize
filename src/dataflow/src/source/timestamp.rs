// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

//! Types and methods for managing timestamp assignment and invention in sources

//! External users will interact primarily with instances of a `TimestampBindingRc` object
//! which lets various source instances reading on the same worker coordinate about the
//! underlying `TimestampBindingBox` and give readers that are lagging behind the ability
//! to delay compaction.

//! Besides that, the only other bit of complexity in this code is the `TimestampProposer` object
//! which manages the collaborative invention of timestamps by several source instances all reading
//! from the same worker. The key idea is that since all source readers are assigned to the same
//! worker, only one of them will be reading at a given time, and that reader can either consult
//! the timestamp bindings generated by its peers if it is not the furthest ahead, or if it is
//! the furthest ahead, it can propose a new assingment of `(partition, offset) -> timestamp` that
//! its peers will respect.

use std::cell::RefCell;
use std::collections::HashSet;
use std::rc::Rc;

use log::debug;
use timely::order::PartialOrder;
use timely::progress::frontier::{Antichain, AntichainRef, MutableAntichain};
use timely::progress::Timestamp as TimelyTimestamp;

use dataflow_types::PartitionOffset;
use expr::PartitionId;
use repr::Timestamp;

/// This struct holds per-source timestamp state in a way that can be shared across
/// different source instances and allow different source instances to indicate
/// how far they have read up to.
///
/// This type is almost never meant to be used directly, and you probably want to
/// use `TimestampBindingRc` instead.
#[derive(Debug)]
pub struct TimestampBindingBox {
    /// TODO(aljoscha): factor this out of the bindings
    partitions: HashSet<PartitionId>,

    /// The actual bindings, as combinations of a source frontier and the `ToTime` that records not
    /// beyond this frontier should be assigned to.
    bindings: Vec<(Antichain<PartitionOffset>, Timestamp)>,

    /// Indicates the lowest timestamp across all partitions that we retain bindings for.
    /// This frontier can be held back by other entities holding the shared
    /// `TimestampBindingRc`.
    compaction_frontier: MutableAntichain<Timestamp>,
}

impl TimestampBindingBox {
    fn new() -> Self {
        Self {
            partitions: HashSet::new(),
            bindings: Vec::new(),
            compaction_frontier: MutableAntichain::new_bottom(TimelyTimestamp::minimum()),
        }
    }

    fn adjust_compaction_frontier(
        &mut self,
        remove: AntichainRef<Timestamp>,
        add: AntichainRef<Timestamp>,
    ) {
        self.compaction_frontier
            .update_iter(remove.iter().map(|t| (*t, -1)));
        self.compaction_frontier
            .update_iter(add.iter().map(|t| (*t, 1)));
    }

    fn compact(&mut self) {
        let frontier = self.compaction_frontier.frontier();

        // Don't compact up to the empty frontier as it would mean there were no
        // timestamp bindings available
        // TODO(rkhaitan): is there a more sensible approach here?
        if frontier.is_empty() {
            return;
        }

        // TODO(aljoscha): for now, we don't compact but timestamp bindings
        // fall out naturally when not needed anymore in `maybe_advance`

        // self.bindings
        //     .retain(|(_frontier, timestamp)| !frontier.less_than(timestamp));
    }

    fn add_partition(&mut self, partition: PartitionId) {
        if self.partitions.insert(partition) {
            debug!("already inserted partition {:?}, ignoring", partition);
        }
    }

    fn add_binding(&mut self, binding: (Antichain<PartitionOffset>, Timestamp)) {
        self.bindings.push(binding);
    }

    fn get_binding(&self, source_timestamp: &PartitionOffset) -> Option<Timestamp> {
        // We could try and be smart here. Maybe do a binary search to find
        // a binding that works. For now, iterate from the beginning, based
        // on the assumption that we first work of earlier bindings before
        // data comes in that would need a later binding.
        for (frontier, timestamp) in self.bindings.iter() {
            if source_timestamp.is_covered(frontier.borrow()) {
                return Some(timestamp.clone());
            }
        }

        None
    }

    fn read_upper(&self, target: &mut Antichain<Timestamp>) {
        target.clear();

        let frontier = self.frontier();

        if let Some(timestamp) = frontier {
            target.insert(timestamp);
        } else {
            use timely::progress::Timestamp;
            target.insert(Timestamp::minimum());
        }
    }

    fn maybe_advance(&mut self, read_frontier: AntichainRef<PartitionOffset>) {
        let last_binding = self.bindings.last().cloned();

        self.bindings.retain(|(binding_frontier, _timestamp)| {
            !PartialOrder::less_equal(&binding_frontier.borrow(), &read_frontier)
        });

        if self.bindings.is_empty() && last_binding.is_some() {
            let last_binding = last_binding.expect("must exist");
            self.bindings.push(last_binding);
        }
    }

    fn frontier(&self) -> Option<Timestamp> {
        self.bindings
            .first()
            .map(|(_frontier, timestamp)| timestamp.clone())
    }

    fn partitions(&self) -> Vec<PartitionId> {
        self.partitions.iter().cloned().collect()
    }
}

/// A wrapper that allows multiple source instances to share a `TimestampBindingBox`
/// and hold back its compaction.
#[derive(Debug)]
pub struct TimestampBindingRc {
    wrapper: Rc<RefCell<TimestampBindingBox>>,
    compaction_frontier: Antichain<Timestamp>,
}

impl TimestampBindingRc {
    /// Create a new instance of `TimestampBindingRc`.
    pub fn new() -> Self {
        let wrapper = Rc::new(RefCell::new(TimestampBindingBox::new()));

        let ret = Self {
            wrapper: wrapper.clone(),
            compaction_frontier: wrapper.borrow().compaction_frontier.frontier().to_owned(),
        };

        ret
    }

    /// Set the compaction frontier to `new_frontier` and compact all timestamp bindings at
    /// timestamps less than the compaction frontier.
    ///
    /// Note that `new_frontier` must be in advance of the current compaction
    /// frontier. The source can be correctly replayed from any `as_of` in advance of
    /// the compaction frontier after this operation.
    pub fn set_compaction_frontier(&mut self, new_frontier: AntichainRef<Timestamp>) {
        assert!(
            self.compaction_frontier.borrow().is_empty()
                || <_ as PartialOrder>::less_equal(
                    &self.compaction_frontier.borrow(),
                    &new_frontier
                )
        );
        self.wrapper
            .borrow_mut()
            .adjust_compaction_frontier(self.compaction_frontier.borrow(), new_frontier);
        self.compaction_frontier = new_frontier.to_owned();
        self.wrapper.borrow_mut().compact();
    }

    /// Add a new mapping from `(partition, offset) -> timestamp`.
    ///
    /// Note that the `timestamp` has to be greater than the largest previously bound
    /// timestamp for that partition, and `offset` has to be greater than or equal to
    /// the largest previously bound offset for that partition. If `proposed` is true,
    /// the binding is treated as tentative and may be overwritten by other, overlapping
    /// bindings
    pub fn add_binding(&self, binding: (Antichain<PartitionOffset>, Timestamp)) {
        self.wrapper.borrow_mut().add_binding(binding);
    }

    /// Tell timestamping machinery to look out for `partition`
    pub fn add_partition(&self, partition: PartitionId) {
        self.wrapper.borrow_mut().add_partition(partition);
    }

    /// Get the timestamp assignment for `(partition, offset)` if it is known.
    ///
    /// This function returns the timestamp and the maximum offset for which it is
    /// valid.
    pub fn get_binding(&self, source_timestamp: &PartitionOffset) -> Option<Timestamp> {
        self.wrapper.borrow().get_binding(source_timestamp)
    }

    /// Returns the frontier of timestamps that have not been bound to any
    /// incoming data, or in other words, all data has been assigned timestamps
    /// less than some element in the returned frontier.
    ///
    /// All subsequent updates will either be at or in advance of this frontier.
    pub fn read_upper(&self, target: &mut Antichain<Timestamp>) {
        self.wrapper.borrow().read_upper(target)
    }

    /// Purges bindings that are dominated by the given read frontier, i.e. when
    /// the read frontier is beyond them.
    pub fn maybe_advance(&mut self, read_frontier: AntichainRef<PartitionOffset>) {
        self.wrapper.borrow_mut().maybe_advance(read_frontier);
    }

    /// Returns the lowest `Timestamp` that is still "open".
    pub fn frontier(&self) -> Option<Timestamp> {
        self.wrapper.borrow().frontier()
    }

    /// Returns the list of partitions this source knows about.
    ///
    /// TODO(rkhaitan): this function feels like a hack, both in the API of having
    /// the source instances ask for the list of known partitions and in allocating
    /// a vector to answer that question.
    pub fn partitions(&self) -> Vec<PartitionId> {
        self.wrapper.borrow().partitions()
    }
}

impl Clone for TimestampBindingRc {
    fn clone(&self) -> Self {
        // Bump the reference count for the current shared frontier
        let frontier = self
            .wrapper
            .borrow()
            .compaction_frontier
            .frontier()
            .to_owned();
        self.wrapper
            .borrow_mut()
            .adjust_compaction_frontier(Antichain::new().borrow(), frontier.borrow());
        self.wrapper.borrow_mut().compact();

        Self {
            wrapper: self.wrapper.clone(),
            compaction_frontier: frontier,
        }
    }
}

impl Drop for TimestampBindingRc {
    fn drop(&mut self) {
        // Decrement the reference count for the current frontier
        self.wrapper.borrow_mut().adjust_compaction_frontier(
            self.compaction_frontier.borrow(),
            Antichain::new().borrow(),
        );
        self.wrapper.borrow_mut().compact();

        self.compaction_frontier = Antichain::new();
    }
}
