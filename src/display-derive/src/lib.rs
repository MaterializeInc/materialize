// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(clippy::style)]
#![allow(clippy::complexity)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::mutable_key_type)]
#![allow(clippy::stable_sort_primitive)]
#![allow(clippy::map_entry)]
#![allow(clippy::box_default)]
#![warn(clippy::bool_comparison)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::no_effect)]
#![warn(clippy::unnecessary_unwrap)]
#![warn(clippy::dbg_macro)]
#![warn(clippy::todo)]
#![warn(clippy::wildcard_dependencies)]
#![warn(clippy::zero_prefixed_literal)]
#![warn(clippy::borrowed_box)]
#![warn(clippy::deref_addrof)]
#![warn(clippy::double_must_use)]
#![warn(clippy::double_parens)]
#![warn(clippy::extra_unused_lifetimes)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_question_mark)]
#![warn(clippy::needless_return)]
#![warn(clippy::redundant_pattern)]
#![warn(clippy::redundant_slicing)]
#![warn(clippy::redundant_static_lifetimes)]
#![warn(clippy::single_component_path_imports)]
#![warn(clippy::unnecessary_cast)]
#![warn(clippy::useless_asref)]
#![warn(clippy::useless_conversion)]
#![warn(clippy::builtin_type_shadow)]
#![warn(clippy::duplicate_underscore_argument)]
#![warn(clippy::double_neg)]
#![warn(clippy::unnecessary_mut_passed)]
#![warn(clippy::wildcard_in_or_patterns)]
#![warn(clippy::collapsible_if)]
#![warn(clippy::collapsible_else_if)]
#![warn(clippy::crosspointer_transmute)]
#![warn(clippy::excessive_precision)]
#![warn(clippy::overflow_check_conditional)]
#![warn(clippy::as_conversions)]
#![warn(clippy::match_overlapping_arm)]
#![warn(clippy::zero_divided_by_zero)]
#![warn(clippy::must_use_unit)]
#![warn(clippy::suspicious_assignment_formatting)]
#![warn(clippy::suspicious_else_formatting)]
#![warn(clippy::suspicious_unary_op_formatting)]
#![warn(clippy::mut_mutex_lock)]
#![warn(clippy::print_literal)]
#![warn(clippy::same_item_push)]
#![warn(clippy::useless_format)]
#![warn(clippy::write_literal)]
#![warn(clippy::redundant_closure)]
#![warn(clippy::redundant_closure_call)]
#![warn(clippy::unnecessary_lazy_evaluations)]
#![warn(clippy::partialeq_ne_impl)]
#![warn(clippy::redundant_field_names)]
#![warn(clippy::transmutes_expressible_as_ptr_casts)]
#![warn(clippy::unused_async)]
#![warn(clippy::disallowed_methods)]
#![warn(clippy::disallowed_macros)]
#![warn(clippy::from_over_into)]
// END LINT CONFIG

use std::collections::HashMap;

use proc_macro::TokenStream;
use quote::quote;
use syn::{Attribute, Field, Fields, FieldsNamed, FieldsUnnamed, Ident, Item, Type};

type TokenStream2 = proc_macro2::TokenStream;

const DISPLAY_WIDTH: usize = usize::MAX;
const NEST: isize = 4;

#[proc_macro_derive(ToDoc, attributes(todoc))]
pub fn derive_to_doc(item: TokenStream) -> TokenStream {
    let input = syn::parse_macro_input!(item as Item);
    match input {
        Item::Enum(item) => {
            let _enum_attrs = Attrs::new(&item.attrs);
            let variants = item.variants.iter().map(|variant| {
                let ident = &variant.ident;
                let mut variant_attrs = Attrs::new(&variant.attrs);
                let name = variant_attrs
                    .remove("rename")
                    .unwrap_or_else(|| fmt_ident(&variant.ident));
                let FromFields { fields, doc } =
                    from_fields(&variant.fields, &name, variant_attrs.separator(""));
                let doc = if variant_attrs.remove("ignore").is_some() {
                    quote! { None }
                } else {
                    let doc = variant_attrs.prefix(doc);
                    let doc = variant_attrs.suffix(doc);
                    variant_attrs.nest(doc)
                };
                quote! { Self::#ident #fields => #doc.unwrap_or_else(pretty::RcDoc::nil), }
            });
            let item_ident = item.ident;
            let (impl_generics, ty_generics, where_clause) = item.generics.split_for_impl();
            quote! {
                impl #impl_generics ToDoc for #item_ident #ty_generics #where_clause {
                    fn to_doc(&self, __mode: crate::ast::display::FormatMode) -> pretty::RcDoc<()> {
                        match self {
                            #(#variants)*
                        }
                    }
                }
                impl #impl_generics AstDisplay for #item_ident #ty_generics #where_clause {
                    fn fmt<W: std::fmt::Write>(&self, f: &mut AstFormatter<W>) {
                        self.to_doc(f.mode).render_fmt(#DISPLAY_WIDTH, &mut f.buf).expect("unexpected failure in render_fmt")
                    }
                }
                impl #impl_generics std::fmt::Display for #item_ident #ty_generics #where_clause {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        self.to_doc(crate::ast::display::FormatMode::Simple).render_fmt(#DISPLAY_WIDTH, f)
                    }
                }
            }
            .into()
        }
        Item::Struct(item) => {
            let mut struct_attrs = Attrs::new(&item.attrs);
            let name = fmt_ident(&item.ident);
            let FromFields { fields, doc } =
                from_fields(&item.fields, &name, struct_attrs.separator(""));
            let item_ident = item.ident;
            let (impl_generics, ty_generics, where_clause) = item.generics.split_for_impl();
            let doc = struct_attrs.name(doc, &name);
            let doc = struct_attrs.suffix(doc);
            quote! {
                impl #impl_generics ToDoc for #item_ident #ty_generics #where_clause {
                    fn to_doc(&self, __mode: crate::ast::display::FormatMode) -> pretty::RcDoc<()> {
                        let Self #fields = self;
                        #doc.unwrap_or_else(pretty::RcDoc::nil).group()
                    }
                }
                impl #impl_generics AstDisplay for #item_ident #ty_generics #where_clause {
                    fn fmt<W: std::fmt::Write>(&self, f: &mut AstFormatter<W>) {
                        self.to_doc(f.mode).render_fmt(#DISPLAY_WIDTH, &mut f.buf).expect("unexpected failure in render_fmt")
                    }
                }
                impl #impl_generics std::fmt::Display for #item_ident #ty_generics #where_clause {
                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                        self.to_doc(crate::ast::display::FormatMode::Simple).render_fmt(#DISPLAY_WIDTH, f)
                    }
                }
            }
            .into()
        }
        _ => panic!("unsupported: {:?}", input),
    }
}
fn from_fields(fields: &Fields, name: &str, separator: TokenStream2) -> FromFields {
    match fields {
        Fields::Named(fields) => named_fields(fields, separator),
        Fields::Unnamed(fields) => unnamed_fields(fields, name),
        Fields::Unit => FromFields {
            fields: quote! {},
            doc: quote! { Some(pretty::RcDoc::text(#name)) },
        },
    }
}

fn unnamed_fields(fields: &FieldsUnnamed, name: &str) -> FromFields {
    let idents = (0..fields.unnamed.len())
        .map(|i| {
            // TODO: Better way to do this?
            Ident::new(&format!("_{i}"), syn::__private::Span::call_site())
        })
        .collect::<Vec<_>>();
    let doc = match fields.unnamed.len() {
        0 => quote! { Some(pretty::RcDoc::text(#name)) },
        1 => {
            let field = from_field(fields.unnamed.first().unwrap(), &idents[0], name);
            field.doc
        }
        _ => panic!(
            "unsupported: unnamed fields with len {}",
            fields.unnamed.len()
        ),
    };
    let idents = quote! { (#(#idents),*) };
    FromFields {
        fields: idents,
        doc,
    }
}

fn named_fields(fields: &FieldsNamed, separator: TokenStream2) -> FromFields {
    let mut ignored = false;
    let (docs, mut idents): (Vec<_>, Vec<_>) = fields
        .named
        .iter()
        .filter_map(|field| {
            let ident = field.ident.as_ref().unwrap();
            let FromField { doc, mut attrs } = from_field(field, ident, &fmt_ident(ident));
            if attrs.remove("ignore").is_some() {
                ignored = true;
                None
            } else {
                Some((doc, quote! { #ident }))
            }
        })
        .unzip();
    let doc = quote! { {
        let docs = [#(#docs),*].into_iter().filter_map(|v| v).collect::<Vec<_>>();
        if docs.is_empty() {
            None
        } else {
            Some(pretty::RcDoc::intersperse(docs, #separator).group())
        }
    } };
    if ignored {
        idents.push(quote! { .. });
    }
    let idents = quote! { {#(#idents),*} };
    FromFields {
        fields: idents,
        doc,
    }
}

struct FromField {
    doc: TokenStream2,
    attrs: Attrs,
}

// ident is something like self.blah, name is blah.
fn from_field(field: &Field, ident: &Ident, name: &str) -> FromField {
    let mut attrs = Attrs::new(&field.attrs);
    if let Some(doc_fn) = attrs.remove("doc_fn") {
        let doc_fn = Ident::new(&doc_fn, syn::__private::Span::call_site());
        let doc = quote! { #doc_fn(&self) };
        return FromField { attrs, doc };
    }
    let name = attrs.rename(name);
    let doc = if is_bool(field) {
        let doc = quote! { #ident.then(|| pretty::RcDoc::text(#name)) };
        attrs.els(doc)
    } else if is_vec(field) {
        let sep = attrs.separator(",");
        let doc = quote! { if #ident.is_empty() {
                None
            } else {
                Some(
                    pretty::RcDoc::intersperse(
                        #ident.iter().map(|v| v.to_doc(__mode)),
                        #sep
                    )
                    .group()
                )
            }
        };
        let doc = attrs.name(doc, &name);
        attrs.show_empty(doc)
    } else if is_option(field) {
        let doc = quote! { #ident.as_ref().map(|opt| opt.to_doc(__mode)) };
        let doc = attrs.name(doc, &name);
        attrs.els(doc)
    } else {
        quote! { Some(#ident.to_doc(__mode)) }
    };
    let doc = attrs.prefix(doc);
    let doc = attrs.suffix(doc);
    let doc = attrs.nest(doc);
    FromField { doc, attrs }
}

struct FromFields {
    fields: TokenStream2,
    doc: TokenStream2,
}

fn is_bool(field: &Field) -> bool {
    matches!(
        &field.ty,
        Type::Path(type_path) if type_path.path.is_ident("bool"),
    )
}

fn is_vec(field: &Field) -> bool {
    if let Type::Path(type_path) = &field.ty {
        let segments = &type_path.path.segments;
        return segments[0].ident == "Vec";
    }
    false
}

fn is_option(field: &Field) -> bool {
    if let Type::Path(type_path) = &field.ty {
        let segments = &type_path.path.segments;
        return segments[0].ident == "Option";
    }
    false
}

fn truncate_stmt_suffix(s: &str) -> &str {
    s.trim_end_matches("sStatement")
        .trim_end_matches("Statement")
}

fn split_upper(mut s: &str) -> Vec<&str> {
    let mut indexes = Vec::new();
    for (i, c) in s.chars().enumerate().skip(1) {
        if c.is_uppercase() {
            indexes.push(i);
        }
    }
    let mut strs = Vec::with_capacity(indexes.len());
    let mut accum = 0;
    for split_at in indexes {
        let at = split_at - accum;
        let (l, r) = s.split_at(at);
        accum += at;
        s = r;
        strs.push(l);
    }
    strs.push(s);
    strs
}

fn fmt_ident(ident: &Ident) -> String {
    split_upper(truncate_stmt_suffix(&ident.to_string()))
        .join(" ")
        .replace('_', " ")
        .to_uppercase()
}

// A struct to parse and track attributes. Unused attributes cause errors on
// Drop, providing the property that users will get compile errors if they
// specify unknown attributes.
struct Attrs(HashMap<String, String>);

impl Attrs {
    fn new(attrs: &[Attribute]) -> Self {
        let mut map = HashMap::new();
        for attr in attrs {
            if !attr.path.is_ident("astdisplay") {
                continue;
            }
            for tok in attr.tokens.clone().into_iter() {
                // TODO: Surely there's a better way to do this.
                if let quote::__private::TokenTree::Group(group) = tok {
                    let mut toks = group
                        .stream()
                        .into_iter()
                        .map(|tok| tok.to_string())
                        .peekable();
                    while toks.peek().is_some() {
                        let name = toks.next().unwrap();
                        let mut value = "".to_string();
                        if let Some("=") = toks.peek().cloned().as_deref() {
                            toks.next();
                            value = toks.next().unwrap();
                            // Trim off the quotes. Gotta be a better way?
                            value = value[1..value.len() - 1].to_string();
                        }
                        map.insert(name, value);
                        match toks.next().as_deref() {
                            Some(",") => continue,
                            None => break,
                            _ => panic!("unexpected attribute token"),
                        }
                    }
                }
            }
        }
        Self(map)
    }

    fn remove(&mut self, key: &str) -> Option<String> {
        self.0.remove(key)
    }

    fn rename(&mut self, name: &str) -> String {
        self.remove("rename").unwrap_or_else(|| name.to_string())
    }

    fn name(&mut self, mut doc: TokenStream2, name: &str) -> TokenStream2 {
        let name = self.rename(name);
        if self.remove("no_name").is_none() {
            doc = quote! { #doc.map(|doc|
                pretty::RcDoc::text(#name)
                .append(pretty::RcDoc::line())
                .append(doc)
                .nest(#NEST)
            ) };
        }
        doc
    }

    fn prefix(&mut self, mut doc: TokenStream2) -> TokenStream2 {
        if let Some(prefix) = self.remove("prefix") {
            doc = quote! { #doc.map(|doc| pretty::RcDoc::text(#prefix).append(doc)) };
        }
        doc
    }

    fn suffix(&mut self, mut doc: TokenStream2) -> TokenStream2 {
        if let Some(suffix) = self.remove("suffix") {
            doc = quote! { #doc.map(|doc| doc.append(pretty::RcDoc::text(#suffix))) };
        }
        doc
    }

    fn nest(&mut self, mut doc: TokenStream2) -> TokenStream2 {
        if let Some(nest) = self.remove("nest") {
            doc = quote! { #doc.map(|doc|
                pretty::RcDoc::text(#nest)
                .append(pretty::RcDoc::line())
                .append(doc)
                .nest(#NEST)
                .group()
            ) };
            if let Some(suffix) = self.remove("nest_suffix") {
                doc = quote! { #doc.map(|doc| doc
                    .append(pretty::RcDoc::line())
                    .append(pretty::RcDoc::text(#suffix))
                    .group()
                ) };
            }
        }
        doc
    }

    fn els(&mut self, mut doc: TokenStream2) -> TokenStream2 {
        if let Some(els) = self.remove("else") {
            doc = quote! { Some(#doc.unwrap_or_else(|| pretty::RcDoc::text(#els))) };
        }
        doc
    }

    fn show_empty(&mut self, mut doc: TokenStream2) -> TokenStream2 {
        if self.remove("show_empty").is_some() {
            doc = quote! { Some(#doc.unwrap_or_else(pretty::RcDoc::nil)) };
        }
        doc
    }

    fn separator(&mut self, default: &str) -> TokenStream2 {
        let sep = self
            .remove("separator")
            .unwrap_or_else(|| default.to_string());
        let mut doc = quote! { pretty::RcDoc::text(#sep) };
        if self.remove("separator_noline").is_none() {
            doc = quote! { #doc.append(pretty::RcDoc::line()) };
        }
        doc
    }
}

impl Drop for Attrs {
    fn drop(&mut self) {
        if !self.0.is_empty() {
            panic!("unknown attributes: {:?}", self.0.keys());
        }
    }
}
