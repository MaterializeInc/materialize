// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(clippy::style)]
#![allow(clippy::complexity)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::mutable_key_type)]
#![allow(clippy::stable_sort_primitive)]
#![allow(clippy::map_entry)]
#![allow(clippy::box_default)]
#![warn(clippy::bool_comparison)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::no_effect)]
#![warn(clippy::unnecessary_unwrap)]
#![warn(clippy::dbg_macro)]
#![warn(clippy::todo)]
#![warn(clippy::wildcard_dependencies)]
#![warn(clippy::zero_prefixed_literal)]
#![warn(clippy::borrowed_box)]
#![warn(clippy::deref_addrof)]
#![warn(clippy::double_must_use)]
#![warn(clippy::double_parens)]
#![warn(clippy::extra_unused_lifetimes)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_question_mark)]
#![warn(clippy::needless_return)]
#![warn(clippy::redundant_pattern)]
#![warn(clippy::redundant_slicing)]
#![warn(clippy::redundant_static_lifetimes)]
#![warn(clippy::single_component_path_imports)]
#![warn(clippy::unnecessary_cast)]
#![warn(clippy::useless_asref)]
#![warn(clippy::useless_conversion)]
#![warn(clippy::builtin_type_shadow)]
#![warn(clippy::duplicate_underscore_argument)]
#![warn(clippy::double_neg)]
#![warn(clippy::unnecessary_mut_passed)]
#![warn(clippy::wildcard_in_or_patterns)]
#![warn(clippy::collapsible_if)]
#![warn(clippy::collapsible_else_if)]
#![warn(clippy::crosspointer_transmute)]
#![warn(clippy::excessive_precision)]
#![warn(clippy::overflow_check_conditional)]
#![warn(clippy::as_conversions)]
#![warn(clippy::match_overlapping_arm)]
#![warn(clippy::zero_divided_by_zero)]
#![warn(clippy::must_use_unit)]
#![warn(clippy::suspicious_assignment_formatting)]
#![warn(clippy::suspicious_else_formatting)]
#![warn(clippy::suspicious_unary_op_formatting)]
#![warn(clippy::mut_mutex_lock)]
#![warn(clippy::print_literal)]
#![warn(clippy::same_item_push)]
#![warn(clippy::useless_format)]
#![warn(clippy::write_literal)]
#![warn(clippy::redundant_closure)]
#![warn(clippy::redundant_closure_call)]
#![warn(clippy::unnecessary_lazy_evaluations)]
#![warn(clippy::partialeq_ne_impl)]
#![warn(clippy::redundant_field_names)]
#![warn(clippy::transmutes_expressible_as_ptr_casts)]
#![warn(clippy::unused_async)]
#![warn(clippy::disallowed_methods)]
#![warn(clippy::disallowed_macros)]
#![warn(clippy::disallowed_types)]
#![warn(clippy::from_over_into)]
// END LINT CONFIG

use std::time::Duration;
use std::{future::Future, time::SystemTime};

use claims::Claims;
use client::Auth;
use config::{ClientBuilder, ClientConfig};
use derivative::Derivative;
use error::FronteggError;
use jsonwebtoken::{decode, Algorithm, DecodingKey, Validation};
use tracing::warn;
use uuid::Uuid;

use mz_ore::now::NowFn;

pub mod app_password;
pub mod claims;
pub mod client;
pub mod config;
pub mod error;
pub mod parse;

pub struct FronteggConfig {
    /// URL for the token endpoint, including full path.
    pub admin_endpoint: String,
    /// JWK used to validate JWTs.
    pub decoding_key: DecodingKey,
    /// Tenant id used to validate JWTs.
    pub tenant_id: Uuid,
    /// Function to provide system time to validate exp (expires at) field of JWTs.
    pub now: NowFn,
    /// Name of admin role.
    pub admin_role: String,
}

#[derive(Clone, Derivative)]
#[derivative(Debug)]
pub struct FronteggAuthentication {
    admin_endpoint: String,
    #[derivative(Debug = "ignore")]
    decoding_key: DecodingKey,
    tenant_id: Uuid,
    now: NowFn,
    validation: Validation,
    admin_role: String,
}

impl FronteggAuthentication {
    /// Creates a new frontegg auth. `jwk_rsa_pem` is the RSA public key to
    /// validate the JWTs. `tenant_id` must be parseable as a UUID.
    pub fn new(config: FronteggConfig) -> Self {
        let mut validation = Validation::new(Algorithm::RS256);

        // We validate with our own now function.
        validation.validate_exp = false;
        Self {
            admin_endpoint: config.admin_endpoint,
            decoding_key: config.decoding_key,
            tenant_id: config.tenant_id,
            now: config.now,
            validation,
            admin_role: config.admin_role,
        }
    }

    /// Authenticates to Frontegg using a Materialize app-password and returns
    /// an access token with a target system time for renewal
    pub async fn auth(&self, password: &str) -> Result<Auth, FronteggError> {
        let client = ClientBuilder::default()
            .endpoint(self.admin_endpoint.parse().unwrap())
            .build(ClientConfig {
                app_password: password.parse()?,
            });

        Ok(client.auth().await.unwrap())
    }

    /// Validates an access token and its `tenant_id`.
    /// Returns the token claims
    pub fn validate_token(
        &self,
        token: String,
        expected_email: Option<&str>,
    ) -> Result<Claims, FronteggError> {
        let msg = decode::<Claims>(&token, &self.decoding_key, &self.validation)?;
        if msg.claims.exp < self.now.as_secs() {
            return Err(FronteggError::TokenExpired);
        }
        if msg.claims.tenant_id != self.tenant_id {
            return Err(FronteggError::UnauthorizedTenant);
        }
        if let Some(expected_email) = expected_email {
            if msg.claims.email != expected_email {
                return Err(FronteggError::WrongEmail);
            }
        }
        Ok(msg.claims)
    }

    /// Continuously validates and refreshes an access token.
    ///
    /// Validates the provided access token once, as `validate_access_token`
    /// does. If it is valid, returns a future that will attempt to refresh
    /// the access token before it expires, resolving iff the token expires
    /// or fails to refresh.
    ///
    /// The claims contained in the provided access token and all updated
    /// claims will be processed by `claims_processor`.
    pub async fn continuously_validate(
        &self,
        password: &str,
        expected_email: String,
        mut claims_processor: impl FnMut(Claims),
    ) -> Result<impl Future<Output = ()>, FronteggError> {
        // Do an initial full validity check of the token.
        let client = ClientBuilder::default()
            .endpoint(self.admin_endpoint.parse().unwrap())
            .build(ClientConfig {
                app_password: password.parse()?,
            });
        let mut auth = client.auth().await.unwrap();
        let claims = self.validate_token(auth.token.clone(), Some(&expected_email))?;
        claims_processor(claims.clone());
        let frontegg = self.clone();

        // This future resolves once the token expiry time has been reached. It will
        // repeatedly attempt to refresh the token before it expires.
        let expire_future = async move {
            loop {
                let current_time = SystemTime::now();

                let sleep_time = auth
                    .refresh_at
                    .duration_since(current_time)
                    .unwrap_or(Duration::from_millis(0));
                tokio::time::sleep(sleep_time).await;

                let refresh_request = async {
                    loop {
                        let resp = async {
                            let auth = client.auth().await.unwrap();
                            let claims = frontegg
                                .validate_token(auth.token.clone(), Some(&expected_email))?;
                            Ok::<(Auth, Claims), anyhow::Error>((auth, claims))
                        };
                        match resp.await {
                            Ok((auth, claims)) => {
                                return (auth, claims);
                            }
                            Err(_) => {
                                // Some error occurred, retry again later. 5 seconds chosen arbitrarily.
                                tokio::time::sleep(Duration::from_secs(5)).await;
                            }
                        }
                    }
                };

                let sleep_time = auth
                    .refresh_at
                    .duration_since(current_time)
                    .unwrap_or(Duration::from_millis(0));
                let expire_in = tokio::time::sleep(sleep_time);

                tokio::select! {
                    _ = expire_in => return (),
                    (refresh_auth, refresh_claims) = refresh_request => {
                        auth = refresh_auth;
                        claims_processor(refresh_claims.clone());
                    },
                };
            }
        };
        Ok(expire_future)
    }

    pub fn tenant_id(&self) -> Uuid {
        self.tenant_id
    }

    pub fn admin_role(&self) -> &str {
        &self.admin_role
    }
}
