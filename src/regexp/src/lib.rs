// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(unknown_lints)]
#![allow(clippy::style)]
#![allow(clippy::complexity)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::mutable_key_type)]
#![allow(clippy::stable_sort_primitive)]
#![allow(clippy::map_entry)]
#![allow(clippy::box_default)]
#![allow(clippy::drain_collect)]
#![warn(clippy::bool_comparison)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::no_effect)]
#![warn(clippy::unnecessary_unwrap)]
#![warn(clippy::dbg_macro)]
#![warn(clippy::todo)]
#![warn(clippy::wildcard_dependencies)]
#![warn(clippy::zero_prefixed_literal)]
#![warn(clippy::borrowed_box)]
#![warn(clippy::deref_addrof)]
#![warn(clippy::double_must_use)]
#![warn(clippy::double_parens)]
#![warn(clippy::extra_unused_lifetimes)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_question_mark)]
#![warn(clippy::needless_return)]
#![warn(clippy::redundant_pattern)]
#![warn(clippy::redundant_slicing)]
#![warn(clippy::redundant_static_lifetimes)]
#![warn(clippy::single_component_path_imports)]
#![warn(clippy::unnecessary_cast)]
#![warn(clippy::useless_asref)]
#![warn(clippy::useless_conversion)]
#![warn(clippy::builtin_type_shadow)]
#![warn(clippy::duplicate_underscore_argument)]
#![warn(clippy::double_neg)]
#![warn(clippy::unnecessary_mut_passed)]
#![warn(clippy::wildcard_in_or_patterns)]
#![warn(clippy::crosspointer_transmute)]
#![warn(clippy::excessive_precision)]
#![warn(clippy::overflow_check_conditional)]
#![warn(clippy::as_conversions)]
#![warn(clippy::match_overlapping_arm)]
#![warn(clippy::zero_divided_by_zero)]
#![warn(clippy::must_use_unit)]
#![warn(clippy::suspicious_assignment_formatting)]
#![warn(clippy::suspicious_else_formatting)]
#![warn(clippy::suspicious_unary_op_formatting)]
#![warn(clippy::mut_mutex_lock)]
#![warn(clippy::print_literal)]
#![warn(clippy::same_item_push)]
#![warn(clippy::useless_format)]
#![warn(clippy::write_literal)]
#![warn(clippy::redundant_closure)]
#![warn(clippy::redundant_closure_call)]
#![warn(clippy::unnecessary_lazy_evaluations)]
#![warn(clippy::partialeq_ne_impl)]
#![warn(clippy::redundant_field_names)]
#![warn(clippy::transmutes_expressible_as_ptr_casts)]
#![warn(clippy::unused_async)]
#![warn(clippy::disallowed_methods)]
#![warn(clippy::disallowed_macros)]
#![warn(clippy::disallowed_types)]
#![warn(clippy::from_over_into)]
// END LINT CONFIG

use mz_repr::adt::regex::Regex;

pub fn regexp_split_to_array<'a>(text: &'a str, regexp: &Regex) -> Vec<&'a str> {
    // Postgres regex split handling differs a bit from spec regex split, so we can't use
    // regexp.split here. See: https://www.postgresql.org/docs/15/functions-matching.html:
    // > the regexp split functions ignore zero-length matches that occur at the start or end
    // > of the string or immediately after a previous match

    let mut finder = regexp.find_iter(text);
    let mut last = 0;
    let mut found = Vec::new();
    loop {
        match finder.next() {
            None => {
                if last <= text.len() {
                    let s = &text[last..];
                    found.push(s);
                }
                break;
            }
            Some(m) => {
                // Ignore zero length matches at start and end of string.
                if m.end() > 0 && m.start() < text.len() {
                    let matched = &text[last..m.start()];
                    last = m.end();
                    found.push(matched);
                }
            }
        }
    }
    found
}

#[cfg(test)]
mod tests {
    use mz_repr::adt::regex::Regex;

    use crate::regexp_split_to_array;

    fn build_regex(needle: String, flags: &str) -> Result<Regex, anyhow::Error> {
        let mut case_insensitive = false;
        // Note: Postgres accepts it when both flags are present, taking the last one. We do the same.
        for f in flags.chars() {
            match f {
                'i' => {
                    case_insensitive = true;
                }
                'c' => {
                    case_insensitive = false;
                }
                _ => anyhow::bail!("unexpected regex flags"),
            }
        }
        Ok(Regex::new(needle, case_insensitive)?)
    }

    // Assert equivalency to postgres and generate TestCases.
    #[mz_ore::test]
    #[cfg_attr(miri, ignore)] // unsupported operation: returning ready events from epoll_wait is not yet implemented
    fn test_pg_regexp_split_array() {
        let Ok(postgres_url) = std::env::var("POSTGRES_URL") else {
            return;
        };
        let mut client = postgres::Client::connect(&postgres_url, postgres::NoTls).unwrap();

        let inputs = vec!["", " ", "  ", "12 34", "12  34", " 12 34 "];
        let regexps = vec!["", "\\s", "\\s+", "\\s*"];
        for input in inputs {
            for re in &regexps {
                let regex = build_regex(re.to_string(), "").unwrap();
                let pg: Vec<String> = client
                    .query_one("select regexp_split_to_array($1, $2)", &[&input, re])
                    .unwrap()
                    .get(0);
                let mz = regexp_split_to_array(input, &regex);
                assert_eq!(pg, mz);
                // Generate TestCases for static use.
                println!(
                    r#"TestCase {{
                text: "{input}",
                regexp: "{}",
                expect: &{pg:?},
            }},"#,
                    re.replace('\\', "\\\\"),
                );
            }
        }
    }

    #[mz_ore::test]
    fn test_regexp_split_array() {
        // Expected outputs generated from postgres.
        struct TestCase {
            text: &'static str,
            regexp: &'static str,
            expect: &'static [&'static str],
        }
        let tests = vec![
            TestCase {
                text: "",
                regexp: "",
                expect: &[""],
            },
            TestCase {
                text: "",
                regexp: "\\s",
                expect: &[""],
            },
            TestCase {
                text: "",
                regexp: "\\s+",
                expect: &[""],
            },
            TestCase {
                text: "",
                regexp: "\\s*",
                expect: &[""],
            },
            TestCase {
                text: " ",
                regexp: "",
                expect: &[" "],
            },
            TestCase {
                text: " ",
                regexp: "\\s",
                expect: &["", ""],
            },
            TestCase {
                text: " ",
                regexp: "\\s+",
                expect: &["", ""],
            },
            TestCase {
                text: " ",
                regexp: "\\s*",
                expect: &["", ""],
            },
            TestCase {
                text: "  ",
                regexp: "",
                expect: &[" ", " "],
            },
            TestCase {
                text: "  ",
                regexp: "\\s",
                expect: &["", "", ""],
            },
            TestCase {
                text: "  ",
                regexp: "\\s+",
                expect: &["", ""],
            },
            TestCase {
                text: "  ",
                regexp: "\\s*",
                expect: &["", ""],
            },
            TestCase {
                text: "12 34",
                regexp: "",
                expect: &["1", "2", " ", "3", "4"],
            },
            TestCase {
                text: "12 34",
                regexp: "\\s",
                expect: &["12", "34"],
            },
            TestCase {
                text: "12 34",
                regexp: "\\s+",
                expect: &["12", "34"],
            },
            TestCase {
                text: "12 34",
                regexp: "\\s*",
                expect: &["1", "2", "3", "4"],
            },
            TestCase {
                text: "12  34",
                regexp: "",
                expect: &["1", "2", " ", " ", "3", "4"],
            },
            TestCase {
                text: "12  34",
                regexp: "\\s",
                expect: &["12", "", "34"],
            },
            TestCase {
                text: "12  34",
                regexp: "\\s+",
                expect: &["12", "34"],
            },
            TestCase {
                text: "12  34",
                regexp: "\\s*",
                expect: &["1", "2", "3", "4"],
            },
            TestCase {
                text: " 12 34 ",
                regexp: "",
                expect: &[" ", "1", "2", " ", "3", "4", " "],
            },
            TestCase {
                text: " 12 34 ",
                regexp: "\\s",
                expect: &["", "12", "34", ""],
            },
            TestCase {
                text: " 12 34 ",
                regexp: "\\s+",
                expect: &["", "12", "34", ""],
            },
            TestCase {
                text: " 12 34 ",
                regexp: "\\s*",
                expect: &["", "1", "2", "3", "4", ""],
            },
        ];
        for tc in tests {
            let regex = build_regex(tc.regexp.to_string(), "").unwrap();
            let result = regexp_split_to_array(tc.text, &regex);
            if tc.expect != result {
                println!(
                    "input: `{}`, regex: `{}`, got: {:?}, expect: {:?}",
                    tc.text, tc.regexp, result, tc.expect
                );
            }
        }
    }
}
