// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(
    clippy::style,
    clippy::complexity,
    clippy::large_enum_variant,
    clippy::mutable_key_type,
    clippy::stable_sort_primitive,
    clippy::map_entry,
    clippy::box_default
)]
#![warn(
    clippy::bool_comparison,
    clippy::clone_on_ref_ptr,
    clippy::no_effect,
    clippy::unnecessary_unwrap,
    clippy::dbg_macro,
    clippy::todo,
    clippy::wildcard_dependencies,
    clippy::zero_prefixed_literal,
    clippy::borrowed_box,
    clippy::deref_addrof,
    clippy::double_must_use,
    clippy::double_parens,
    clippy::extra_unused_lifetimes,
    clippy::needless_borrow,
    clippy::needless_question_mark,
    clippy::needless_return,
    clippy::redundant_pattern,
    clippy::redundant_slicing,
    clippy::redundant_static_lifetimes,
    clippy::single_component_path_imports,
    clippy::unnecessary_cast,
    clippy::useless_asref,
    clippy::useless_conversion,
    clippy::builtin_type_shadow,
    clippy::duplicate_underscore_argument,
    clippy::double_neg,
    clippy::unnecessary_mut_passed,
    clippy::wildcard_in_or_patterns,
    clippy::collapsible_if,
    clippy::collapsible_else_if,
    clippy::crosspointer_transmute,
    clippy::excessive_precision,
    clippy::overflow_check_conditional,
    clippy::as_conversions,
    clippy::match_overlapping_arm,
    clippy::zero_divided_by_zero,
    clippy::must_use_unit,
    clippy::suspicious_assignment_formatting,
    clippy::suspicious_else_formatting,
    clippy::suspicious_unary_op_formatting,
    clippy::mut_mutex_lock,
    clippy::print_literal,
    clippy::same_item_push,
    clippy::useless_format,
    clippy::write_literal,
    clippy::redundant_closure,
    clippy::redundant_closure_call,
    clippy::unnecessary_lazy_evaluations,
    clippy::partialeq_ne_impl,
    clippy::redundant_field_names,
    clippy::transmutes_expressible_as_ptr_casts,
    clippy::unused_async,
    clippy::disallowed_methods,
    clippy::disallowed_macros,
    clippy::from_over_into
)]
// END LINT CONFIG

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
use rand::rngs::StdRng;
use rand::seq::SliceRandom;
use rand::{Rng, SeedableRng};

use mz_repr::strconv;

fn bench_parse_float32(c: &mut Criterion) {
    for s in &["-3.0", "9.7", "NaN", "inFiNiTy"] {
        c.bench_with_input(BenchmarkId::new("parse_float32", s), s, |b, s| {
            b.iter(|| strconv::parse_float32(s).unwrap())
        });
    }
}

fn bench_parse_numeric(c: &mut Criterion) {
    for s in &["-135412353251", "1.030340E11"] {
        c.bench_with_input(BenchmarkId::new("parse_numeric", s), s, |b, s| {
            b.iter(|| strconv::parse_numeric(s).unwrap())
        });
    }
}

fn bench_parse_jsonb(c: &mut Criterion) {
    let input = include_str!("testdata/twitter.json");
    c.bench_function("parse_jsonb", |b| {
        b.iter(|| black_box(strconv::parse_jsonb(input).unwrap()))
    });
}

fn bench_format_list_simple(c: &mut Criterion) {
    let mut rng = StdRng::from_seed([0; 32]);
    let list: Vec<i32> = (0..(1 << 12)).map(|_| rng.gen()).collect();
    c.bench_function("format_list simple", |b| {
        b.iter(|| {
            let mut buf = String::new();
            strconv::format_list(&mut buf, black_box(&list), |lw, i| {
                Ok::<_, ()>(strconv::format_int32(lw.nonnull_buffer(), *i))
            })
            .unwrap()
        })
    });
}

fn bench_format_list_nested(c: &mut Criterion) {
    let mut rng = StdRng::from_seed([0; 32]);
    const STRINGS: &[&str] = &[
        "NULL",
        "Po1bcC3mQWeYrMh6XaAM3ibM9CDDOoZK",
        r#""Elementary, my dear Watson," said Sherlock."#,
        "14VyaJllwQiPHRO2aNBo7p3P4v8cTLVB",
    ];
    let list: Vec<Vec<Vec<String>>> = (0..8)
        .map(|_| {
            (0..rng.gen_range(0..16))
                .map(|_| {
                    (1..rng.gen_range(0..16))
                        .map(|_| STRINGS.choose(&mut rng).unwrap())
                        .map(|s| (*s).to_owned())
                        .collect()
                })
                .collect()
        })
        .collect();

    c.bench_function("format_list nested", |b| {
        b.iter(|| {
            let mut buf = String::new();
            strconv::format_list(&mut buf, black_box(&list), |lw, list| {
                strconv::format_list(lw.nonnull_buffer(), list, |lw, list| {
                    strconv::format_list(lw.nonnull_buffer(), list, |lw, s| {
                        Ok::<_, ()>(strconv::format_string(lw.nonnull_buffer(), s))
                    })
                })
            })
            .unwrap();
        })
    });
}

criterion_group!(
    benches,
    bench_format_list_simple,
    bench_format_list_nested,
    bench_parse_numeric,
    bench_parse_float32,
    bench_parse_jsonb
);
criterion_main!(benches);
