# Copyright 2020 sqlparser-rs contributors. All rights reserved.
# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# This file is derived from the sqlparser-rs project, available at
# https://github.com/andygrove/sqlparser-rs. It was incorporated
# directly into Materialize on December 21, 2019.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the LICENSE file at the
# root of this repository, or online at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

parse-statement
CREATE TABLE uk_cities (
    name VARCHAR(100) NOT NULL,
    lat DOUBLE NULL,
    lng DOUBLE,
    constrained INT NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0),
    ref INT REFERENCES othertable (a, b)
)
----
CREATE TABLE uk_cities (name varchar(100) NOT NULL, lat float8 NULL, lng float8, constrained int4 NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0), ref int4 REFERENCES othertable (a, b))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("uk_cities")]), columns: [ColumnDef { name: Ident("name"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [100] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("lat"), data_type: Other { name: Name(UnresolvedObjectName([Ident("float8")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }] }, ColumnDef { name: Ident("lng"), data_type: Other { name: Name(UnresolvedObjectName([Ident("float8")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("constrained"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }, ColumnOptionDef { name: Some(Ident("pkey")), option: Unique { is_primary: true } }, ColumnOptionDef { name: None, option: NotNull }, ColumnOptionDef { name: None, option: Unique { is_primary: false } }, ColumnOptionDef { name: None, option: Check(Op { op: Op { namespace: [], op: ">" }, expr1: Identifier([Ident("constrained")]), expr2: Some(Value(Number("0"))) }) }] }, ColumnDef { name: Ident("ref"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: ForeignKey { foreign_table: UnresolvedObjectName([Ident("othertable")]), referred_columns: [Ident("a"), Ident("b")] } }] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (a int NOT NULL GARBAGE)
----
error: Expected column option, found identifier "garbage"
CREATE TABLE t (a int NOT NULL GARBAGE)
                               ^

parse-statement
CREATE TABLE t (c int) WITH (foo = 'bar', a = 123)
----
CREATE TABLE t (c int4) WITH (foo = 'bar', a = 123)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [WithOption { key: Ident("foo"), value: Some(Value(String("bar"))) }, WithOption { key: Ident("a"), value: Some(Value(Number("123"))) }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE types_table (char_col char, bpchar_col bpchar, text_col text, bool_col boolean, date_col date, time_col time, timestamp_col timestamp, uuid_col uuid, double_col double precision);
----
CREATE TABLE types_table (char_col bpchar, bpchar_col bpchar, text_col text, bool_col bool, date_col date, time_col time, timestamp_col timestamp, uuid_col uuid, double_col float8)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("types_table")]), columns: [ColumnDef { name: Ident("char_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("bpchar")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("bpchar_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("bpchar")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("text_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("text")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("bool_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("bool")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("date_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("date")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("time_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("time")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("timestamp_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("timestamp")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("uuid_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("uuid")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("double_col"), data_type: Other { name: Name(UnresolvedObjectName([Ident("float8")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t
----
error: Expected a list of columns in parentheses, found EOF
CREATE TABLE t
              ^

parse-statement
CREATE TABLE t ()
----
CREATE TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t ()
----
CREATE TEMPORARY TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [], constraints: [], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE foo (bar int,)
----
error: Expected column name or constraint definition, found right parenthesis
CREATE TABLE foo (bar int,)
                          ^

parse-statement
CREATE TABLE foo (bar int list)
----
CREATE TABLE foo (bar int4 list)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }), collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (bar int list list)
----
CREATE TABLE foo (bar int4 list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(List(Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] })), collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE tab (foo int,
----
error: Expected column name or constraint definition, found EOF
CREATE TABLE tab (foo int,
                          ^

parse-statement
CREATE TABLE foo (id int, CONSTRAINT address_pkey PRIMARY KEY (address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT address_pkey PRIMARY KEY (address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("address_pkey")), columns: [Ident("address_id")], is_primary: true }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT uk_task UNIQUE (report_date, task_id))
----
CREATE TABLE foo (id int4, CONSTRAINT uk_task UNIQUE (report_date, task_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("uk_task")), columns: [Ident("report_date"), Ident("task_id")], is_primary: false }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: Some(Ident("customer_address_id_fkey")), columns: [Ident("address_id")], foreign_table: Name(UnresolvedObjectName([Ident("public"), Ident("address")])), referred_columns: [Ident("address_id")] }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMPORARY TABLE foo (id int, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
----
CREATE TEMPORARY TABLE foo (id int4, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: Some(Ident("ck")), expr: Op { op: Op { namespace: [], op: "<>" }, expr1: Function(Function { name: UnresolvedObjectName([Ident("rtrim")]), args: Args { args: [Function(Function { name: UnresolvedObjectName([Ident("ltrim")]), args: Args { args: [Identifier([Ident("ref_code")])], order_by: [] }, filter: None, over: None, distinct: false })], order_by: [] }, filter: None, over: None, distinct: false }), expr2: Some(Value(String(""))) } }], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE foo (id int, PRIMARY KEY (foo, bar))
----
CREATE TABLE foo (id int4, PRIMARY KEY (foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("foo"), Ident("bar")], is_primary: true }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, UNIQUE (id))
----
CREATE TABLE foo (id int4, UNIQUE (id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("id")], is_primary: false }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
----
CREATE TABLE foo (id int4, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: None, columns: [Ident("foo"), Ident("bar")], foreign_table: Name(UnresolvedObjectName([Ident("anothertable")])), referred_columns: [Ident("foo"), Ident("bar")] }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CHECK (end_date > start_date OR end_date IS NULL))
----
CREATE TABLE foo (id int4, CHECK (end_date > start_date OR end_date IS NULL))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: Or { left: Op { op: Op { namespace: [], op: ">" }, expr1: Identifier([Ident("end_date")]), expr2: Some(Identifier([Ident("start_date")])) }, right: IsExpr { expr: Identifier([Ident("end_date")]), construct: Null, negated: false } } }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CHECK (end_date > start_date OR end_date IS UNKNOWN))
----
CREATE TABLE foo (id int4, CHECK (end_date > start_date OR end_date IS UNKNOWN))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: Or { left: Op { op: Op { namespace: [], op: ">" }, expr1: Identifier([Ident("end_date")]), expr2: Some(Identifier([Ident("start_date")])) }, right: IsExpr { expr: Identifier([Ident("end_date")]), construct: Unknown, negated: false } } }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CHECK (start_date IS TRUE))
----
CREATE TABLE foo (id int4, CHECK (start_date IS TRUE))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: IsExpr { expr: Identifier([Ident("start_date")]), construct: True, negated: false } }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t (c schema.type)
----
CREATE TEMPORARY TABLE t (c schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE t (c db.schema.type)
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c "db"."schema"."type")
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c something.db.schema.type)
----
CREATE TABLE t (c something.db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("something"), Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t (c db.schema.type(0,1,100))
----
CREATE TEMPORARY TABLE t (c db.schema.type(0, 1, 100))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [0, 1, 100] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE t (c time with time zone (0,1,100))
----
error: Expected column option, found left parenthesis
CREATE TABLE t (c time with time zone (0,1,100))
                                      ^

parse-statement
CREATE TABLE t (c t(1+1))
----
error: Expected right parenthesis, found operator "+"
CREATE TABLE t (c t(1+1))
                     ^

parse-statement
CREATE TABLE t (c t(1,))
----
error: Expected literal integer, found right parenthesis
CREATE TABLE t (c t(1,))
                      ^

parse-statement
CREATE TABLE t (c "type"(1))
----
CREATE TABLE t (c type(1))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("type")])), typ_mod: [1] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c "type"(1) list list)
----
CREATE TABLE t (c type(1) list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: List(List(Other { name: Name(UnresolvedObjectName([Ident("type")])), typ_mod: [1] })), collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE DATABASE IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE DATABASE IF EXISTS foo
                   ^

parse-statement
CREATE DATABASE foo.bar
----
error: Expected end of statement, found dot
CREATE DATABASE foo.bar
                   ^

parse-statement
CREATE SCHEMA foo.bar
----
CREATE SCHEMA foo.bar
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedSchemaName([Ident("foo"), Ident("bar")]), if_not_exists: false })

parse-statement
CREATE SCHEMA IF NOT EXISTS foo
----
CREATE SCHEMA IF NOT EXISTS foo
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedSchemaName([Ident("foo")]), if_not_exists: true })

parse-statement
CREATE SCHEMA IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE SCHEMA IF EXISTS foo
                 ^

parse-statement
CREATE VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: false, definition: ViewDefinition { name: UnresolvedObjectName([Ident("myschema"), Ident("myview")]), columns: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: true, definition: ViewDefinition { name: UnresolvedObjectName([Ident("myview")]), columns: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE TEMP VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: true, definition: ViewDefinition { name: UnresolvedObjectName([Ident("myview")]), columns: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE OR REPLACE VIEW v AS SELECT 1
----
CREATE OR REPLACE VIEW v AS SELECT 1
=>
CreateView(CreateViewStatement { if_exists: Replace, temporary: false, definition: ViewDefinition { name: UnresolvedObjectName([Ident("v")]), columns: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE VIEW IF NOT EXISTS v AS SELECT 1
----
CREATE VIEW IF NOT EXISTS v AS SELECT 1
=>
CreateView(CreateViewStatement { if_exists: Skip, temporary: false, definition: ViewDefinition { name: UnresolvedObjectName([Ident("v")]), columns: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
----
error: Expected AS, found NOT
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
                          ^

parse-statement
CREATE VIEW v (has, cols) AS SELECT 1, 2
----
CREATE VIEW v (has, cols) AS SELECT 1, 2
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: false, definition: ViewDefinition { name: UnresolvedObjectName([Ident("v")]), columns: [Ident("has"), Ident("cols")], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }, Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
----
CREATE VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Skip, temporary: false, definition: ViewDefinition { name: UnresolvedObjectName([Ident("myschema"), Ident("myview")]), columns: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE VIEWS FROM SOURCE "foobar"
----
CREATE VIEWS FROM SOURCE foobar
=>
CreateViews(CreateViewsStatement { if_exists: Error, temporary: false, source: Name(UnresolvedObjectName([Ident("foobar")])), targets: None })

parse-statement
CREATE OR REPLACE VIEWS FROM SOURCE "foobar"
----
CREATE OR REPLACE VIEWS FROM SOURCE foobar
=>
CreateViews(CreateViewsStatement { if_exists: Replace, temporary: false, source: Name(UnresolvedObjectName([Ident("foobar")])), targets: None })

parse-statement
CREATE VIEWS FROM SOURCE "foobar" ();
----
error: Expected identifier, found right parenthesis
CREATE VIEWS FROM SOURCE "foobar" ();
                                   ^

parse-statement
CREATE VIEWS FROM SOURCE "foobar" (t1, "t2" AS t3);
----
CREATE VIEWS FROM SOURCE foobar (t1, t2 AS t3)
=>
CreateViews(CreateViewsStatement { if_exists: Error, temporary: false, source: Name(UnresolvedObjectName([Ident("foobar")])), targets: Some([CreateViewsSourceTarget { name: UnresolvedObjectName([Ident("t1")]), alias: None }, CreateViewsSourceTarget { name: UnresolvedObjectName([Ident("t2")]), alias: Some(UnresolvedObjectName([Ident("t3")])) }]) })

parse-statement
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedObjectName([Ident("myschema"), Ident("myview")]), columns: [], in_cluster: None, query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE OR REPLACE MATERIALIZED VIEW v AS SELECT 1
----
CREATE OR REPLACE MATERIALIZED VIEW v AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Replace, name: UnresolvedObjectName([Ident("v")]), columns: [], in_cluster: None, query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW IF NOT EXISTS v AS SELECT 1
----
CREATE MATERIALIZED VIEW IF NOT EXISTS v AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Skip, name: UnresolvedObjectName([Ident("v")]), columns: [], in_cluster: None, query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW v (has, cols) AS SELECT 1, 2
----
CREATE MATERIALIZED VIEW v (has, cols) AS SELECT 1, 2
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedObjectName([Ident("v")]), columns: [Ident("has"), Ident("cols")], in_cluster: None, query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }, Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW v IN CLUSTER bar AS SELECT 1
----
CREATE MATERIALIZED VIEW v IN CLUSTER bar AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedObjectName([Ident("v")]), columns: [], in_cluster: Some(Unresolved(Ident("bar"))), query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW v IN CLUSTER [1] AS SELECT 1
----
CREATE MATERIALIZED VIEW v IN CLUSTER [1] AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedObjectName([Ident("v")]), columns: [], in_cluster: Some(Resolved("1")), query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE CONNECTION pgconn FOR postgres HOST foo, PORT 1234, SSL CERTIFICATE AUTHORITY 'foo', SSH TUNNEL tun
----
CREATE CONNECTION pgconn FOR POSTGRES HOST = foo, PORT = 1234, SSL CERTIFICATE AUTHORITY = 'foo', SSH TUNNEL = tun
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedObjectName([Ident("pgconn")]), connection: Postgres { with_options: [PostgresConnectionOption { name: Host, value: Some(Ident(Ident("foo"))) }, PostgresConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, PostgresConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("foo"))) }, PostgresConnectionOption { name: SshTunnel, value: Some(Object(Name(UnresolvedObjectName([Ident("tun")])))) }] }, if_not_exists: false })

parse-statement
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red');
----
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red')
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("psychic")]), col_names: [], connection: Postgres { connection: Name(UnresolvedObjectName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, legacy_with_options: [], include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (REPLICATION FACTOR = 7, RETENTION MS = 10000, RETENTION BYTES = 10000000000, TOPIC 'topic') FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (REPLICATION FACTOR = 7, RETENTION MS = 10000, RETENTION BYTES = 10000000000, TOPIC = 'topic') FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), if_not_exists: false, from: Name(UnresolvedObjectName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedObjectName([Ident("baz")])), options: [KafkaConfigOption { name: ReplicationFactor, value: Some(Value(Number("7"))) }, KafkaConfigOption { name: RetentionMs, value: Some(Value(Number("10000"))) }, KafkaConfigOption { name: RetentionBytes, value: Some(Value(Number("10000000000"))) }, KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: None }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') KEY (a, b) FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), if_not_exists: false, from: Name(UnresolvedObjectName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedObjectName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: Some(KafkaSinkKey { key_columns: [Ident("a"), Ident("b")], not_enforced: false }) }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), if_not_exists: false, from: Name(UnresolvedObjectName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedObjectName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: Some(KafkaSinkKey { key_columns: [Ident("a"), Ident("b")], not_enforced: true }) }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) CONSISTENCY (TOPIC 'consistency' FORMAT BYTES) FORMAT BYTES
----
error: Expected end of statement, found identifier "consistency"
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) CONSISTENCY (TOPIC 'consistency' FORMAT BYTES) FORMAT BYTES
                                                                              ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY FORMAT BYTES
----
error: Expected end of statement, found KEY
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY FORMAT BYTES
                                                                   ^

parse-statement
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
----
error: Expected NOT, found EXISTS
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
               ^

parse-statement
CREATE INDEX foo ON myschema.bar (a, b)
----
CREATE INDEX foo ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo ON myschema.bar USING arrangement (a, b)
----
CREATE INDEX foo ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo ON myschema.bar (a, b) WITH (LOGICAL COMPACTION WINDOW = 0)
----
CREATE INDEX foo ON myschema.bar (a, b) WITH (LOGICAL COMPACTION WINDOW = 0)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [IndexOption { name: LogicalCompactionWindow, value: Some(Value(Number("0"))) }], if_not_exists: false })

parse-statement
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
----
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("fizz")), in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("baz")])), key_parts: Some([Function(Function { name: UnresolvedObjectName([Ident("ascii")]), args: Args { args: [Identifier([Ident("x")])], order_by: [] }, filter: None, over: None, distinct: false }), IsExpr { expr: Identifier([Ident("a")]), construct: Null, negated: true }, Nested(Exists(Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("y")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("boop")])), alias: None }, joins: [] }], selection: Some(Op { op: Op { namespace: [], op: "=" }, expr1: Identifier([Ident("boop"), Ident("z")]), expr2: Some(Identifier([Ident("z")])) }), group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None })), Identifier([Ident("delta")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX ind ON tab ((col + 1))
----
CREATE INDEX ind ON tab ((col + 1))
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("ind")), in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("tab")])), key_parts: Some([Nested(Op { op: Op { namespace: [], op: "+" }, expr1: Identifier([Ident("col")]), expr2: Some(Value(Number("1"))) })]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
----
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("qualifiers")), in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("no_parentheses")])), key_parts: Some([Identifier([Ident("alpha"), Ident("omega")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo IN CLUSTER bar ON myschema.bar (a, b)
----
CREATE INDEX foo IN CLUSTER bar ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: Some(Unresolved(Ident("bar"))), on_name: Name(UnresolvedObjectName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo IN CLUSTER [1] ON myschema.bar (a, b)
----
CREATE INDEX foo IN CLUSTER [1] ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: Some(Resolved("1")), on_name: Name(UnresolvedObjectName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX ON tab
----
CREATE DEFAULT INDEX ON tab
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("tab")])), key_parts: None, with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
----
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("tab")])), key_parts: None, with_options: [], if_not_exists: true })

parse-statement
CREATE DEFAULT INDEX ON tab (a, b)
----
error: Expected end of statement, found left parenthesis
CREATE DEFAULT INDEX ON tab (a, b)
                            ^

parse-statement
CREATE INDEX ON tab;
----
error: Expected left parenthesis, found semicolon
CREATE INDEX ON tab;
                   ^

parse-statement
CREATE INDEX ON tab (a, b)
----
CREATE INDEX ON tab (a, b)
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedObjectName([Ident("tab")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX IF NOT EXISTS ON tab (a, b)
----
error: Expected index name, found ON
CREATE INDEX IF NOT EXISTS ON tab (a, b)
                           ^

parse-statement
CREATE INDEX myschema.ind ON foo(b)
----
error: Expected ON, found dot
CREATE INDEX myschema.ind ON foo(b)
                     ^

parse-statement
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
----
error: Expected NOT, found EXISTS
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
                ^

parse-statement
DROP DATABASE mydb
----
DROP DATABASE mydb
=>
DropDatabase(DropDatabaseStatement { name: UnresolvedDatabaseName(Ident("mydb")), if_exists: false, restrict: false })

parse-statement
DROP DATABASE IF EXISTS mydb
----
DROP DATABASE IF EXISTS mydb
=>
DropDatabase(DropDatabaseStatement { name: UnresolvedDatabaseName(Ident("mydb")), if_exists: true, restrict: false })

parse-statement
DROP DATABASE mydb.nope
----
error: Expected end of statement, found dot
DROP DATABASE mydb.nope
                  ^

parse-statement
DROP DATABASE mydb CASCADE
----
DROP DATABASE mydb
=>
DropDatabase(DropDatabaseStatement { name: UnresolvedDatabaseName(Ident("mydb")), if_exists: false, restrict: false })

parse-statement
DROP DATABASE mydb RESTRICT
----
DROP DATABASE mydb RESTRICT
=>
DropDatabase(DropDatabaseStatement { name: UnresolvedDatabaseName(Ident("mydb")), if_exists: false, restrict: true })

parse-statement
DROP DATABASE mydb CASCADE RESTRICT
----
error: Cannot specify both CASCADE and RESTRICT in DROP
DROP DATABASE mydb CASCADE RESTRICT
                           ^

parse-statement
DROP DATABASE mydb RESTRICT CASCADE
----
error: Cannot specify both RESTRICT and CASCADE in DROP
DROP DATABASE mydb RESTRICT CASCADE
                            ^

parse-statement
DROP DATABASE mydb CASCADE CASCADE
----
error: Expected end of statement, found CASCADE
DROP DATABASE mydb CASCADE CASCADE
                           ^

parse-statement
DROP SCHEMA mydb.myschema
----
DROP SCHEMA mydb.myschema
=>
DropSchema(DropSchemaStatement { name: UnresolvedSchemaName([Ident("mydb"), Ident("myschema")]), if_exists: false, cascade: false })

parse-statement
DROP TABLE foo
----
DROP TABLE foo
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: false, names: [UnresolvedObjectName([Ident("foo")])], cascade: false })

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE
----
DROP TABLE IF EXISTS foo, bar CASCADE
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: true, names: [UnresolvedObjectName([Ident("foo")]), UnresolvedObjectName([Ident("bar")])], cascade: true })

parse-statement
DROP TABLE
----
error: Expected identifier, found EOF
DROP TABLE
          ^

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
----
error: Cannot specify both CASCADE and RESTRICT in DROP
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
                                      ^

parse-statement
DROP VIEW myschema.myview
----
DROP VIEW myschema.myview
=>
DropObjects(DropObjectsStatement { object_type: View, if_exists: false, names: [UnresolvedObjectName([Ident("myschema"), Ident("myview")])], cascade: false })

parse-statement
DROP MATERIALIZED VIEW myschema.myview
----
DROP MATERIALIZED VIEW myschema.myview
=>
DropObjects(DropObjectsStatement { object_type: MaterializedView, if_exists: false, names: [UnresolvedObjectName([Ident("myschema"), Ident("myview")])], cascade: false })

parse-statement
DROP SOURCE myschema.mydatasource
----
DROP SOURCE myschema.mydatasource
=>
DropObjects(DropObjectsStatement { object_type: Source, if_exists: false, names: [UnresolvedObjectName([Ident("myschema"), Ident("mydatasource")])], cascade: false })

parse-statement
DROP INDEX IF EXISTS myschema.myindex
----
DROP INDEX IF EXISTS myschema.myindex
=>
DropObjects(DropObjectsStatement { object_type: Index, if_exists: true, names: [UnresolvedObjectName([Ident("myschema"), Ident("myindex")])], cascade: false })

parse-statement
SUBSCRIBE foo.bar
----
SUBSCRIBE foo.bar
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedObjectName([Ident("foo"), Ident("bar")]))), options: [], as_of: None })

parse-statement
SUBSCRIBE TO foo.bar
----
SUBSCRIBE foo.bar
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedObjectName([Ident("foo"), Ident("bar")]))), options: [], as_of: None })

parse-statement
SUBSCRIBE foo.bar AS OF 123
----
SUBSCRIBE foo.bar AS OF 123
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedObjectName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Value(Number("123")))) })

parse-statement
SUBSCRIBE foo.bar AS OF now()
----
SUBSCRIBE foo.bar AS OF now()
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedObjectName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))) })

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT) AS OF now()
----
SUBSCRIBE foo.bar WITH (SNAPSHOT) AS OF now()
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedObjectName([Ident("foo"), Ident("bar")]))), options: [SubscribeOption { name: Snapshot, value: None }], as_of: Some(At(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))) })

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT = false, TIMESTAMPS) AS OF now()
----
error: Expected one of PROGRESS or SNAPSHOT, found identifier "timestamps"
SUBSCRIBE foo.bar WITH (SNAPSHOT = false, TIMESTAMPS) AS OF now()
                                          ^

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT false)
----
SUBSCRIBE foo.bar WITH (SNAPSHOT = false)
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedObjectName([Ident("foo"), Ident("bar")]))), options: [SubscribeOption { name: Snapshot, value: Some(Value(Boolean(false))) }], as_of: None })

parse-statement
SUBSCRIBE (SELECT * FROM a)
----
SUBSCRIBE (SELECT * FROM a)
=>
Subscribe(SubscribeStatement { relation: Query(Query { ctes: [], body: Select(Select { distinct: None, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("a")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }), options: [], as_of: None })

parse-statement
CREATE TABLE public.customer (
        customer_id integer DEFAULT nextval(public.customer_customer_id_seq),
        store_id smallint NOT NULL,
        first_name character varying(45) NOT NULL,
        last_name character varying(45) COLLATE "es_ES" NOT NULL,
        email character varying(50),
        address_id smallint NOT NULL,
        activebool boolean DEFAULT true NOT NULL,
        create_date date DEFAULT now()::text NOT NULL,
        last_update timestamp without time zone DEFAULT now() NOT NULL,
        last_update_tz timestamp with time zone,
        active integer NOT NULL
) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
----
CREATE TABLE public.customer (customer_id int4 DEFAULT nextval(public.customer_customer_id_seq), store_id int2 NOT NULL, first_name varchar(45) NOT NULL, last_name varchar(45) COLLATE "es_ES" NOT NULL, email varchar(50), address_id int2 NOT NULL, activebool bool DEFAULT true NOT NULL, create_date date DEFAULT now()::text NOT NULL, last_update timestamp DEFAULT now() NOT NULL, last_update_tz timestamptz, active int4 NOT NULL) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("public"), Ident("customer")]), columns: [ColumnDef { name: Ident("customer_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Function(Function { name: UnresolvedObjectName([Ident("nextval")]), args: Args { args: [Identifier([Ident("public"), Ident("customer_customer_id_seq")])], order_by: [] }, filter: None, over: None, distinct: false })) }] }, ColumnDef { name: Ident("store_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int2")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("first_name"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [45] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("last_name"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [45] }, collation: Some(UnresolvedObjectName([Ident("es_ES")])), options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("email"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [50] }, collation: None, options: [] }, ColumnDef { name: Ident("address_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int2")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("activebool"), data_type: Other { name: Name(UnresolvedObjectName([Ident("bool")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Value(Boolean(true))) }, ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("create_date"), data_type: Other { name: Name(UnresolvedObjectName([Ident("date")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Cast { expr: Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }), data_type: Other { name: Name(UnresolvedObjectName([Ident("text")])), typ_mod: [] } }) }, ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("last_update"), data_type: Other { name: Name(UnresolvedObjectName([Ident("timestamp")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false })) }, ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("last_update_tz"), data_type: Other { name: Name(UnresolvedObjectName([Ident("timestamptz")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("active"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }], constraints: [], with_options: [WithOption { key: Ident("fillfactor"), value: Some(Value(Number("20"))) }, WithOption { key: Ident("user_catalog_table"), value: Some(Value(Boolean(true))) }, WithOption { key: Ident("autovacuum_vacuum_threshold"), value: Some(Value(Number("100"))) }], if_not_exists: false, temporary: false })

parse-statement roundtrip
CREATE TABLE public.customer (
    customer_id int DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
    store_id smallint NOT NULL,
    first_name character varying(45) NOT NULL,
    last_name character varying(45) NOT NULL,
    info text,
    address_id smallint NOT NULL,
    activebool boolean DEFAULT true NOT NULL,
    create_date date DEFAULT now()::date NOT NULL,
    create_date1 date DEFAULT 'now'::text::date NOT NULL,
    last_update timestamp DEFAULT now(),
    active int
)
----
CREATE TABLE public.customer (customer_id int4 DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL, store_id int2 NOT NULL, first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL, info text, address_id int2 NOT NULL, activebool bool DEFAULT true NOT NULL, create_date date DEFAULT now()::date NOT NULL, create_date1 date DEFAULT 'now'::text::date NOT NULL, last_update timestamp DEFAULT now(), active int4)

parse-statement roundtrip
CREATE TABLE bazaar.settings (
  settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL,
  user_id uuid UNIQUE,
  value text,
  use_metric boolean DEFAULT true
)
----
CREATE TABLE bazaar.settings (settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL, user_id uuid UNIQUE, value text, use_metric bool DEFAULT true)

parse-statement roundtrip
CREATE TABLE IF NOT EXISTS foo (bar int)
----
CREATE TABLE IF NOT EXISTS foo (bar int4)

parse-statement
ALTER INDEX name SET (property = true)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name SET (property = true)
                      ^

parse-statement
ALTER INDEX name RESET (property)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name RESET (property)
                        ^

parse-statement
ALTER INDEX IF EXISTS name SET (property = true)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX IF EXISTS name SET (property = true)
                                ^

parse-statement
ALTER INDEX name SET ()
----
error: Expected LOGICAL, found right parenthesis
ALTER INDEX name SET ()
                      ^

parse-statement
ALTER INDEX name RESET ()
----
error: Expected LOGICAL, found right parenthesis
ALTER INDEX name RESET ()
                        ^

parse-statement
ALTER INDEX name SET (property)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name SET (property)
                      ^

parse-statement
ALTER INDEX name RESET (property = true)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name RESET (property = true)
                        ^

parse-statement
ALTER SOURCE name SET (property = true)
----
error: Expected one of IGNORE or REMOTE or SIZE or TIMELINE or TIMESTAMP, found identifier "property"
ALTER SOURCE name SET (property = true)
                       ^

parse-statement
ALTER SOURCE name SET (SIZE LARGE)
----
ALTER SOURCE name SET (SIZE = large)
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedObjectName([Ident("name")]), if_exists: false, action: SetOptions([CreateSourceOption { name: Size, value: Some(Ident(Ident("large"))) }]) })

parse-statement
ALTER SOURCE name RESET (SIZE)
----
ALTER SOURCE name RESET (SIZE)
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedObjectName([Ident("name")]), if_exists: false, action: ResetOptions([Size]) })


parse-statement
ALTER VIEW name SET (property = true)
----
error: Expected RENAME, found SET
ALTER VIEW name SET (property = true)
                ^

parse-statement
ALTER MATERIALIZED VIEW name SET (property = true)
----
error: Expected RENAME, found SET
ALTER MATERIALIZED VIEW name SET (property = true)
                             ^

parse-statement
ALTER SINK name SET (property = true)
----
error: Expected RENAME, found SET
ALTER SINK name SET (property = true)
                ^

parse-statement
ALTER INDEX name RENAME TO name2
----
ALTER INDEX name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Index, if_exists: false, name: UnresolvedObjectName([Ident("name")]), to_item_name: Ident("name2") })

parse-statement
ALTER INDEX i1 misplaced
----
error: Expected one of RESET or SET or RENAME, found identifier "misplaced"
ALTER INDEX i1 misplaced
               ^

parse-statement
ALTER INDEX i1
----
error: Expected one of RESET or SET or RENAME, found EOF
ALTER INDEX i1
              ^

parse-statement
ALTER VIEW name RENAME TO name2
----
ALTER VIEW name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: View, if_exists: false, name: UnresolvedObjectName([Ident("name")]), to_item_name: Ident("name2") })

parse-statement
ALTER MATERIALIZED VIEW name RENAME TO name2
----
ALTER MATERIALIZED VIEW name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: MaterializedView, if_exists: false, name: UnresolvedObjectName([Ident("name")]), to_item_name: Ident("name2") })

parse-statement
CREATE CLUSTER cluster REPLICAS ()
----
CREATE CLUSTER cluster REPLICAS ()
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([])] })

parse-statement
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL '1s'
----
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL '1s'
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([]), IntrospectionInterval(Value(String("1s")))] })

parse-statement
CREATE CLUSTER cluster INTROSPECTION INTERVAL '1s', REPLICAS ()
----
CREATE CLUSTER cluster INTROSPECTION INTERVAL '1s', REPLICAS ()
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [IntrospectionInterval(Value(String("1s"))), Replicas([])] })

parse-statement
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL = '1s'
----
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL '1s'
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([]), IntrospectionInterval(Value(String("1s")))] })

parse-statement
CREATE CLUSTER cluster WITH REPLICAS (), INTROSPECTION INTERVAL = '1s'
----
error: Expected one of REPLICAS or INTROSPECTION, found WITH
CREATE CLUSTER cluster WITH REPLICAS (), INTROSPECTION INTERVAL = '1s'
                       ^

parse-statement
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL = 0
----
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL 0
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([]), IntrospectionInterval(Value(Number("0")))] })

parse-statement
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL = NULL
----
CREATE CLUSTER cluster REPLICAS (), INTROSPECTION INTERVAL NULL
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([]), IntrospectionInterval(Value(Null))] })

parse-statement
CREATE CLUSTER cluster REPLICAS (), BADOPT
----
error: Expected one of REPLICAS or INTROSPECTION, found identifier "badopt"
CREATE CLUSTER cluster REPLICAS (), BADOPT
                                    ^

parse-statement
CREATE CLUSTER cluster REPLICAS (a (REMOTE ['host1']))
----
CREATE CLUSTER cluster REPLICAS (a (REMOTE = ['host1']))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: Remote, value: Some(Value(Array([String("host1")]))) }] }])] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (REMOTE ['host1']), b (SIZE '1')), INTROSPECTION INTERVAL '1s'
----
CREATE CLUSTER cluster REPLICAS (a (REMOTE = ['host1']), b (SIZE = '1')), INTROSPECTION INTERVAL '1s'
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: Remote, value: Some(Value(Array([String("host1")]))) }] }, ReplicaDefinition { name: Ident("b"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }] }]), IntrospectionInterval(Value(String("1s")))] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (REMOTE ['host1'], SIZE '1'))
----
CREATE CLUSTER cluster REPLICAS (a (REMOTE = ['host1'], SIZE = '1'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: Remote, value: Some(Value(Array([String("host1")]))) }, ReplicaOption { name: Size, value: Some(Value(String("1"))) }] }])] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (REMOTE ['host1:2400', 'host2:2400'], COMPUTE ['host1:2401', 'host2:2401'], WORKERS '1'))
----
CREATE CLUSTER cluster REPLICAS (a (REMOTE = ['host1:2400', 'host2:2400'], COMPUTE = ['host1:2401', 'host2:2401'], WORKERS = '1'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [Replicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: Remote, value: Some(Value(Array([String("host1:2400"), String("host2:2400")]))) }, ReplicaOption { name: Compute, value: Some(Value(Array([String("host1:2401"), String("host2:2401")]))) }, ReplicaOption { name: Workers, value: Some(Value(String("1"))) }] }])] })

parse-statement
CREATE CLUSTER REPLICA replica REMOTE ['host1']
----
error: Expected dot, found REMOTE
CREATE CLUSTER REPLICA replica REMOTE ['host1']
                               ^

parse-statement
CREATE CLUSTER REPLICA replica SIZE 'small'
----
error: Expected dot, found SIZE
CREATE CLUSTER REPLICA replica SIZE 'small'
                               ^

parse-statement
CREATE CLUSTER REPLICA replica SIZE 'small', (REMOTE ['host1'])
----
error: Expected dot, found SIZE
CREATE CLUSTER REPLICA replica SIZE 'small', (REMOTE ['host1'])
                               ^

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small'
----
CREATE CLUSTER REPLICA default.replica SIZE = 'small'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', AVAILABILITY ZONE 'a'
----
CREATE CLUSTER REPLICA default.replica SIZE = 'small', AVAILABILITY ZONE = 'a'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica AVAILABILITY ZONE 'a', AVAILABILITY ZONE 'b'
----
CREATE CLUSTER REPLICA default.replica AVAILABILITY ZONE = 'a', AVAILABILITY ZONE = 'b'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("b"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica REMOTE ['host1'], AVAILABILITY ZONE 'a'
----
CREATE CLUSTER REPLICA default.replica REMOTE = ['host1'], AVAILABILITY ZONE = 'a'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Remote, value: Some(Value(Array([String("host1")]))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }] } })

parse-statement
DROP CLUSTER cluster
----
DROP CLUSTER cluster
=>
DropClusters(DropClustersStatement { if_exists: false, names: [UnresolvedObjectName([Ident("cluster")])], cascade: false })

parse-statement
DROP CLUSTER IF EXISTS cluster
----
DROP CLUSTER IF EXISTS cluster
=>
DropClusters(DropClustersStatement { if_exists: true, names: [UnresolvedObjectName([Ident("cluster")])], cascade: false })

parse-statement
DROP CLUSTER IF EXISTS cluster RESTRICT
----
DROP CLUSTER IF EXISTS cluster
=>
DropClusters(DropClustersStatement { if_exists: true, names: [UnresolvedObjectName([Ident("cluster")])], cascade: false })

parse-statement
DROP CLUSTER REPLICA r1, r2
----
error: Expected dot, found comma
DROP CLUSTER REPLICA r1, r2
                       ^

parse-statement
DROP CLUSTER REPLICA IF EXISTS cluster.replica
----
DROP CLUSTER REPLICA IF EXISTS cluster.replica
=>
DropClusterReplicas(DropClusterReplicasStatement { if_exists: true, names: [QualifiedReplica { cluster: Ident("cluster"), replica: Ident("replica") }], cascade: false })

parse-statement
DROP CLUSTER REPLICA cluster.replica CASCADE
----
DROP CLUSTER REPLICA cluster.replica CASCADE
=>
DropClusterReplicas(DropClusterReplicasStatement { if_exists: false, names: [QualifiedReplica { cluster: Ident("cluster"), replica: Ident("replica") }], cascade: true })



parse-statement
DROP CLUSTER REPLICA IF EXISTS cluster.replica CASCADE
----
DROP CLUSTER REPLICA IF EXISTS cluster.replica CASCADE
=>
DropClusterReplicas(DropClusterReplicasStatement { if_exists: true, names: [QualifiedReplica { cluster: Ident("cluster"), replica: Ident("replica") }], cascade: true })

parse-statement
DROP CLUSTER REPLICA IF EXISTS replica
----
error: Expected dot, found EOF
DROP CLUSTER REPLICA IF EXISTS replica
                                      ^

parse-statement
DROP CLUSTER IF EXISTS cluster CASCADE
----
DROP CLUSTER IF EXISTS cluster CASCADE
=>
DropClusters(DropClustersStatement { if_exists: true, names: [UnresolvedObjectName([Ident("cluster")])], cascade: true })

parse-statement
CREATE SECRET secret AS decode('c2VjcmV0Cg==', 'base64')
----
CREATE SECRET secret AS decode('c2VjcmV0Cg==', 'base64')
=>
CreateSecret(CreateSecretStatement { name: UnresolvedObjectName([Ident("secret")]), if_not_exists: false, value: Function(Function { name: UnresolvedObjectName([Ident("decode")]), args: Args { args: [Value(String("c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
CREATE SECRET IF NOT EXISTS secret AS decode('c2VjcmV0Cg==', 'base64')
----
CREATE SECRET IF NOT EXISTS secret AS decode('c2VjcmV0Cg==', 'base64')
=>
CreateSecret(CreateSecretStatement { name: UnresolvedObjectName([Ident("secret")]), if_not_exists: true, value: Function(Function { name: UnresolvedObjectName([Ident("decode")]), args: Args { args: [Value(String("c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
DROP SECRET secret
----
DROP SECRET secret
=>
DropObjects(DropObjectsStatement { object_type: Secret, if_exists: false, names: [UnresolvedObjectName([Ident("secret")])], cascade: false })

parse-statement
DROP SECRET IF EXISTS secret
----
DROP SECRET IF EXISTS secret
=>
DropObjects(DropObjectsStatement { object_type: Secret, if_exists: true, names: [UnresolvedObjectName([Ident("secret")])], cascade: false })

parse-statement
SHOW SECRETS
----
SHOW SECRETS
=>
Show(ShowObjects(ShowObjectsStatement { object_type: Secret, from: None, in_cluster: None, filter: None }))

parse-statement
ALTER SECRET secret RENAME TO secret2
----
ALTER SECRET secret RENAME TO secret2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Secret, if_exists: false, name: UnresolvedObjectName([Ident("secret")]), to_item_name: Ident("secret2") })

parse-statement
ALTER SECRET secret AS decode('new c2VjcmV0Cg==', 'base64')
----
ALTER SECRET secret AS decode('new c2VjcmV0Cg==', 'base64')
=>
AlterSecret(AlterSecretStatement { name: UnresolvedObjectName([Ident("secret")]), if_exists: false, value: Function(Function { name: UnresolvedObjectName([Ident("decode")]), args: Args { args: [Value(String("new c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
CREATE CONNECTION conn1 FOR KAFKA BROKER 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux';
----
CREATE CONNECTION conn1 FOR KAFKA BROKER = 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux'
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedObjectName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Broker, value: Some(Value(String("kafka:1234"))) }, KafkaConnectionOption { name: SslKey, value: Some(Value(String("foo"))) }, KafkaConnectionOption { name: SslCertificate, value: Some(Value(String("qux"))) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION conn1 FOR KAFKA BROKER 'kafka:1234', PROGRESS TOPIC 'my-materialize-progress-topic';
----
CREATE CONNECTION conn1 FOR KAFKA BROKER = 'kafka:1234', PROGRESS TOPIC = 'my-materialize-progress-topic'
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedObjectName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Broker, value: Some(Value(String("kafka:1234"))) }, KafkaConnectionOption { name: ProgressTopic, value: Some(Value(String("my-materialize-progress-topic"))) }] }, if_not_exists: false })

parse-statement
DROP CONNECTION conn1
----
DROP CONNECTION conn1
=>
DropObjects(DropObjectsStatement { object_type: Connection, if_exists: false, names: [UnresolvedObjectName([Ident("conn1")])], cascade: false })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') LEGACYWITH (consistency = 'lug') FORMAT BYTES
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') LEGACYWITH (consistency = 'lug') FORMAT BYTES
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("src1")]), col_names: [], connection: Kafka(KafkaSourceConnection { connection: KafkaConnection { connection: Name(UnresolvedObjectName([Ident("conn1")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, key: None }), legacy_with_options: [WithOption { key: Ident("consistency"), value: Some(Value(String("lug"))) }], include_metadata: [], format: Bare(Bytes), envelope: None, if_not_exists: false, key_constraint: None, with_options: [] })

parse-statement
CREATE CONNECTION conn1 FOR CONFLUENT SCHEMA REGISTRY URL 'http://localhost:8081', USERNAME 'user', PASSWORD 'word'
----
CREATE CONNECTION conn1 FOR CONFLUENT SCHEMA REGISTRY URL = 'http://localhost:8081', USERNAME = 'user', PASSWORD = 'word'
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedObjectName([Ident("conn1")]), connection: Csr { with_options: [CsrConnectionOption { name: Url, value: Some(Value(String("http://localhost:8081"))) }, CsrConnectionOption { name: Username, value: Some(Value(String("user"))) }, CsrConnectionOption { name: Password, value: Some(Value(String("word"))) }] }, if_not_exists: false })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("src1")]), col_names: [], connection: Kafka(KafkaSourceConnection { connection: KafkaConnection { connection: Name(UnresolvedObjectName([Ident("conn1")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, key: None }), legacy_with_options: [], include_metadata: [], format: Bare(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedObjectName([Ident("conn2")])), options: [] }, key_strategy: None, value_strategy: None, seed: None } })), envelope: Some(Debezium(Plain)), if_not_exists: false, key_constraint: None, with_options: [] })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("src1")]), col_names: [], connection: Kafka(KafkaSourceConnection { connection: KafkaConnection { connection: Name(UnresolvedObjectName([Ident("conn1")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, key: None }), legacy_with_options: [], include_metadata: [], format: Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedObjectName([Ident("conn2")])), options: [] }, seed: None } })), envelope: Some(Debezium(Plain)), if_not_exists: false, key_constraint: None, with_options: [] })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (SOURCE a.b.c, COLLECTION 'foo'))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (SOURCE a.b.c, COLLECTION 'foo'))
                                                                               ^

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                                               ^

# Note that this will error in planninf, as you cannot specify START OFFSET and START TIMESTAMP at the same time
parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (START OFFSET=1, START TIMESTAMP=2, TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (START OFFSET=1, START TIMESTAMP=2, TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                                                                                  ^

# Note that this will error in planning, as START OFFSET must be an array of nums
parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 WITH (START OFFSET="hmm") TOPIC 'baz' ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected one of IGNORE or REMOTE or SIZE or TIMELINE or TIMESTAMP, found START
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 WITH (START OFFSET="hmm") TOPIC 'baz' ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                     ^

parse-statement
CREATE SOURCE golbat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' KEY FORMAT TEXT VALUE FORMAT TEXT INCLUDE KEY ENVELOPE NONE WITH (REMOTE 'johto:42', SIZE large)
----
error: Expected CONNECTION, found BROKER
CREATE SOURCE golbat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' KEY FORMAT TEXT VALUE FORMAT TEXT INCLUDE KEY ENVELOPE NONE WITH (REMOTE 'johto:42', SIZE large)
                                ^

parse-statement
CREATE CONNECTION my_ssh_tunnel FOR SSH TUNNEL HOST 'ssh-bastion', PORT 1234, USER 'blah'
----
CREATE CONNECTION my_ssh_tunnel FOR SSH TUNNEL HOST = 'ssh-bastion', PORT = 1234, USER = 'blah'
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedObjectName([Ident("my_ssh_tunnel")]), connection: Ssh { with_options: [SshConnectionOption { name: Host, value: Some(Value(String("ssh-bastion"))) }, SshConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, SshConnectionOption { name: User, value: Some(Value(String("blah"))) }] }, if_not_exists: false })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER
----
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("lg")]), col_names: [], connection: LoadGenerator { generator: Counter, options: [] }, legacy_with_options: [], include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [] })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER TICK INTERVAL '1s'
----
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER TICK INTERVAL = '1s'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("lg")]), col_names: [], connection: LoadGenerator { generator: Counter, options: [LoadGeneratorOption { name: TickInterval, value: Some(Value(String("1s"))) }] }, legacy_with_options: [], include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [] })

# Ensure that we can parse REMOTE with pg
parse-statement
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red') with (REMOTE 'johto:42');
----
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red') WITH (REMOTE = 'johto:42')
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("psychic")]), col_names: [], connection: Postgres { connection: Name(UnresolvedObjectName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, legacy_with_options: [], include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Remote, value: Some(Value(String("johto:42"))) }] })

# Ensure that we can parse legacy and non-legacy options
parse-statement
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red') legacywith (a = 'hmm') with (REMOTE 'johto:42');
----
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red') LEGACYWITH (a = 'hmm') WITH (REMOTE = 'johto:42')
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("psychic")]), col_names: [], connection: Postgres { connection: Name(UnresolvedObjectName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, legacy_with_options: [WithOption { key: Ident("a"), value: Some(Value(String("hmm"))) }], include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Remote, value: Some(Value(String("johto:42"))) }] })

parse-statement
ALTER SYSTEM SET wal_level TO logical
----
ALTER SYSTEM SET wal_level = logical
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("wal_level"), value: Ident(Ident("logical")) })

parse-statement
ALTER SYSTEM SET wal_level = logical
----
ALTER SYSTEM SET wal_level = logical
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("wal_level"), value: Ident(Ident("logical")) })

parse-statement
ALTER SYSTEM SET log_destination TO 'syslog'
----
ALTER SYSTEM SET log_destination = 'syslog'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_destination"), value: Literal(String("syslog")) })

parse-statement
ALTER SYSTEM SET log_destination = 'syslog'
----
ALTER SYSTEM SET log_destination = 'syslog'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_destination"), value: Literal(String("syslog")) })

parse-statement
ALTER SYSTEM SET shared_buffers TO 42
----
ALTER SYSTEM SET shared_buffers = 42
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("shared_buffers"), value: Literal(Number("42")) })

parse-statement
ALTER SYSTEM SET shared_buffers = 42
----
ALTER SYSTEM SET shared_buffers = 42
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("shared_buffers"), value: Literal(Number("42")) })

parse-statement
ALTER SYSTEM SET search_path TO default
----
ALTER SYSTEM SET search_path = DEFAULT
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("search_path"), value: Default })

parse-statement
ALTER SYSTEM SET search_path = default
----
ALTER SYSTEM SET search_path = DEFAULT
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("search_path"), value: Default })

parse-statement
ALTER SYSTEM SET log_connections TO 'default'
----
ALTER SYSTEM SET log_connections = 'default'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_connections"), value: Literal(String("default")) })

parse-statement
ALTER SYSTEM SET log_connections = 'default'
----
ALTER SYSTEM SET log_connections = 'default'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_connections"), value: Literal(String("default")) })

parse-statement
ALTER SYSTEM SET some_array_key = [667, 668]
----
ALTER SYSTEM SET some_array_key = [667, 668]
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("some_array_key"), value: Literal(Array([Number("667"), Number("668")])) })

parse-statement
ALTER SYSTEM SET quantum_enabled = true
----
ALTER SYSTEM SET quantum_enabled = true
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("quantum_enabled"), value: Literal(Boolean(true)) })

parse-statement
ALTER SYSTEM SET use_optional = NULL
----
ALTER SYSTEM SET use_optional = NULL
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("use_optional"), value: Literal(Null) })

parse-statement
ALTER SYSTEM SET key value
----
error: Expected TO or equals sign, found VALUE
ALTER SYSTEM SET key value
                     ^

parse-statement
ALTER SYSTEM RESET wal_level
----
ALTER SYSTEM RESET wal_level
=>
AlterSystemReset(AlterSystemResetStatement { name: Ident("wal_level") })

parse-statement
ALTER SYSTEM RESET ALL
----
ALTER SYSTEM RESET ALL
=>
AlterSystemResetAll(AlterSystemResetAllStatement)

parse-statement
ALTER SYSTEM RESET
----
error: Expected identifier, found EOF
ALTER SYSTEM RESET
                  ^
