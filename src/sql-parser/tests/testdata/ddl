# Copyright 2020 sqlparser-rs contributors. All rights reserved.
# Copyright Materialize, Inc. All rights reserved.
#
# This file is derived from the sqlparser-rs project, available at
# https://github.com/andygrove/sqlparser-rs. It was incorporated
# directly into Materialize on December 21, 2019.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the LICENSE file at the
# root of this repository, or online at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

parse-statement
CREATE TABLE uk_cities (
    name VARCHAR(100) NOT NULL,
    lat DOUBLE NULL,
    lng DOUBLE,
    constrained INT NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0),
    ref INT REFERENCES othertable (a, b)
)
----
CREATE TABLE uk_cities (name varchar(100) NOT NULL, lat float8 NULL, lng float8, constrained int4 NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0), ref int4 REFERENCES othertable (a, b))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("uk_cities")]), columns: [ColumnDef { name: Ident("name"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [100] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("lat"), data_type: Other { name: Name(UnresolvedObjectName([Ident("float8")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }] }, ColumnDef { name: Ident("lng"), data_type: Other { name: Name(UnresolvedObjectName([Ident("float8")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("constrained"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }, ColumnOptionDef { name: Some(Ident("pkey")), option: Unique { is_primary: true } }, ColumnOptionDef { name: None, option: NotNull }, ColumnOptionDef { name: None, option: Unique { is_primary: false } }, ColumnOptionDef { name: None, option: Check(Op { op: ">", expr1: Identifier([Ident("constrained")]), expr2: Some(Value(Number("0"))) }) }] }, ColumnDef { name: Ident("ref"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: ForeignKey { foreign_table: UnresolvedObjectName([Ident("othertable")]), referred_columns: [Ident("a"), Ident("b")] } }] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (a int NOT NULL GARBAGE)
----
error: Expected column option, found identifier 'garbage'
CREATE TABLE t (a int NOT NULL GARBAGE)
                               ^

parse-statement
CREATE TABLE t (c int) WITH (foo = 'bar', a = 123)
----
CREATE TABLE t (c int4) WITH (foo = 'bar', a = 123)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [Value { name: Ident("foo"), value: String("bar") }, Value { name: Ident("a"), value: Number("123") }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t
----
error: Expected a list of columns in parentheses, found EOF
CREATE TABLE t
              ^

parse-statement
CREATE TABLE t ()
----
CREATE TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t ()
----
CREATE TEMPORARY TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [], constraints: [], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE foo (bar int,)
----
error: Expected column name or constraint definition, found right parenthesis
CREATE TABLE foo (bar int,)
                          ^

parse-statement
CREATE TABLE foo (bar int list)
----
CREATE TABLE foo (bar int4 list)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }), collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (bar int list list)
----
CREATE TABLE foo (bar int4 list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(List(Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] })), collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE tab (foo int,
----
error: Expected column name or constraint definition, found EOF
CREATE TABLE tab (foo int,
                          ^

parse-statement
CREATE TABLE foo (id int, CONSTRAINT address_pkey PRIMARY KEY (address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT address_pkey PRIMARY KEY (address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("address_pkey")), columns: [Ident("address_id")], is_primary: true }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT uk_task UNIQUE (report_date, task_id))
----
CREATE TABLE foo (id int4, CONSTRAINT uk_task UNIQUE (report_date, task_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("uk_task")), columns: [Ident("report_date"), Ident("task_id")], is_primary: false }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: Some(Ident("customer_address_id_fkey")), columns: [Ident("address_id")], foreign_table: UnresolvedObjectName([Ident("public"), Ident("address")]), referred_columns: [Ident("address_id")] }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMPORARY TABLE foo (id int, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
----
CREATE TEMPORARY TABLE foo (id int4, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: Some(Ident("ck")), expr: Op { op: "<>", expr1: Function(Function { name: UnresolvedObjectName([Ident("rtrim")]), args: Args([Function(Function { name: UnresolvedObjectName([Ident("ltrim")]), args: Args([Identifier([Ident("ref_code")])]), filter: None, over: None, distinct: false })]), filter: None, over: None, distinct: false }), expr2: Some(Value(String(""))) } }], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE foo (id int, PRIMARY KEY (foo, bar))
----
CREATE TABLE foo (id int4, PRIMARY KEY (foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("foo"), Ident("bar")], is_primary: true }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, UNIQUE (id))
----
CREATE TABLE foo (id int4, UNIQUE (id))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("id")], is_primary: false }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
----
CREATE TABLE foo (id int4, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: None, columns: [Ident("foo"), Ident("bar")], foreign_table: UnresolvedObjectName([Ident("anothertable")]), referred_columns: [Ident("foo"), Ident("bar")] }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CHECK (end_date > start_date OR end_date IS NULL))
----
CREATE TABLE foo (id int4, CHECK (end_date > start_date OR end_date IS NULL))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: Or { left: Op { op: ">", expr1: Identifier([Ident("end_date")]), expr2: Some(Identifier([Ident("start_date")])) }, right: IsNull { expr: Identifier([Ident("end_date")]), negated: false } } }], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t (c schema.type)
----
CREATE TEMPORARY TABLE t (c schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE t (c db.schema.type)
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c "db"."schema"."type")
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c something.db.schema.type)
----
CREATE TABLE t (c something.db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("something"), Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t (c db.schema.type(0,1,100))
----
CREATE TEMPORARY TABLE t (c db.schema.type(0, 1, 100))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [0, 1, 100] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE t (c time with time zone (0,1,100))
----
error: Expected column option, found left parenthesis
CREATE TABLE t (c time with time zone (0,1,100))
                                      ^

parse-statement
CREATE TABLE t (c t(1+1))
----
error: Expected right parenthesis, found operator '+'
CREATE TABLE t (c t(1+1))
                     ^

parse-statement
CREATE TABLE t (c t(1,))
----
error: Expected literal int, found right parenthesis
CREATE TABLE t (c t(1,))
                      ^

parse-statement
CREATE TABLE t (c "type"(1))
----
CREATE TABLE t (c type(1))
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedObjectName([Ident("type")])), typ_mod: [1] }, collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c "type"(1) list list)
----
CREATE TABLE t (c type(1) list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: List(List(Other { name: Name(UnresolvedObjectName([Ident("type")])), typ_mod: [1] })), collation: None, options: [] }], constraints: [], with_options: [], if_not_exists: false, temporary: false })

parse-statement
CREATE DATABASE IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE DATABASE IF EXISTS foo
                   ^

parse-statement
CREATE DATABASE foo.bar
----
error: Expected end of statement, found dot
CREATE DATABASE foo.bar
                   ^

parse-statement
CREATE SCHEMA foo.bar
----
CREATE SCHEMA foo.bar
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedObjectName([Ident("foo"), Ident("bar")]), if_not_exists: false })

parse-statement
CREATE SCHEMA IF NOT EXISTS foo
----
CREATE SCHEMA IF NOT EXISTS foo
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedObjectName([Ident("foo")]), if_not_exists: true })

parse-statement
CREATE SCHEMA IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE SCHEMA IF EXISTS foo
                 ^

parse-statement
CREATE VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("myschema"), Ident("myview")]), columns: [], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Error, temporary: false, materialized: false })

parse-statement
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("myview")]), columns: [], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Error, temporary: true, materialized: false })

parse-statement
CREATE TEMP VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("myview")]), columns: [], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Error, temporary: true, materialized: false })

parse-statement
CREATE OR REPLACE VIEW v AS SELECT 1
----
CREATE OR REPLACE VIEW v AS SELECT 1
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("v")]), columns: [], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Replace, temporary: false, materialized: false })

parse-statement
CREATE VIEW IF NOT EXISTS v AS SELECT 1
----
CREATE VIEW IF NOT EXISTS v AS SELECT 1
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("v")]), columns: [], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Skip, temporary: false, materialized: false })

parse-statement
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
----
error: Expected AS, found NOT
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
                          ^

parse-statement
CREATE VIEW v WITH (foo = 'bar', a = 123) AS SELECT 1
----
CREATE VIEW v WITH (foo = 'bar', a = 123) AS SELECT 1
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("v")]), columns: [], with_options: [Value { name: Ident("foo"), value: String("bar") }, Value { name: Ident("a"), value: Number("123") }], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Error, temporary: false, materialized: false })

parse-statement
CREATE VIEW v (has, cols) AS SELECT 1, 2
----
CREATE VIEW v (has, cols) AS SELECT 1, 2
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("v")]), columns: [Ident("has"), Ident("cols")], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }, Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Error, temporary: false, materialized: false })

parse-statement
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("myschema"), Ident("myview")]), columns: [], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Error, temporary: false, materialized: true })

parse-statement
CREATE MATERIALIZED VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
----
CREATE MATERIALIZED VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { name: UnresolvedObjectName([Ident("myschema"), Ident("myview")]), columns: [], with_options: [], query: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, if_exists: Skip, temporary: false, materialized: true })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING SCHEMA 'baz'
----
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING SCHEMA 'baz'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Avro(Schema { schema: Inline("baz"), with_options: [] })), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo
FROM KAFKA BROKER 'bar' TOPIC 'baz' WITH (consistency = 'lug', ssl_certificate_file = '/Path/to/file')
FORMAT BYTES
----
CREATE SOURCE foo FROM KAFKA BROKER 'bar' TOPIC 'baz' WITH (consistency = 'lug', ssl_certificate_file = '/Path/to/file') FORMAT BYTES
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: Kafka { broker: "bar", topic: "baz", key: None }, with_options: [Value { name: Ident("consistency"), value: String("lug") }, Value { name: Ident("ssl_certificate_file"), value: String("/Path/to/file") }], format: Some(Bytes), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE MATERIALIZED SOURCE foo FROM FILE 'bar' FORMAT PROTOBUF MESSAGE
'somemessage' USING SCHEMA FILE 'path'
----
CREATE MATERIALIZED SOURCE foo FROM FILE 'bar' FORMAT PROTOBUF MESSAGE 'somemessage' USING SCHEMA FILE 'path'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Protobuf { message_name: "somemessage", schema: File("path") }), envelope: None, if_not_exists: false, materialized: true })

parse-statement
CREATE SOURCE IF NOT EXISTS foo FROM FILE 'bar' WITH (tail = true) FORMAT REGEX '(asdf)|(jkl)'
----
CREATE SOURCE IF NOT EXISTS foo FROM FILE 'bar' WITH (tail = true) FORMAT REGEX '(asdf)|(jkl)'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [Value { name: Ident("tail"), value: Boolean(true) }], format: Some(Regex("(asdf)|(jkl)")), envelope: None, if_not_exists: true, materialized: false })

parse-statement
CREATE SOURCE IF NOT EXISTS foo (one, two) FROM FILE 'bar' WITH (tail = true) FORMAT REGEX '(asdf)|(jkl)'
----
CREATE SOURCE IF NOT EXISTS foo (one, two) FROM FILE 'bar' WITH (tail = true) FORMAT REGEX '(asdf)|(jkl)'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [Ident("one"), Ident("two")], connector: File { path: "bar", compression: None }, with_options: [Value { name: Ident("tail"), value: Boolean(true) }], format: Some(Regex("(asdf)|(jkl)")), envelope: None, if_not_exists: true, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' WITH (tail = false) FORMAT CSV WITH HEADER
----
CREATE SOURCE foo FROM FILE 'bar' WITH (tail = false) FORMAT CSV WITH HEADER
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [Value { name: Ident("tail"), value: Boolean(false) }], format: Some(Csv { header_row: true, n_cols: None, delimiter: ',' }), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' WITH (tail = false) FORMAT CSV WITH 3 COLUMNS
----
CREATE SOURCE foo FROM FILE 'bar' WITH (tail = false) FORMAT CSV WITH 3 COLUMNS
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [Value { name: Ident("tail"), value: Boolean(false) }], format: Some(Csv { header_row: false, n_cols: Some(3), delimiter: ',' }), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo (one, two) FROM FILE 'bar' FORMAT CSV WITH HEADER
----
CREATE SOURCE foo (one, two) FROM FILE 'bar' FORMAT CSV WITH HEADER
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [Ident("one"), Ident("two")], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Csv { header_row: true, n_cols: None, delimiter: ',' }), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' WITH (tail = true) FORMAT CSV WITH 3 COLUMNS DELIMITED BY '|'
----
CREATE SOURCE foo FROM FILE 'bar' WITH (tail = true) FORMAT CSV WITH 3 COLUMNS DELIMITED BY '|'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [Value { name: Ident("tail"), value: Boolean(true) }], format: Some(Csv { header_row: false, n_cols: Some(3), delimiter: '|' }), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE MATERIALIZED OR VIEW foo as SELECT * from bar
----
error: Expected VIEW or SOURCE after CREATE MATERIALIZED, found OR
CREATE MATERIALIZED OR VIEW foo as SELECT * from bar
                    ^

parse-statement
CREATE SOURCE foo FROM AVRO OCF '/tmp/bar'
----
CREATE SOURCE foo FROM AVRO OCF '/tmp/bar'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: AvroOcf { path: "/tmp/bar" }, with_options: [], format: None, envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' ENVELOPE DEBEZIUM
----
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: None, with_options: [] })), envelope: Debezium(Plain), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' SEED VALUE SCHEMA 'blah'
----
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' SEED VALUE SCHEMA 'blah'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: Some(CsrSeed { key_schema: None, value_schema: "blah" }), with_options: [] })), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' SEED KEY SCHEMA 'a' VALUE SCHEMA 'b'
----
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' SEED KEY SCHEMA 'a' VALUE SCHEMA 'b'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: Some(CsrSeed { key_schema: Some("a"), value_schema: "b" }), with_options: [] })), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' WITH (a = 'b') ENVELOPE DEBEZIUM
----
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' WITH (a = 'b') ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: None, with_options: [Value { name: Ident("a"), value: String("b") }] })), envelope: Debezium(Plain), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081'
----
CREATE SOURCE foo FROM FILE 'bar' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: None, with_options: [] })), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' ENVELOPE UPSERT
----
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' ENVELOPE UPSERT
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("crobat")]), col_names: [], connector: Kafka { broker: "zubat", topic: "hoothoot", key: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: None, with_options: [] })), envelope: Upsert(None), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING SCHEMA 'string' ENVELOPE UPSERT FORMAT AVRO USING SCHEMA 'long'
----
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING SCHEMA 'string' ENVELOPE UPSERT FORMAT AVRO USING SCHEMA 'long'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("crobat")]), col_names: [], connector: Kafka { broker: "zubat", topic: "hoothoot", key: None }, with_options: [], format: Some(Avro(Schema { schema: Inline("string"), with_options: [] })), envelope: Upsert(Some(Avro(Schema { schema: Inline("long"), with_options: [] }))), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING SCHEMA 'string' WITH (confluent_wire_format = false) ENVELOPE NONE
----
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING SCHEMA 'string' WITH (confluent_wire_format = false)
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("crobat")]), col_names: [], connector: Kafka { broker: "zubat", topic: "hoothoot", key: None }, with_options: [], format: Some(Avro(Schema { schema: Inline("string"), with_options: [WithOption { key: Ident("confluent_wire_format"), value: Some(Value(Boolean(false))) }] })), envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
----
CREATE SOURCE crobat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("crobat")]), col_names: [], connector: Kafka { broker: "zubat", topic: "hoothoot", key: None }, with_options: [], format: Some(Avro(Schema { schema: File("path"), with_options: [] })), envelope: Upsert(Some(Text)), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset=2) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
----
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset = 2) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("source")]), col_names: [], connector: Kafka { broker: "broker", topic: "topic", key: None }, with_options: [Value { name: Ident("start_offset"), value: Number("2") }], format: Some(Avro(Schema { schema: File("path"), with_options: [] })), envelope: Upsert(Some(Text)), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset=[]) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
----
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset = []) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("source")]), col_names: [], connector: Kafka { broker: "broker", topic: "topic", key: None }, with_options: [Value { name: Ident("start_offset"), value: Array([]) }], format: Some(Avro(Schema { schema: File("path"), with_options: [] })), envelope: Upsert(Some(Text)), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset=[2]) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
----
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset = [2]) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("source")]), col_names: [], connector: Kafka { broker: "broker", topic: "topic", key: None }, with_options: [Value { name: Ident("start_offset"), value: Array([Number("2")]) }], format: Some(Avro(Schema { schema: File("path"), with_options: [] })), envelope: Upsert(Some(Text)), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset=[2, 40000000]) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
----
CREATE SOURCE source FROM KAFKA BROKER 'broker' TOPIC 'topic' WITH (start_offset = [2, 40000000]) FORMAT AVRO USING SCHEMA FILE 'path' ENVELOPE UPSERT FORMAT TEXT
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("source")]), col_names: [], connector: Kafka { broker: "broker", topic: "topic", key: None }, with_options: [Value { name: Ident("start_offset"), value: Array([Number("2"), Number("40000000")]) }], format: Some(Avro(Schema { schema: File("path"), with_options: [] })), envelope: Upsert(Some(Text)), if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE psychic FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLE 'psychic' (pokedex_id int NOT NULL, evolution int);
----
CREATE SOURCE psychic FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLE 'psychic' (pokedex_id int4 NOT NULL, evolution int4)
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("psychic")]), col_names: [], connector: Postgres { conn: "host=kanto user=ash password=teamrocket dbname=pokemon", publication: "red", namespace: "generation1", table: "psychic", columns: [ColumnDef { name: Ident("pokedex_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("evolution"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }] }, with_options: [], format: None, envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE psychic FROM PUBNUB SUBSCRIBE KEY 'subscribe_key' CHANNEL 'channel';
----
CREATE SOURCE psychic FROM PUBNUB SUBSCRIBE KEY 'subscribe_key' CHANNEL 'channel'
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("psychic")]), col_names: [], connector: PubNub { subscribe_key: "subscribe_key", channel: "channel" }, with_options: [], format: None, envelope: None, if_not_exists: false, materialized: false })

parse-statement
CREATE SOURCE IF NOT EXISTS foo FROM FILE 'bar' FORMAT BYTES
----
CREATE SOURCE IF NOT EXISTS foo FROM FILE 'bar' FORMAT BYTES
=>
CreateSource(CreateSourceStatement { name: UnresolvedObjectName([Ident("foo")]), col_names: [], connector: File { path: "bar", compression: None }, with_options: [], format: Some(Bytes), envelope: None, if_not_exists: true, materialized: false })

parse-statement
CREATE SOURCE IF EXISTS foo FROM FILE 'bar' USING SCHEMA ''
----
error: Expected NOT, found EXISTS
CREATE SOURCE IF EXISTS foo FROM FILE 'bar' USING SCHEMA ''
                 ^

parse-statement
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ();
----
error: Expected literal string, found right parenthesis
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ();
                                                                                                                                             ^

parse-statement
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES (SELECT 1);
----
error: Expected literal string, found SELECT
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES (SELECT 1);
                                                                                                                                             ^

parse-statement
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ("public.psychic" (pokedex_id int NOT NULL, evolution int))
----
error: Expected literal string, found identifier 'public.psychic'
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ("public.psychic" (pokedex_id int NOT NULL, evolution int))
                                                                                                                                             ^

parse-statement
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ('psychic' as "public.psychic" (pokedex_id int NOT NULL, evolution int))
----
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ('psychic' AS "public.psychic" (pokedex_id int4 NOT NULL, evolution int4))
=>
CreateSources(CreateSourcesStatement { connector: Postgres { conn: "host=kanto user=ash password=teamrocket dbname=pokemon", publication: "red", namespace: "generation1", tables: [PgTable { name: "psychic", alias: Name(UnresolvedObjectName([Ident("public.psychic")])), columns: [ColumnDef { name: Ident("pokedex_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("evolution"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }] }] }, stmts: [] })

parse-statement
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ('random.psychic' as "public.psychic" (pokedex_id int NOT NULL, evolution int), 'another_table' as "another_one")
----
CREATE SOURCES FROM POSTGRES HOST 'host=kanto user=ash password=teamrocket dbname=pokemon' PUBLICATION 'red' NAMESPACE 'generation1' TABLES ('random.psychic' AS "public.psychic" (pokedex_id int4 NOT NULL, evolution int4), 'another_table' AS another_one)
=>
CreateSources(CreateSourcesStatement { connector: Postgres { conn: "host=kanto user=ash password=teamrocket dbname=pokemon", publication: "red", namespace: "generation1", tables: [PgTable { name: "random.psychic", alias: Name(UnresolvedObjectName([Ident("public.psychic")])), columns: [ColumnDef { name: Ident("pokedex_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("evolution"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }] }, PgTable { name: "another_table", alias: Name(UnresolvedObjectName([Ident("another_one")])), columns: [] }] }, stmts: [] })

parse-statement
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES
----
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Bytes), envelope: None, with_snapshot: true, as_of: None, if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO FILE 'baz' WITH SNAPSHOT FORMAT BYTES
----
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Bytes), envelope: None, with_snapshot: true, as_of: None, if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA BROKER 'baz' TOPIC 'topic' WITH (replication_factor = 7) FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA BROKER 'baz' TOPIC 'topic' WITH (replication_factor = 7) FORMAT BYTES WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: Kafka { broker: "baz", topic: "topic", key: None }, with_options: [Value { name: Ident("replication_factor"), value: Number("7") }], format: Some(Bytes), envelope: None, with_snapshot: true, as_of: None, if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA BROKER 'baz' TOPIC 'topic' KEY (a, b) FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA BROKER 'baz' TOPIC 'topic' KEY (a, b) FORMAT BYTES WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: Kafka { broker: "baz", topic: "topic", key: Some([Ident("a"), Ident("b")]) }, with_options: [], format: Some(Bytes), envelope: None, with_snapshot: true, as_of: None, if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA BROKER 'baz' TOPIC 'topic' KEY FORMAT BYTES
----
error: Expected a list of columns in parentheses, found FORMAT
CREATE SINK foo FROM bar INTO KAFKA BROKER 'baz' TOPIC 'topic' KEY FORMAT BYTES
                                                                   ^

parse-statement
CREATE SINK foo FROM bar INTO AVRO OCF 'baz'
----
CREATE SINK foo FROM bar INTO AVRO OCF 'baz' WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: AvroOcf { path: "baz" }, with_options: [], format: None, envelope: None, with_snapshot: true, as_of: None, if_not_exists: false })

parse-statement
CREATE SINK IF NOT EXISTS foo FROM bar INTO FILE 'baz' FORMAT BYTES
----
CREATE SINK IF NOT EXISTS foo FROM bar INTO FILE 'baz' FORMAT BYTES WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Bytes), envelope: None, with_snapshot: true, as_of: None, if_not_exists: true })

parse-statement
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES AS OF 123
----
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES WITH SNAPSHOT AS OF 123
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Bytes), envelope: None, with_snapshot: true, as_of: Some(Value(Number("123"))), if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES WITHOUT SNAPSHOT AS OF 123
----
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES WITHOUT SNAPSHOT AS OF 123
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Bytes), envelope: None, with_snapshot: false, as_of: Some(Value(Number("123"))), if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES AS OF now()
----
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT BYTES WITH SNAPSHOT AS OF now()
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Bytes), envelope: None, with_snapshot: true, as_of: Some(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args([]), filter: None, over: None, distinct: false })), if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' WITH SNAPSHOT
----
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: None, with_options: [] })), envelope: None, with_snapshot: true, as_of: None, if_not_exists: false })

parse-statement
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' WITH (a = 'b') WITH SNAPSHOT
----
CREATE SINK foo FROM bar INTO FILE 'baz' FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY 'http://localhost:8081' WITH (a = 'b') WITH SNAPSHOT
=>
CreateSink(CreateSinkStatement { name: UnresolvedObjectName([Ident("foo")]), from: UnresolvedObjectName([Ident("bar")]), connector: File { path: "baz", compression: None }, with_options: [], format: Some(Avro(CsrUrl { url: "http://localhost:8081", seed: None, with_options: [Value { name: Ident("a"), value: String("b") }] })), envelope: None, with_snapshot: true, as_of: None, if_not_exists: false })

parse-statement
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
----
error: Expected NOT, found EXISTS
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
               ^

parse-statement
CREATE INDEX foo ON myschema.bar (a, b)
----
CREATE INDEX foo ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), on_name: UnresolvedObjectName([Ident("myschema"), Ident("bar")]), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo ON myschema.bar (a, b) WITH (baz = 'raz')
----
CREATE INDEX foo ON myschema.bar (a, b) WITH (baz = 'raz')
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), on_name: UnresolvedObjectName([Ident("myschema"), Ident("bar")]), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [WithOption { key: Ident("baz"), value: Some(Value(String("raz"))) }], if_not_exists: false })

parse-statement
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
----
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("fizz")), on_name: UnresolvedObjectName([Ident("baz")]), key_parts: Some([Function(Function { name: UnresolvedObjectName([Ident("ascii")]), args: Args([Identifier([Ident("x")])]), filter: None, over: None, distinct: false }), IsNull { expr: Identifier([Ident("a")]), negated: true }, Nested(Exists(Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("y")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedObjectName([Ident("boop")])), alias: None }, joins: [] }], selection: Some(Op { op: "=", expr1: Identifier([Ident("boop"), Ident("z")]), expr2: Some(Identifier([Ident("z")])) }), group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None })), Identifier([Ident("delta")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX ind ON tab ((col + 1))
----
CREATE INDEX ind ON tab ((col + 1))
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("ind")), on_name: UnresolvedObjectName([Ident("tab")]), key_parts: Some([Nested(Op { op: "+", expr1: Identifier([Ident("col")]), expr2: Some(Value(Number("1"))) })]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
----
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("qualifiers")), on_name: UnresolvedObjectName([Ident("no_parentheses")]), key_parts: Some([Identifier([Ident("alpha"), Ident("omega")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX ON tab
----
CREATE DEFAULT INDEX ON tab
=>
CreateIndex(CreateIndexStatement { name: None, on_name: UnresolvedObjectName([Ident("tab")]), key_parts: None, with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
----
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
=>
CreateIndex(CreateIndexStatement { name: None, on_name: UnresolvedObjectName([Ident("tab")]), key_parts: None, with_options: [], if_not_exists: true })

parse-statement
CREATE DEFAULT INDEX ON tab (a, b)
----
error: Expected end of statement, found left parenthesis
CREATE DEFAULT INDEX ON tab (a, b)
                            ^

parse-statement
CREATE INDEX ON tab;
----
error: Expected left parenthesis, found semicolon
CREATE INDEX ON tab;
                   ^

parse-statement
CREATE INDEX ON tab (a, b)
----
CREATE INDEX ON tab (a, b)
=>
CreateIndex(CreateIndexStatement { name: None, on_name: UnresolvedObjectName([Ident("tab")]), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX IF NOT EXISTS ON tab (a, b)
----
error: Expected index name, found ON
CREATE INDEX IF NOT EXISTS ON tab (a, b)
                           ^

parse-statement
CREATE INDEX myschema.ind ON foo(b)
----
error: Expected ON, found dot
CREATE INDEX myschema.ind ON foo(b)
                     ^

parse-statement
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
----
error: Expected NOT, found EXISTS
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
                ^

parse-statement
DROP DATABASE mydb
----
DROP DATABASE mydb
=>
DropDatabase(DropDatabaseStatement { name: Ident("mydb"), if_exists: false })

parse-statement
DROP DATABASE IF EXISTS mydb
----
DROP DATABASE IF EXISTS mydb
=>
DropDatabase(DropDatabaseStatement { name: Ident("mydb"), if_exists: true })

parse-statement
DROP DATABASE mydb.nope
----
error: Expected end of statement, found dot
DROP DATABASE mydb.nope
                  ^

parse-statement
DROP SCHEMA mydb.myschema
----
DROP SCHEMA mydb.myschema
=>
DropObjects(DropObjectsStatement { object_type: Schema, if_exists: false, names: [UnresolvedObjectName([Ident("mydb"), Ident("myschema")])], cascade: false })

parse-statement
DROP TABLE foo
----
DROP TABLE foo
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: false, names: [UnresolvedObjectName([Ident("foo")])], cascade: false })

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE
----
DROP TABLE IF EXISTS foo, bar CASCADE
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: true, names: [UnresolvedObjectName([Ident("foo")]), UnresolvedObjectName([Ident("bar")])], cascade: true })

parse-statement
DROP TABLE
----
error: Expected identifier, found EOF
DROP TABLE
          ^

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
----
error: Cannot specify both CASCADE and RESTRICT in DROP
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
                                      ^

parse-statement
DROP VIEW myschema.myview
----
DROP VIEW myschema.myview
=>
DropObjects(DropObjectsStatement { object_type: View, if_exists: false, names: [UnresolvedObjectName([Ident("myschema"), Ident("myview")])], cascade: false })

parse-statement
DROP SOURCE myschema.mydatasource
----
DROP SOURCE myschema.mydatasource
=>
DropObjects(DropObjectsStatement { object_type: Source, if_exists: false, names: [UnresolvedObjectName([Ident("myschema"), Ident("mydatasource")])], cascade: false })

parse-statement
DROP INDEX IF EXISTS myschema.myindex
----
DROP INDEX IF EXISTS myschema.myindex
=>
DropObjects(DropObjectsStatement { object_type: Index, if_exists: true, names: [UnresolvedObjectName([Ident("myschema"), Ident("myindex")])], cascade: false })

parse-statement
TAIL foo.bar
----
TAIL foo.bar
=>
Tail(TailStatement { name: UnresolvedObjectName([Ident("foo"), Ident("bar")]), options: [], as_of: None })

parse-statement
TAIL foo.bar AS OF 123
----
TAIL foo.bar AS OF 123
=>
Tail(TailStatement { name: UnresolvedObjectName([Ident("foo"), Ident("bar")]), options: [], as_of: Some(Value(Number("123"))) })

parse-statement
TAIL foo.bar AS OF now()
----
TAIL foo.bar AS OF now()
=>
Tail(TailStatement { name: UnresolvedObjectName([Ident("foo"), Ident("bar")]), options: [], as_of: Some(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args([]), filter: None, over: None, distinct: false })) })

parse-statement
TAIL foo.bar WITH (SNAPSHOT) AS OF now()
----
TAIL foo.bar WITH (snapshot) AS OF now()
=>
Tail(TailStatement { name: UnresolvedObjectName([Ident("foo"), Ident("bar")]), options: [WithOption { key: Ident("snapshot"), value: None }], as_of: Some(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args([]), filter: None, over: None, distinct: false })) })

parse-statement
TAIL foo.bar WITH (SNAPSHOT = false, TIMESTAMPS) AS OF now()
----
TAIL foo.bar WITH (snapshot = false, timestamps) AS OF now()
=>
Tail(TailStatement { name: UnresolvedObjectName([Ident("foo"), Ident("bar")]), options: [WithOption { key: Ident("snapshot"), value: Some(Value(Boolean(false))) }, WithOption { key: Ident("timestamps"), value: None }], as_of: Some(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args([]), filter: None, over: None, distinct: false })) })

parse-statement
TAIL foo.bar WITH (SNAPSHOT false)
----
error: Expected equals sign, found FALSE
TAIL foo.bar WITH (SNAPSHOT false)
                            ^

parse-statement
CREATE TABLE public.customer (
        customer_id integer DEFAULT nextval(public.customer_customer_id_seq),
        store_id smallint NOT NULL,
        first_name character varying(45) NOT NULL,
        last_name character varying(45) COLLATE "es_ES" NOT NULL,
        email character varying(50),
        address_id smallint NOT NULL,
        activebool boolean DEFAULT true NOT NULL,
        create_date date DEFAULT now()::text NOT NULL,
        last_update timestamp without time zone DEFAULT now() NOT NULL,
        last_update_tz timestamp with time zone,
        active integer NOT NULL
) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
----
CREATE TABLE public.customer (customer_id int4 DEFAULT nextval(public.customer_customer_id_seq), store_id int2 NOT NULL, first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL, email varchar(50), address_id int2 NOT NULL, activebool bool DEFAULT true NOT NULL, create_date date DEFAULT now()::text NOT NULL, last_update timestamp DEFAULT now() NOT NULL, last_update_tz timestamptz, active int4 NOT NULL) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
=>
CreateTable(CreateTableStatement { name: UnresolvedObjectName([Ident("public"), Ident("customer")]), columns: [ColumnDef { name: Ident("customer_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Function(Function { name: UnresolvedObjectName([Ident("nextval")]), args: Args([Identifier([Ident("public"), Ident("customer_customer_id_seq")])]), filter: None, over: None, distinct: false })) }] }, ColumnDef { name: Ident("store_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int2")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("first_name"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [45] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("last_name"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [45] }, collation: Some(UnresolvedObjectName([Ident("es_ES")])), options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("email"), data_type: Other { name: Name(UnresolvedObjectName([Ident("varchar")])), typ_mod: [50] }, collation: None, options: [] }, ColumnDef { name: Ident("address_id"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int2")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("activebool"), data_type: Other { name: Name(UnresolvedObjectName([Ident("bool")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Value(Boolean(true))) }, ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("create_date"), data_type: Other { name: Name(UnresolvedObjectName([Ident("date")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Cast { expr: Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args([]), filter: None, over: None, distinct: false }), data_type: Other { name: Name(UnresolvedObjectName([Ident("text")])), typ_mod: [] } }) }, ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("last_update"), data_type: Other { name: Name(UnresolvedObjectName([Ident("timestamp")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Default(Function(Function { name: UnresolvedObjectName([Ident("now")]), args: Args([]), filter: None, over: None, distinct: false })) }, ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("last_update_tz"), data_type: Other { name: Name(UnresolvedObjectName([Ident("timestamptz")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("active"), data_type: Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }], constraints: [], with_options: [Value { name: Ident("fillfactor"), value: Number("20") }, Value { name: Ident("user_catalog_table"), value: Boolean(true) }, Value { name: Ident("autovacuum_vacuum_threshold"), value: Number("100") }], if_not_exists: false, temporary: false })

parse-statement roundtrip
CREATE TABLE public.customer (
    customer_id int DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
    store_id smallint NOT NULL,
    first_name character varying(45) NOT NULL,
    last_name character varying(45) NOT NULL,
    info text,
    address_id smallint NOT NULL,
    activebool boolean DEFAULT true NOT NULL,
    create_date date DEFAULT now()::date NOT NULL,
    create_date1 date DEFAULT 'now'::text::date NOT NULL,
    last_update timestamp DEFAULT now(),
    active int
)
----
CREATE TABLE public.customer (customer_id int4 DEFAULT nextval('public.customer_customer_id_seq'::oid) NOT NULL, store_id int2 NOT NULL, first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL, info text, address_id int2 NOT NULL, activebool bool DEFAULT true NOT NULL, create_date date DEFAULT now()::date NOT NULL, create_date1 date DEFAULT 'now'::text::date NOT NULL, last_update timestamp DEFAULT now(), active int4)

parse-statement roundtrip
CREATE TABLE bazaar.settings (
  settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL,
  user_id uuid UNIQUE,
  value text,
  use_metric boolean DEFAULT true
)
----
CREATE TABLE bazaar.settings (settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL, user_id uuid UNIQUE, value text, use_metric bool DEFAULT true)

parse-statement roundtrip
CREATE TABLE IF NOT EXISTS foo (bar int)
----
CREATE TABLE IF NOT EXISTS foo (bar int4)

parse-statement
ALTER INDEX name SET (property = true)
----
ALTER INDEX name SET (property = true)
=>
AlterIndexOptions(AlterIndexOptionsStatement { index_name: UnresolvedObjectName([Ident("name")]), if_exists: false, options: Set([WithOption { key: Ident("property"), value: Some(Value(Boolean(true))) }]) })

parse-statement
ALTER INDEX name RESET (property)
----
ALTER INDEX name RESET (property)
=>
AlterIndexOptions(AlterIndexOptionsStatement { index_name: UnresolvedObjectName([Ident("name")]), if_exists: false, options: Reset([Ident("property")]) })

parse-statement
ALTER INDEX IF EXISTS name SET (property = true)
----
ALTER INDEX IF EXISTS name SET (property = true)
=>
AlterIndexOptions(AlterIndexOptionsStatement { index_name: UnresolvedObjectName([Ident("name")]), if_exists: true, options: Set([WithOption { key: Ident("property"), value: Some(Value(Boolean(true))) }]) })

parse-statement
ALTER INDEX name SET ()
----
error: Expected identifier, found right parenthesis
ALTER INDEX name SET ()
                      ^

parse-statement
ALTER INDEX name RESET ()
----
error: Expected identifier, found right parenthesis
ALTER INDEX name RESET ()
                        ^

parse-statement
ALTER INDEX name SET (property)
----
ALTER INDEX name SET (property)
=>
AlterIndexOptions(AlterIndexOptionsStatement { index_name: UnresolvedObjectName([Ident("name")]), if_exists: false, options: Set([WithOption { key: Ident("property"), value: None }]) })

parse-statement
ALTER INDEX name RESET (property = true)
----
error: Expected right parenthesis, found equals sign
ALTER INDEX name RESET (property = true)
                                 ^

parse-statement
ALTER SOURCE name SET (property = true)
----
error: Expected RENAME, found SET
ALTER SOURCE name SET (property = true)
                  ^

parse-statement
ALTER VIEW name SET (property = true)
----
error: Expected RENAME, found SET
ALTER VIEW name SET (property = true)
                ^

parse-statement
ALTER SINK name SET (property = true)
----
error: Expected RENAME, found SET
ALTER SINK name SET (property = true)
                ^

parse-statement
ALTER INDEX name RENAME TO name2
----
ALTER INDEX name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Index, if_exists: false, name: UnresolvedObjectName([Ident("name")]), to_item_name: Ident("name2") })
