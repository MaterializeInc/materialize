# Copyright 2020 sqlparser-rs contributors. All rights reserved.
# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# This file is derived from the sqlparser-rs project, available at
# https://github.com/andygrove/sqlparser-rs. It was incorporated
# directly into Materialize on December 21, 2019.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the LICENSE file at the
# root of this repository, or online at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

parse-statement
CREATE TABLE uk_cities (
    name VARCHAR(100) NOT NULL,
    lat DOUBLE NULL,
    lng DOUBLE,
    constrained INT NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0),
    ref INT REFERENCES othertable (a, b)
)
----
CREATE TABLE uk_cities (name varchar(100) NOT NULL, lat float8 NULL, lng float8, constrained int4 NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0), ref int4 REFERENCES othertable (a, b))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("uk_cities")]), columns: [ColumnDef { name: Ident("name"), data_type: Other { name: Name(UnresolvedItemName([Ident("varchar")])), typ_mod: [100] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("lat"), data_type: Other { name: Name(UnresolvedItemName([Ident("float8")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }] }, ColumnDef { name: Ident("lng"), data_type: Other { name: Name(UnresolvedItemName([Ident("float8")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("constrained"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }, ColumnOptionDef { name: Some(Ident("pkey")), option: Unique { is_primary: true } }, ColumnOptionDef { name: None, option: NotNull }, ColumnOptionDef { name: None, option: Unique { is_primary: false } }, ColumnOptionDef { name: None, option: Check(Op { op: Op { namespace: None, op: ">" }, expr1: Identifier([Ident("constrained")]), expr2: Some(Value(Number("0"))) }) }] }, ColumnDef { name: Ident("ref"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: ForeignKey { foreign_table: UnresolvedItemName([Ident("othertable")]), referred_columns: [Ident("a"), Ident("b")] } }] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE t (a int NOT NULL GARBAGE)
----
error: Expected column option, found identifier "garbage"
CREATE TABLE t (a int NOT NULL GARBAGE)
                               ^

parse-statement
CREATE TABLE t (c int) WITH (foo = 'bar', a = 123)
----
error: Expected RETAIN, found identifier "foo"
CREATE TABLE t (c int) WITH (foo = 'bar', a = 123)
                             ^

parse-statement
CREATE TABLE types_table (char_col char, bpchar_col bpchar, text_col text, bool_col boolean, date_col date, time_col time, timestamp_col timestamp, uuid_col uuid, double_col double precision);
----
CREATE TABLE types_table (char_col bpchar, bpchar_col bpchar, text_col text, bool_col bool, date_col date, time_col time, timestamp_col timestamp, uuid_col uuid, double_col float8)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("types_table")]), columns: [ColumnDef { name: Ident("char_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("bpchar")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("bpchar_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("bpchar")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("text_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("text")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("bool_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("bool")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("date_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("date")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("time_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("time")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("timestamp_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("timestamp")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("uuid_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("uuid")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("double_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("float8")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE t
----
error: Expected a list of columns in parentheses, found EOF
CREATE TABLE t
              ^

parse-statement
CREATE TABLE t ()
----
CREATE TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TEMP TABLE t ()
----
CREATE TEMPORARY TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [], constraints: [], if_not_exists: false, temporary: true, with_options: [] })

parse-statement
CREATE TABLE foo (bar int,)
----
error: Expected column name or constraint definition, found right parenthesis
CREATE TABLE foo (bar int,)
                          ^

parse-statement
CREATE TABLE foo (bar int list)
----
CREATE TABLE foo (bar int4 list)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }), collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (bar int list list)
----
CREATE TABLE foo (bar int4 list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(List(Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] })), collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE tab (foo int,
----
error: Expected column name or constraint definition, found EOF
CREATE TABLE tab (foo int,
                          ^

parse-statement
CREATE TABLE foo (id int, CONSTRAINT address_pkey PRIMARY KEY (address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT address_pkey PRIMARY KEY (address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("address_pkey")), columns: [Ident("address_id")], is_primary: true, nulls_not_distinct: false }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT uk_task UNIQUE (report_date, task_id))
----
CREATE TABLE foo (id int4, CONSTRAINT uk_task UNIQUE (report_date, task_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("uk_task")), columns: [Ident("report_date"), Ident("task_id")], is_primary: false, nulls_not_distinct: false }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT uk_task UNIQUE NULLS NOT DISTINCT (report_date, task_id))
----
CREATE TABLE foo (id int4, CONSTRAINT uk_task UNIQUE NULLS NOT DISTINCT (report_date, task_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("uk_task")), columns: [Ident("report_date"), Ident("task_id")], is_primary: false, nulls_not_distinct: true }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: Some(Ident("customer_address_id_fkey")), columns: [Ident("address_id")], foreign_table: Name(UnresolvedItemName([Ident("public"), Ident("address")])), referred_columns: [Ident("address_id")] }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TEMPORARY TABLE foo (id int, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
----
CREATE TEMPORARY TABLE foo (id int4, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: Some(Ident("ck")), expr: Op { op: Op { namespace: None, op: "<>" }, expr1: Function(Function { name: Name(UnresolvedItemName([Ident("rtrim")])), args: Args { args: [Function(Function { name: Name(UnresolvedItemName([Ident("ltrim")])), args: Args { args: [Identifier([Ident("ref_code")])], order_by: [] }, filter: None, over: None, distinct: false })], order_by: [] }, filter: None, over: None, distinct: false }), expr2: Some(Value(String(""))) } }], if_not_exists: false, temporary: true, with_options: [] })

parse-statement
CREATE TABLE foo (id int, PRIMARY KEY (foo, bar))
----
CREATE TABLE foo (id int4, PRIMARY KEY (foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("foo"), Ident("bar")], is_primary: true, nulls_not_distinct: false }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, UNIQUE (id))
----
CREATE TABLE foo (id int4, UNIQUE (id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("id")], is_primary: false, nulls_not_distinct: false }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
----
CREATE TABLE foo (id int4, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: None, columns: [Ident("foo"), Ident("bar")], foreign_table: Name(UnresolvedItemName([Ident("anothertable")])), referred_columns: [Ident("foo"), Ident("bar")] }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, CHECK (end_date > start_date OR end_date IS NULL))
----
CREATE TABLE foo (id int4, CHECK (end_date > start_date OR end_date IS NULL))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: Or { left: Op { op: Op { namespace: None, op: ">" }, expr1: Identifier([Ident("end_date")]), expr2: Some(Identifier([Ident("start_date")])) }, right: IsExpr { expr: Identifier([Ident("end_date")]), construct: Null, negated: false } } }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, CHECK (end_date > start_date OR end_date IS UNKNOWN))
----
CREATE TABLE foo (id int4, CHECK (end_date > start_date OR end_date IS UNKNOWN))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: Or { left: Op { op: Op { namespace: None, op: ">" }, expr1: Identifier([Ident("end_date")]), expr2: Some(Identifier([Ident("start_date")])) }, right: IsExpr { expr: Identifier([Ident("end_date")]), construct: Unknown, negated: false } } }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE foo (id int, CHECK (start_date IS TRUE))
----
CREATE TABLE foo (id int4, CHECK (start_date IS TRUE))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: IsExpr { expr: Identifier([Ident("start_date")]), construct: True, negated: false } }], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TEMP TABLE t (c schema.type)
----
CREATE TEMPORARY TABLE t (c schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: true, with_options: [] })

parse-statement
CREATE TABLE t (c db.schema.type)
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE t (c "db"."schema"."type")
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE t (c something.db.schema.type)
----
CREATE TABLE t (c something.db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("something"), Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TEMP TABLE t (c db.schema.type(0,1,100))
----
CREATE TEMPORARY TABLE t (c db.schema.type(0, 1, 100))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [0, 1, 100] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: true, with_options: [] })

parse-statement
CREATE TABLE t (c time with time zone (0,1,100))
----
error: Expected column option, found left parenthesis
CREATE TABLE t (c time with time zone (0,1,100))
                                      ^

parse-statement
CREATE TABLE t (c t(1+1))
----
error: Expected right parenthesis, found operator "+"
CREATE TABLE t (c t(1+1))
                     ^

parse-statement
CREATE TABLE t (c t(1,))
----
error: Expected literal integer, found right parenthesis
CREATE TABLE t (c t(1,))
                      ^

parse-statement
CREATE TABLE t (c "type"(1))
----
CREATE TABLE t (c type(1))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("type")])), typ_mod: [1] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE TABLE t (c "type"(1) list list)
----
CREATE TABLE t (c type(1) list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: List(List(Other { name: Name(UnresolvedItemName([Ident("type")])), typ_mod: [1] })), collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false, with_options: [] })

parse-statement
CREATE DATABASE IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE DATABASE IF EXISTS foo
                   ^

parse-statement
CREATE DATABASE foo.bar
----
error: Expected end of statement, found dot
CREATE DATABASE foo.bar
                   ^

parse-statement
CREATE SCHEMA foo.bar
----
CREATE SCHEMA foo.bar
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedSchemaName([Ident("foo"), Ident("bar")]), if_not_exists: false })

parse-statement
CREATE SCHEMA IF NOT EXISTS foo
----
CREATE SCHEMA IF NOT EXISTS foo
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedSchemaName([Ident("foo")]), if_not_exists: true })

parse-statement
CREATE SCHEMA IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE SCHEMA IF EXISTS foo
                 ^

parse-statement
CREATE VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("myschema"), Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: true, definition: ViewDefinition { name: UnresolvedItemName([Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE TEMP VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: true, definition: ViewDefinition { name: UnresolvedItemName([Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE OR REPLACE VIEW v AS SELECT 1
----
CREATE OR REPLACE VIEW v AS SELECT 1
=>
CreateView(CreateViewStatement { if_exists: Replace, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("v")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE VIEW IF NOT EXISTS v AS SELECT 1
----
CREATE VIEW IF NOT EXISTS v AS SELECT 1
=>
CreateView(CreateViewStatement { if_exists: Skip, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("v")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
----
error: Expected AS, found NOT
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
                          ^

parse-statement
CREATE VIEW v (has, cols) AS SELECT 1, 2
----
CREATE VIEW v (has, cols) AS SELECT 1, 2
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("v")]), columns: [Ident("has"), Ident("cols")], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }, Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
----
CREATE VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Skip, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("myschema"), Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("myschema"), Ident("myview")]), columns: [], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [] })

parse-statement
CREATE OR REPLACE MATERIALIZED VIEW v AS SELECT 1
----
CREATE OR REPLACE MATERIALIZED VIEW v AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Replace, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [] })

parse-statement
CREATE MATERIALIZED VIEW IF NOT EXISTS v AS SELECT 1
----
CREATE MATERIALIZED VIEW IF NOT EXISTS v AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Skip, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [] })

parse-statement
CREATE MATERIALIZED VIEW v (has, cols) AS SELECT 1, 2
----
CREATE MATERIALIZED VIEW v (has, cols) AS SELECT 1, 2
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("v")]), columns: [Ident("has"), Ident("cols")], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }, Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [] })

parse-statement
CREATE MATERIALIZED VIEW v IN CLUSTER bar AS SELECT 1
----
CREATE MATERIALIZED VIEW v IN CLUSTER bar AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: Some(Unresolved(Ident("bar"))), query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [] })

parse-statement
CREATE MATERIALIZED VIEW v IN CLUSTER [1] AS SELECT 1
----
CREATE MATERIALIZED VIEW v IN CLUSTER [1] AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: Some(Resolved("1")), query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [] })

parse-statement
CREATE MATERIALIZED VIEW v WITH (REFRESH EVERY '1 day', ASSERT NOT NULL x) AS SELECT * FROM t;
----
CREATE MATERIALIZED VIEW v WITH (REFRESH = EVERY '1 day', ASSERT NOT NULL = x) AS SELECT * FROM t
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("t")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [MaterializedViewOption { name: Refresh, value: Some(Refresh(Every(RefreshEveryOptionValue { interval: IntervalValue { value: "1 day", precision_high: Year, precision_low: Second, fsec_max_precision: None }, aligned_to: None }))) }, MaterializedViewOption { name: AssertNotNull, value: Some(UnresolvedItemName(UnresolvedItemName([Ident("x")]))) }] })

parse-statement
CREATE OR REPLACE MATERIALIZED VIEW v IN CLUSTER [1] WITH (REFRESH EVERY '1 day' ALIGNED TO '2023-12-11 11:00', ASSERT NOT NULL x, REFRESH AT mz_now(), REFRESH ON COMMIT, REFRESH = AT CREATION) AS SELECT * FROM t;
----
CREATE OR REPLACE MATERIALIZED VIEW v IN CLUSTER [1] WITH (REFRESH = EVERY '1 day' ALIGNED TO '2023-12-11 11:00', ASSERT NOT NULL = x, REFRESH = AT mz_now(), REFRESH = ON COMMIT, REFRESH = AT CREATION) AS SELECT * FROM t
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Replace, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: Some(Resolved("1")), query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("t")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }, as_of: None, with_options: [MaterializedViewOption { name: Refresh, value: Some(Refresh(Every(RefreshEveryOptionValue { interval: IntervalValue { value: "1 day", precision_high: Year, precision_low: Second, fsec_max_precision: None }, aligned_to: Some(Value(String("2023-12-11 11:00"))) }))) }, MaterializedViewOption { name: AssertNotNull, value: Some(UnresolvedItemName(UnresolvedItemName([Ident("x")]))) }, MaterializedViewOption { name: Refresh, value: Some(Refresh(At(RefreshAtOptionValue { time: Function(Function { name: Name(UnresolvedItemName([Ident("mz_now")])), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }) }))) }, MaterializedViewOption { name: Refresh, value: Some(Refresh(OnCommit)) }, MaterializedViewOption { name: Refresh, value: Some(Refresh(AtCreation)) }] })

parse-statement roundtrip
CREATE OR REPLACE MATERIALIZED VIEW v WITH (ASSERT NOT NULL a, ASSERT NOT NULL = b, RETAIN HISTORY = FOR '1s') AS SELECT 1
----
CREATE OR REPLACE MATERIALIZED VIEW v WITH (ASSERT NOT NULL = a, ASSERT NOT NULL = b, RETAIN HISTORY = FOR '1s') AS SELECT 1

parse-statement
CREATE CONNECTION awsconn TO AWS (ACCESS KEY ID 'id', ENDPOINT 'endpoint', REGION 'region', SECRET ACCESS KEY 'key', SESSION TOKEN 'token')
----
CREATE CONNECTION awsconn TO AWS (ACCESS KEY ID = 'id', ENDPOINT = 'endpoint', REGION = 'region', SECRET ACCESS KEY = 'key', SESSION TOKEN = 'token')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("awsconn")]), connection_type: Aws, if_not_exists: false, values: [ConnectionOption { name: AccessKeyId, value: Some(Value(String("id"))) }, ConnectionOption { name: Endpoint, value: Some(Value(String("endpoint"))) }, ConnectionOption { name: Region, value: Some(Value(String("region"))) }, ConnectionOption { name: SecretAccessKey, value: Some(Value(String("key"))) }, ConnectionOption { name: SessionToken, value: Some(Value(String("token"))) }], with_options: [] })

parse-statement
CREATE CONNECTION awsconn TO AWS (ASSUME ROLE ARN 'role-arn', ASSUME ROLE SESSION NAME 'session-name')
----
CREATE CONNECTION awsconn TO AWS (ASSUME ROLE ARN = 'role-arn', ASSUME ROLE SESSION NAME = 'session-name')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("awsconn")]), connection_type: Aws, if_not_exists: false, values: [ConnectionOption { name: AssumeRoleArn, value: Some(Value(String("role-arn"))) }, ConnectionOption { name: AssumeRoleSessionName, value: Some(Value(String("session-name"))) }], with_options: [] })

parse-statement
CREATE CONNECTION awsconn TO AWS (ACCESS KEY ID 'id', ENDPOINT 'endpoint', REGION 'region', ASSUME ROLE ARN 'role-arn', SECRET ACCESS KEY 'key', SESSION TOKEN 'token')
----
CREATE CONNECTION awsconn TO AWS (ACCESS KEY ID = 'id', ENDPOINT = 'endpoint', REGION = 'region', ASSUME ROLE ARN = 'role-arn', SECRET ACCESS KEY = 'key', SESSION TOKEN = 'token')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("awsconn")]), connection_type: Aws, if_not_exists: false, values: [ConnectionOption { name: AccessKeyId, value: Some(Value(String("id"))) }, ConnectionOption { name: Endpoint, value: Some(Value(String("endpoint"))) }, ConnectionOption { name: Region, value: Some(Value(String("region"))) }, ConnectionOption { name: AssumeRoleArn, value: Some(Value(String("role-arn"))) }, ConnectionOption { name: SecretAccessKey, value: Some(Value(String("key"))) }, ConnectionOption { name: SessionToken, value: Some(Value(String("token"))) }], with_options: [] })

parse-statement
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES ('use1-az1', 'use1-az4'))
----
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME = 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES = ('use1-az1', 'use1-az4'))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("privatelinkconn")]), connection_type: AwsPrivatelink, if_not_exists: false, values: [ConnectionOption { name: ServiceName, value: Some(Value(String("com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc"))) }, ConnectionOption { name: AvailabilityZones, value: Some(Sequence([Value(String("use1-az1")), Value(String("use1-az4"))])) }], with_options: [] })

parse-statement
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES ('use1-az1', 'use1-az4')) WITH (VALIDATE = FALSE)
----
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME = 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES = ('use1-az1', 'use1-az4')) WITH (VALIDATE = false)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("privatelinkconn")]), connection_type: AwsPrivatelink, if_not_exists: false, values: [ConnectionOption { name: ServiceName, value: Some(Value(String("com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc"))) }, ConnectionOption { name: AvailabilityZones, value: Some(Sequence([Value(String("use1-az1")), Value(String("use1-az4"))])) }], with_options: [CreateConnectionOption { name: Validate, value: Some(Value(Boolean(false))) }] })

parse-statement
CREATE CONNECTION privatelinkconn FOR AWS PRIVATELINK SERVICE NAME 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES ('use1-az1', 'use1-az4')
----
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME = 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES = ('use1-az1', 'use1-az4'))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("privatelinkconn")]), connection_type: AwsPrivatelink, if_not_exists: false, values: [ConnectionOption { name: ServiceName, value: Some(Value(String("com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc"))) }, ConnectionOption { name: AvailabilityZones, value: Some(Sequence([Value(String("use1-az1")), Value(String("use1-az4"))])) }], with_options: [] })

parse-statement
CREATE CONNECTION privatelinkconn FOR AWS PRIVATELINK SERVICE NAME 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES ('use1-az1', 'use1-az4') WITH (VALIDATE = TRUE)
----
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME = 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES = ('use1-az1', 'use1-az4')) WITH (VALIDATE = true)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("privatelinkconn")]), connection_type: AwsPrivatelink, if_not_exists: false, values: [ConnectionOption { name: ServiceName, value: Some(Value(String("com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc"))) }, ConnectionOption { name: AvailabilityZones, value: Some(Sequence([Value(String("use1-az1")), Value(String("use1-az4"))])) }], with_options: [CreateConnectionOption { name: Validate, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE CONNECTION pgconn FOR postgres HOST foo, PORT 1234, SSL CERTIFICATE AUTHORITY 'foo', SSH TUNNEL tun, DATABASE 'db', PASSWORD 'pw', SSL CERTIFICATE 'cert', SSL KEY 'key', SSL MODE 'mode', USER 'postgres'
----
CREATE CONNECTION pgconn TO POSTGRES (HOST = foo, PORT = 1234, SSL CERTIFICATE AUTHORITY = 'foo', SSH TUNNEL = tun, DATABASE = 'db', PASSWORD = 'pw', SSL CERTIFICATE = 'cert', SSL KEY = 'key', SSL MODE = 'mode', USER = 'postgres')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("pgconn")]), connection_type: Postgres, if_not_exists: false, values: [ConnectionOption { name: Host, value: Some(UnresolvedItemName(UnresolvedItemName([Ident("foo")]))) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, ConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("foo"))) }, ConnectionOption { name: SshTunnel, value: Some(Item(Name(UnresolvedItemName([Ident("tun")])))) }, ConnectionOption { name: Database, value: Some(Value(String("db"))) }, ConnectionOption { name: Password, value: Some(Value(String("pw"))) }, ConnectionOption { name: SslCertificate, value: Some(Value(String("cert"))) }, ConnectionOption { name: SslKey, value: Some(Value(String("key"))) }, ConnectionOption { name: SslMode, value: Some(Value(String("mode"))) }, ConnectionOption { name: User, value: Some(Value(String("postgres"))) }], with_options: [] })

parse-statement
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK db.schema.item, PORT 1234)
----
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK = db.schema.item, PORT = 1234)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("pgconn")]), connection_type: Postgres, if_not_exists: false, values: [ConnectionOption { name: AwsPrivatelink, value: Some(ConnectionAwsPrivatelink(ConnectionDefaultAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])), port: None })) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }], with_options: [] })

parse-statement
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK db.schema.item, PORT 1234, HOST foo, SSL CERTIFICATE 'cert', SSL CERTIFICATE AUTHORITY 'auth', SSL KEY 'key')
----
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK = db.schema.item, PORT = 1234, HOST = foo, SSL CERTIFICATE = 'cert', SSL CERTIFICATE AUTHORITY = 'auth', SSL KEY = 'key')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("pgconn")]), connection_type: Postgres, if_not_exists: false, values: [ConnectionOption { name: AwsPrivatelink, value: Some(ConnectionAwsPrivatelink(ConnectionDefaultAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])), port: None })) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, ConnectionOption { name: Host, value: Some(UnresolvedItemName(UnresolvedItemName([Ident("foo")]))) }, ConnectionOption { name: SslCertificate, value: Some(Value(String("cert"))) }, ConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("auth"))) }, ConnectionOption { name: SslKey, value: Some(Value(String("key"))) }], with_options: [] })

parse-statement
CREATE CONNECTION mysqlconn FOR mysql HOST foo, PORT 1234, SSL CERTIFICATE AUTHORITY 'foo', SSH TUNNEL tun, PASSWORD 'pw', SSL CERTIFICATE 'cert', SSL KEY 'key', SSL MODE 'mode', USER 'root'
----
CREATE CONNECTION mysqlconn TO MYSQL (HOST = foo, PORT = 1234, SSL CERTIFICATE AUTHORITY = 'foo', SSH TUNNEL = tun, PASSWORD = 'pw', SSL CERTIFICATE = 'cert', SSL KEY = 'key', SSL MODE = 'mode', USER = 'root')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("mysqlconn")]), connection_type: MySql, if_not_exists: false, values: [ConnectionOption { name: Host, value: Some(UnresolvedItemName(UnresolvedItemName([Ident("foo")]))) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, ConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("foo"))) }, ConnectionOption { name: SshTunnel, value: Some(Item(Name(UnresolvedItemName([Ident("tun")])))) }, ConnectionOption { name: Password, value: Some(Value(String("pw"))) }, ConnectionOption { name: SslCertificate, value: Some(Value(String("cert"))) }, ConnectionOption { name: SslKey, value: Some(Value(String("key"))) }, ConnectionOption { name: SslMode, value: Some(Value(String("mode"))) }, ConnectionOption { name: User, value: Some(Value(String("root"))) }], with_options: [] })

parse-statement
CREATE CONNECTION mysqlconn TO MYSQL (AWS PRIVATELINK db.schema.item, PORT 1234)
----
CREATE CONNECTION mysqlconn TO MYSQL (AWS PRIVATELINK = db.schema.item, PORT = 1234)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("mysqlconn")]), connection_type: MySql, if_not_exists: false, values: [ConnectionOption { name: AwsPrivatelink, value: Some(ConnectionAwsPrivatelink(ConnectionDefaultAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])), port: None })) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }], with_options: [] })

parse-statement
CREATE CONNECTION mysqlconn TO MYSQL (AWS PRIVATELINK db.schema.item, PORT 1234, HOST foo, SSL CERTIFICATE 'cert', SSL CERTIFICATE AUTHORITY 'auth', SSL KEY 'key')
----
CREATE CONNECTION mysqlconn TO MYSQL (AWS PRIVATELINK = db.schema.item, PORT = 1234, HOST = foo, SSL CERTIFICATE = 'cert', SSL CERTIFICATE AUTHORITY = 'auth', SSL KEY = 'key')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("mysqlconn")]), connection_type: MySql, if_not_exists: false, values: [ConnectionOption { name: AwsPrivatelink, value: Some(ConnectionAwsPrivatelink(ConnectionDefaultAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])), port: None })) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, ConnectionOption { name: Host, value: Some(UnresolvedItemName(UnresolvedItemName([Ident("foo")]))) }, ConnectionOption { name: SslCertificate, value: Some(Value(String("cert"))) }, ConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("auth"))) }, ConnectionOption { name: SslKey, value: Some(Value(String("key"))) }], with_options: [] })

parse-statement
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn FOR TABLES (foo, bar as qux, baz into zop);
----
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn FOR TABLES (foo, bar AS qux, baz AS zop)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: MySql { connection: Name(UnresolvedItemName([Ident("mysqlconn")])), options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(SubsetTables([CreateSourceSubsource { reference: UnresolvedItemName([Ident("foo")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("bar")]), subsource: Some(Deferred(UnresolvedItemName([Ident("qux")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("baz")]), subsource: Some(Deferred(UnresolvedItemName([Ident("zop")]))) }])), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn FOR TABLES ([s1 AS foo.bar]);
----
error: Expected identifier, found left square bracket
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn FOR TABLES ([s1 AS foo.bar]);
                                                                    ^

parse-statement
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn (TEXT COLUMNS (public.foo.bar)) FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn (TEXT COLUMNS = (public.foo.bar)) FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: MySql { connection: Name(UnresolvedItemName([Ident("mysqlconn")])), options: [MySqlConfigOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("public"), Ident("foo"), Ident("bar")]))])) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn (IGNORE COLUMNS (public.foo.bar)) FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn (IGNORE COLUMNS = (public.foo.bar)) FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: MySql { connection: Name(UnresolvedItemName([Ident("mysqlconn")])), options: [MySqlConfigOption { name: IgnoreColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("public"), Ident("foo"), Ident("bar")]))])) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn (IGNORE COLUMNS (public.foo.bar), TEXT COLUMNS (public.foo.baz)) FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM MYSQL CONNECTION mysqlconn (IGNORE COLUMNS = (public.foo.bar), TEXT COLUMNS = (public.foo.baz)) FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: MySql { connection: Name(UnresolvedItemName([Ident("mysqlconn")])), options: [MySqlConfigOption { name: IgnoreColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("public"), Ident("foo"), Ident("bar")]))])) }, MySqlConfigOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("public"), Ident("foo"), Ident("baz")]))])) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red');
----
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("psychic")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic', PROGRESS GROUP ID PREFIX 'prefix', COMPRESSION TYPE = gzip) FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic', PROGRESS GROUP ID PREFIX = 'prefix', COMPRESSION TYPE = gzip) FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }, KafkaSinkConfigOption { name: ProgressGroupIdPrefix, value: Some(Value(String("prefix"))) }, KafkaSinkConfigOption { name: CompressionType, value: Some(UnresolvedItemName(UnresolvedItemName([Ident("gzip")]))) }], key: None }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK FROM bar INTO KAFKA CONNECTION baz
----
CREATE SINK FROM bar INTO KAFKA CONNECTION baz
=>
CreateSink(CreateSinkStatement { name: None, in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [], key: None }, format: None, envelope: None, with_options: [] })

parse-statement
CREATE SINK from FROM bar INTO KAFKA CONNECTION baz
----
CREATE SINK "from" FROM bar INTO KAFKA CONNECTION baz
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("from")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [], key: None }, format: None, envelope: None, with_options: [] })

parse-statement
CREATE SINK IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz
----
CREATE SINK IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz
=>
CreateSink(CreateSinkStatement { name: None, in_cluster: Some(Unresolved(Ident("c"))), if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [], key: None }, format: None, envelope: None, with_options: [] })

parse-statement
CREATE SINK in IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz
----
CREATE SINK in IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("in")])), in_cluster: Some(Unresolved(Ident("c"))), if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [], key: None }, format: None, envelope: None, with_options: [] })

parse-statement
CREATE SINK in FROM bar INTO KAFKA CONNECTION baz
----
CREATE SINK in FROM bar INTO KAFKA CONNECTION baz
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("in")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [], key: None }, format: None, envelope: None, with_options: [] })

parse-statement
CREATE SOURCE psychic IN CLUSTER c FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red') INCLUDE TIMESTAMP;
----
CREATE SOURCE psychic IN CLUSTER c FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red') INCLUDE TIMESTAMP
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("psychic")]), in_cluster: Some(Unresolved(Ident("c"))), col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, include_metadata: [Timestamp { alias: None }], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SINK IF NOT EXISTS foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) FORMAT BYTES ENVELOPE NONE
----
error: Expected UPSERT, or DEBEZIUM, found NONE
CREATE SINK IF NOT EXISTS foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) FORMAT BYTES ENVELOPE NONE
                                                                                                                  ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: Some(KafkaSinkKey { key_columns: [Ident("a"), Ident("b")], not_enforced: true }) }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
----
CREATE SINK foo IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: Some(Unresolved(Ident("c"))), if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: Some(KafkaSinkKey { key_columns: [Ident("a"), Ident("b")], not_enforced: true }) }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) CONSISTENCY (TOPIC 'consistency' FORMAT BYTES) FORMAT BYTES
----
error: Expected end of statement, found identifier "consistency"
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) CONSISTENCY (TOPIC 'consistency' FORMAT BYTES) FORMAT BYTES
                                                                              ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY FORMAT BYTES
----
error: Expected end of statement, found KEY
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY FORMAT BYTES
                                                                   ^

parse-statement
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
----
error: Expected NOT, found EXISTS
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
               ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SNAPSHOT = false)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SNAPSHOT = false)
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(false))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS = TRUE) ENVELOPE UPSERT
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS = true) ENVELOPE UPSERT
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [CsrConfigOption { name: NullDefaults, value: Some(Value(Boolean(true))) }] }, key_strategy: None, value_strategy: None, seed: None } })), envelope: Some(Upsert), with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS TRUE) ENVELOPE UPSERT
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS = true) ENVELOPE UPSERT
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [CsrConfigOption { name: NullDefaults, value: Some(Value(Boolean(true))) }] }, key_strategy: None, value_strategy: None, seed: None } })), envelope: Some(Upsert), with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS) ENVELOPE UPSERT
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS) ENVELOPE UPSERT
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [CsrConfigOption { name: NullDefaults, value: None }] }, key_strategy: None, value_strategy: None, seed: None } })), envelope: Some(Upsert), with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL VALUES) ENVELOPE UPSERT
----
error: Expected DEFAULTS, found VALUES
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL VALUES) ENVELOPE UPSERT
                                                                                                                                      ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS = FALSE) ENVELOPE UPSERT
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (NULL DEFAULTS = false) ENVELOPE UPSERT
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [CsrConfigOption { name: NullDefaults, value: Some(Value(Boolean(false))) }] }, key_strategy: None, value_strategy: None, seed: None } })), envelope: Some(Upsert), with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (DOC ON bar) ENVELOPE UPSERT
----
error: Expected one of TYPE or COLUMN, found identifier "bar"
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (DOC ON bar) ENVELOPE UPSERT
                                                                                                                                        ^


parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (DOC ON COLUMN c = 'comment') ENVELOPE UPSERT
----
error: need to specify an object and a column
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (DOC ON COLUMN c = 'comment') ENVELOPE UPSERT
                                                                                                                                               ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (DOC ON TYPE bar = 'bar comment', KEY DOC ON COLUMN bar.a = 'a comment', VALUE DOC ON COLUMN bar.b = 'b comment') ENVELOPE UPSERT
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 (DOC ON TYPE bar = 'bar comment', KEY DOC ON COLUMN bar.a = 'a comment', VALUE DOC ON COLUMN bar.b = 'b comment') ENVELOPE UPSERT
=>
CreateSink(CreateSinkStatement { name: Some(UnresolvedItemName([Ident("foo")])), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaSinkConfigOption { name: Topic, value: Some(Value(String("topic"))) }], key: None }, format: Some(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [CsrConfigOption { name: AvroDocOn(AvroDocOn { identifier: Type(Name(UnresolvedItemName([Ident("bar")]))), for_schema: All }), value: Some(Value(String("bar comment"))) }, CsrConfigOption { name: AvroDocOn(AvroDocOn { identifier: Column(RawColumnName { relation: Name(UnresolvedItemName([Ident("bar")])), column: Ident("a") }), for_schema: KeyOnly }), value: Some(Value(String("a comment"))) }, CsrConfigOption { name: AvroDocOn(AvroDocOn { identifier: Column(RawColumnName { relation: Name(UnresolvedItemName([Ident("bar")])), column: Ident("b") }), for_schema: ValueOnly }), value: Some(Value(String("b comment"))) }] }, key_strategy: None, value_strategy: None, seed: None } })), envelope: Some(Upsert), with_options: [] })

parse-statement
CREATE INDEX foo ON myschema.bar (a, b)
----
CREATE INDEX foo ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo ON myschema.bar USING arrangement (a, b)
----
CREATE INDEX foo ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo ON myschema.bar (a, b) WITH (RETAIN HISTORY = FOR 0)
----
CREATE INDEX foo ON myschema.bar (a, b) WITH (RETAIN HISTORY = FOR 0)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [IndexOption { name: RetainHistory, value: Some(RetainHistoryFor(Number("0"))) }], if_not_exists: false })

parse-statement
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
----
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("fizz")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("baz")])), key_parts: Some([Function(Function { name: Name(UnresolvedItemName([Ident("ascii")])), args: Args { args: [Identifier([Ident("x")])], order_by: [] }, filter: None, over: None, distinct: false }), IsExpr { expr: Identifier([Ident("a")]), construct: Null, negated: true }, Nested(Exists(Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("y")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("boop")])), alias: None }, joins: [] }], selection: Some(Op { op: Op { namespace: None, op: "=" }, expr1: Identifier([Ident("boop"), Ident("z")]), expr2: Some(Identifier([Ident("z")])) }), group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None })), Identifier([Ident("delta")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX ind ON tab ((col + 1))
----
CREATE INDEX ind ON tab ((col + 1))
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("ind")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: Some([Nested(Op { op: Op { namespace: None, op: "+" }, expr1: Identifier([Ident("col")]), expr2: Some(Value(Number("1"))) })]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
----
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("qualifiers")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("no_parentheses")])), key_parts: Some([Identifier([Ident("alpha"), Ident("omega")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo IN CLUSTER bar ON myschema.bar (a, b)
----
CREATE INDEX foo IN CLUSTER bar ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: Some(Unresolved(Ident("bar"))), on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo IN CLUSTER [1] ON myschema.bar (a, b)
----
CREATE INDEX foo IN CLUSTER [1] ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: Some(Resolved("1")), on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX ON tab
----
CREATE DEFAULT INDEX ON tab
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: None, with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
----
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: None, with_options: [], if_not_exists: true })

parse-statement
CREATE DEFAULT INDEX ON tab (a, b)
----
error: Expected end of statement, found left parenthesis
CREATE DEFAULT INDEX ON tab (a, b)
                            ^

parse-statement
CREATE INDEX ON tab;
----
error: Expected left parenthesis, found semicolon
CREATE INDEX ON tab;
                   ^

parse-statement
CREATE INDEX ON tab (a, b)
----
CREATE INDEX ON tab (a, b)
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX IF NOT EXISTS ON tab (a, b)
----
error: Expected index name, found ON
CREATE INDEX IF NOT EXISTS ON tab (a, b)
                           ^

parse-statement
CREATE INDEX myschema.ind ON foo(b)
----
error: Expected ON, found dot
CREATE INDEX myschema.ind ON foo(b)
                     ^

parse-statement
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
----
error: Expected NOT, found EXISTS
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
                ^

parse-statement
DROP DATABASE mydb
----
DROP DATABASE mydb
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: false, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: true })

parse-statement
DROP DATABASE IF EXISTS mydb
----
DROP DATABASE IF EXISTS mydb
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: true, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: true })

parse-statement
DROP DATABASE mydb.nope
----
error: Expected end of statement, found dot
DROP DATABASE mydb.nope
                  ^

parse-statement
DROP DATABASE mydb CASCADE
----
DROP DATABASE mydb
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: false, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: true })

parse-statement
DROP DATABASE mydb RESTRICT
----
DROP DATABASE mydb RESTRICT
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: false, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: false })

parse-statement
DROP DATABASE mydb CASCADE RESTRICT
----
error: Cannot specify both CASCADE and RESTRICT in DROP
DROP DATABASE mydb CASCADE RESTRICT
                           ^

parse-statement
DROP DATABASE mydb RESTRICT CASCADE
----
error: Cannot specify both RESTRICT and CASCADE in DROP
DROP DATABASE mydb RESTRICT CASCADE
                            ^

parse-statement
DROP DATABASE mydb CASCADE CASCADE
----
error: Expected end of statement, found CASCADE
DROP DATABASE mydb CASCADE CASCADE
                           ^

parse-statement
DROP SCHEMA mydb.myschema
----
DROP SCHEMA mydb.myschema
=>
DropObjects(DropObjectsStatement { object_type: Schema, if_exists: false, names: [Schema(UnresolvedSchemaName([Ident("mydb"), Ident("myschema")]))], cascade: false })

parse-statement
DROP TABLE foo
----
DROP TABLE foo
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: false, names: [Item(UnresolvedItemName([Ident("foo")]))], cascade: false })

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE
----
DROP TABLE IF EXISTS foo, bar CASCADE
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: true, names: [Item(UnresolvedItemName([Ident("foo")])), Item(UnresolvedItemName([Ident("bar")]))], cascade: true })

parse-statement
DROP TABLE
----
error: Expected identifier, found EOF
DROP TABLE
          ^

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
----
error: Cannot specify both CASCADE and RESTRICT in DROP
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
                                      ^

parse-statement
DROP VIEW myschema.myview
----
DROP VIEW myschema.myview
=>
DropObjects(DropObjectsStatement { object_type: View, if_exists: false, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("myview")]))], cascade: false })

parse-statement
DROP MATERIALIZED VIEW myschema.myview
----
DROP MATERIALIZED VIEW myschema.myview
=>
DropObjects(DropObjectsStatement { object_type: MaterializedView, if_exists: false, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("myview")]))], cascade: false })

parse-statement
DROP SOURCE myschema.mydatasource
----
DROP SOURCE myschema.mydatasource
=>
DropObjects(DropObjectsStatement { object_type: Source, if_exists: false, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("mydatasource")]))], cascade: false })

parse-statement
DROP INDEX IF EXISTS myschema.myindex
----
DROP INDEX IF EXISTS myschema.myindex
=>
DropObjects(DropObjectsStatement { object_type: Index, if_exists: true, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("myindex")]))], cascade: false })

parse-statement
SUBSCRIBE foo.bar
----
SUBSCRIBE foo.bar
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None, output: Diffs })

parse-statement
SUBSCRIBE TO foo.bar
----
SUBSCRIBE foo.bar
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None, output: Diffs })

parse-statement
SUBSCRIBE foo.bar AS OF 123
----
SUBSCRIBE foo.bar AS OF 123
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Value(Number("123")))), up_to: None, output: Diffs })

parse-statement
SUBSCRIBE foo.bar AS OF now()
----
SUBSCRIBE foo.bar AS OF now()
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Function(Function { name: Name(UnresolvedItemName([Ident("now")])), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))), up_to: None, output: Diffs })

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT) AS OF now()
----
SUBSCRIBE foo.bar WITH (SNAPSHOT) AS OF now()
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [SubscribeOption { name: Snapshot, value: None }], as_of: Some(At(Function(Function { name: Name(UnresolvedItemName([Ident("now")])), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))), up_to: None, output: Diffs })

parse-statement
SUBSCRIBE foo.bar WITH (PROGRESS) AS OF now()
----
SUBSCRIBE foo.bar WITH (PROGRESS) AS OF now()
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [SubscribeOption { name: Progress, value: None }], as_of: Some(At(Function(Function { name: Name(UnresolvedItemName([Ident("now")])), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))), up_to: None, output: Diffs })

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT = false, TIMESTAMPS) AS OF now()
----
error: Expected one of PROGRESS or SNAPSHOT, found identifier "timestamps"
SUBSCRIBE foo.bar WITH (SNAPSHOT = false, TIMESTAMPS) AS OF now()
                                          ^

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT false)
----
SUBSCRIBE foo.bar WITH (SNAPSHOT = false)
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [SubscribeOption { name: Snapshot, value: Some(Value(Boolean(false))) }], as_of: None, up_to: None, output: Diffs })

parse-statement
SUBSCRIBE (SELECT * FROM a)
----
SUBSCRIBE (SELECT * FROM a)
=>
Subscribe(SubscribeStatement { relation: Query(Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("a")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }), options: [], as_of: None, up_to: None, output: Diffs })

parse-statement
SUBSCRIBE foo.bar AS OF now() UP TO now() + interval '1' day
----
SUBSCRIBE foo.bar AS OF now() UP TO now() + INTERVAL '1' DAY
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Function(Function { name: Name(UnresolvedItemName([Ident("now")])), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))), up_to: Some(Op { op: Op { namespace: None, op: "+" }, expr1: Function(Function { name: Name(UnresolvedItemName([Ident("now")])), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }), expr2: Some(Value(Interval(IntervalValue { value: "1", precision_high: Year, precision_low: Day, fsec_max_precision: None }))) }), output: Diffs })

parse-statement
SUBSCRIBE foo.bar UP TO now() + interval '1' day
----
SUBSCRIBE foo.bar UP TO now() + INTERVAL '1' DAY
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: Some(Op { op: Op { namespace: None, op: "+" }, expr1: Function(Function { name: Name(UnresolvedItemName([Ident("now")])), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }), expr2: Some(Value(Interval(IntervalValue { value: "1", precision_high: Year, precision_low: Day, fsec_max_precision: None }))) }), output: Diffs })

parse-statement
SUBSCRIBE foo.bar AS OF AT LEAST 1
----
SUBSCRIBE foo.bar AS OF AT LEAST 1
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(AtLeast(Value(Number("1")))), up_to: None, output: Diffs })

parse-statement
SUBSCRIBE foo.bar ENVELOPE UPSERT KEY (a)
----
error: Expected left parenthesis, found KEY
SUBSCRIBE foo.bar ENVELOPE UPSERT KEY (a)
                                  ^

parse-statement
SUBSCRIBE foo.bar ENVELOPE UPSERT KEY (a, b, c, d, e)
----
error: Expected left parenthesis, found KEY
SUBSCRIBE foo.bar ENVELOPE UPSERT KEY (a, b, c, d, e)
                                  ^

parse-statement
SUBSCRIBE foo.bar ENVELOPE UPSERT (KEY (a, b, c, d, e))
----
SUBSCRIBE foo.bar ENVELOPE UPSERT (KEY (a, b, c, d, e))
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None, output: EnvelopeUpsert { key_columns: [Ident("a"), Ident("b"), Ident("c"), Ident("d"), Ident("e")] } })

parse-statement
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM KEY (a)
----
error: Expected left parenthesis, found KEY
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM KEY (a)
                                    ^

parse-statement
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM KEY (a, b, c, d, e)
----
error: Expected left parenthesis, found KEY
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM KEY (a, b, c, d, e)
                                    ^

parse-statement
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM (KEY (c))
----
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM (KEY (c))
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None, output: EnvelopeDebezium { key_columns: [Ident("c")] } })

parse-statement
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM (KEY (a, b, c, d, e))
----
SUBSCRIBE foo.bar ENVELOPE DEBEZIUM (KEY (a, b, c, d, e))
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None, output: EnvelopeDebezium { key_columns: [Ident("a"), Ident("b"), Ident("c"), Ident("d"), Ident("e")] } })

parse-statement
SUBSCRIBE foo.bar ENVELOPE blah
----
error: Expected one of UPSERT or DEBEZIUM, found identifier "blah"
SUBSCRIBE foo.bar ENVELOPE blah
                           ^

parse-statement
SUBSCRIBE foo.bar ENVELOPE
----
error: Expected one of UPSERT or DEBEZIUM, found EOF
SUBSCRIBE foo.bar ENVELOPE
                          ^


parse-statement
SUBSCRIBE foo.bar WITHIN TIMESTAMP ORDER BY a ASC NULLS LAST, b, c DESC
----
SUBSCRIBE foo.bar WITHIN TIMESTAMP ORDER BY a ASC NULLS LAST, b, c DESC
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None, output: WithinTimestampOrderBy { order_by: [OrderByExpr { expr: Identifier([Ident("a")]), asc: Some(true), nulls_last: Some(true) }, OrderByExpr { expr: Identifier([Ident("b")]), asc: None, nulls_last: None }, OrderByExpr { expr: Identifier([Ident("c")]), asc: Some(false), nulls_last: None }] } })

parse-statement
SUBSCRIBE (SELECT *, f1 + f2 FROM foo.bar) WITHIN TIMESTAMP ORDER BY foo.bar.baz DESC, f1 + f2
----
SUBSCRIBE (SELECT *, f1 + f2 FROM foo.bar) WITHIN TIMESTAMP ORDER BY foo.bar.baz DESC, f1 + f2
=>
Subscribe(SubscribeStatement { relation: Query(Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Wildcard, Expr { expr: Op { op: Op { namespace: None, op: "+" }, expr1: Identifier([Ident("f1")]), expr2: Some(Identifier([Ident("f2")])) }, alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("foo"), Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }), options: [], as_of: None, up_to: None, output: WithinTimestampOrderBy { order_by: [OrderByExpr { expr: Identifier([Ident("foo"), Ident("bar"), Ident("baz")]), asc: Some(false), nulls_last: None }, OrderByExpr { expr: Op { op: Op { namespace: None, op: "+" }, expr1: Identifier([Ident("f1")]), expr2: Some(Identifier([Ident("f2")])) }, asc: None, nulls_last: None }] } })


parse-statement
SUBSCRIBE foo.bar WITHIN TIMESTAMP ORDER BY
----
error: Unexpected EOF
SUBSCRIBE foo.bar WITHIN TIMESTAMP ORDER BY
                                           ^

parse-statement
CREATE TABLE public.customer (
        customer_id integer DEFAULT nextval(public.customer_customer_id_seq),
        store_id smallint NOT NULL,
        first_name character varying(45) NOT NULL,
        last_name character varying(45) COLLATE "es_ES" NOT NULL,
        email character varying(50),
        address_id smallint NOT NULL,
        activebool boolean DEFAULT true NOT NULL,
        create_date date DEFAULT now()::text NOT NULL,
        last_update timestamp without time zone DEFAULT now() NOT NULL,
        last_update_tz timestamp with time zone,
        active integer NOT NULL
) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
----
error: Expected RETAIN, found identifier "fillfactor"
) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
        ^

parse-statement roundtrip
CREATE TABLE public.customer (
    customer_id int DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
    store_id smallint NOT NULL,
    first_name character varying(45) NOT NULL,
    last_name character varying(45) NOT NULL,
    info text,
    address_id smallint NOT NULL,
    activebool boolean DEFAULT true NOT NULL,
    create_date date DEFAULT now()::date NOT NULL,
    create_date1 date DEFAULT 'now'::text::date NOT NULL,
    last_update timestamp DEFAULT now(),
    active int
)
----
CREATE TABLE public.customer (customer_id int4 DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL, store_id int2 NOT NULL, first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL, info text, address_id int2 NOT NULL, activebool bool DEFAULT true NOT NULL, create_date date DEFAULT now()::date NOT NULL, create_date1 date DEFAULT 'now'::text::date NOT NULL, last_update timestamp DEFAULT now(), active int4)

parse-statement roundtrip
CREATE TABLE bazaar.settings (
  settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL,
  user_id uuid UNIQUE,
  value text,
  use_metric boolean DEFAULT true
)
----
CREATE TABLE bazaar.settings (settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL, user_id uuid UNIQUE, value text, use_metric bool DEFAULT true)

parse-statement roundtrip
CREATE TABLE IF NOT EXISTS foo (bar int)
----
CREATE TABLE IF NOT EXISTS foo (bar int4)

parse-statement
ALTER INDEX name SET (property = true)
----
error: Expected RETAIN, found identifier "property"
ALTER INDEX name SET (property = true)
                      ^

parse-statement
ALTER INDEX name RESET (property)
----
error: Expected RETAIN, found identifier "property"
ALTER INDEX name RESET (property)
                        ^

parse-statement
ALTER INDEX IF EXISTS name SET (property = true)
----
error: Expected RETAIN, found identifier "property"
ALTER INDEX IF EXISTS name SET (property = true)
                                ^

parse-statement
ALTER INDEX name SET ()
----
error: Expected RETAIN, found right parenthesis
ALTER INDEX name SET ()
                      ^

parse-statement
ALTER INDEX name RESET ()
----
error: Expected RETAIN, found right parenthesis
ALTER INDEX name RESET ()
                        ^

parse-statement
ALTER INDEX name SET (property)
----
error: Expected RETAIN, found identifier "property"
ALTER INDEX name SET (property)
                      ^

parse-statement
ALTER INDEX name RESET (property = true)
----
error: Expected RETAIN, found identifier "property"
ALTER INDEX name RESET (property = true)
                        ^

parse-statement
ALTER SOURCE name SET (property = true)
----
error: Expected one of IGNORE or TIMELINE or TIMESTAMP or RETAIN, found identifier "property"
ALTER SOURCE name SET (property = true)
                       ^

parse-statement
ALTER SOURCE name SET (SIZE LARGE)
----
error: Expected one of IGNORE or TIMELINE or TIMESTAMP or RETAIN, found SIZE
ALTER SOURCE name SET (SIZE LARGE)
                       ^

parse-statement
ALTER SOURCE name RESET (SIZE)
----
error: Expected one of IGNORE or TIMELINE or TIMESTAMP or RETAIN, found SIZE
ALTER SOURCE name RESET (SIZE)
                         ^

parse-statement
ALTER SOURCE n DROP SUBSOURCE x, y, z
----
ALTER SOURCE n DROP SUBSOURCE x, y, z
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: DropSubsources { if_exists: false, cascade: false, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE n DROP TABLE x, y, z
----
ALTER SOURCE n DROP SUBSOURCE x, y, z
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: DropSubsources { if_exists: false, cascade: false, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE n DROP SUBSOURCE IF EXISTS x, y, z
----
ALTER SOURCE n DROP SUBSOURCE IF EXISTS x, y, z
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: DropSubsources { if_exists: true, cascade: false, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE n DROP SUBSOURCE x, y, z CASCADE
----
ALTER SOURCE n DROP SUBSOURCE x, y, z CASCADE
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: DropSubsources { if_exists: false, cascade: true, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE n DROP SUBSOURCE IF EXISTS x, y, z CASCADE
----
ALTER SOURCE n DROP SUBSOURCE IF EXISTS x, y, z CASCADE
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: DropSubsources { if_exists: true, cascade: true, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE IF EXISTS n DROP SUBSOURCE IF EXISTS x, y, z CASCADE
----
ALTER SOURCE IF EXISTS n DROP SUBSOURCE IF EXISTS x, y, z CASCADE
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: true, action: DropSubsources { if_exists: true, cascade: true, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE n DROP SUBSOURCE x, y, z RESTRICT
----
ALTER SOURCE n DROP SUBSOURCE x, y, z
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: DropSubsources { if_exists: false, cascade: false, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE n DROP SUBSOURCE IF EXISTS x, y, z RESTRICT
----
ALTER SOURCE n DROP SUBSOURCE IF EXISTS x, y, z
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: DropSubsources { if_exists: true, cascade: false, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE IF EXISTS n DROP SUBSOURCE IF EXISTS x, y, z RESTRICT
----
ALTER SOURCE IF EXISTS n DROP SUBSOURCE IF EXISTS x, y, z
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: true, action: DropSubsources { if_exists: true, cascade: false, names: [UnresolvedItemName([Ident("x")]), UnresolvedItemName([Ident("y")]), UnresolvedItemName([Ident("z")])] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: None }], options: [] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }], options: [] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: Some(Deferred(UnresolvedItemName([Ident("d"), Ident("e"), Ident("f"), Ident("g")]))) }], options: [] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: None }], options: [] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g, a.b.c
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g, a.b.c
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: Some(Deferred(UnresolvedItemName([Ident("d"), Ident("e"), Ident("f"), Ident("g")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: None }], options: [] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c, a.b.c.d AS e.f.g
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c, a.b.c.d AS e.f.g
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }], options: [] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a, b.c, c, d.e
----
ALTER SOURCE n ADD SUBSOURCE a, b.c, c, d.e
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("b"), Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("d"), Ident("e")]), subsource: None }], options: [] } })


parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: None }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: Some(Deferred(UnresolvedItemName([Ident("d"), Ident("e"), Ident("f"), Ident("g")]))) }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: None }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g, a.b.c WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d, a.b.c AS d.e.f.g, a.b.c WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: Some(Deferred(UnresolvedItemName([Ident("d"), Ident("e"), Ident("f"), Ident("g")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: None }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c, a.b.c.d AS e.f.g WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE n ADD SUBSOURCE a.b.c.d AS e.f.g, a.b.c, a.b.c.d AS e.f.g WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("a"), Ident("b"), Ident("c"), Ident("d")]), subsource: Some(Deferred(UnresolvedItemName([Ident("e"), Ident("f"), Ident("g")]))) }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE n ADD SUBSOURCE a, b.c, c, d.e WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE n ADD SUBSOURCE a, b.c, c, d.e WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("b"), Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("d"), Ident("e")]), subsource: None }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE IF EXISTS n ADD SUBSOURCE a, b.c, c, d.e WITH (TEXT COLUMNS [a.b, c.d])
----
ALTER SOURCE IF EXISTS n ADD SUBSOURCE a, b.c, c, d.e WITH (TEXT COLUMNS = (a.b, c.d))
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: true, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("b"), Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("c")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("d"), Ident("e")]), subsource: None }], options: [AlterSourceAddSubsourceOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("a"), Ident("b")])), UnresolvedItemName(UnresolvedItemName([Ident("c"), Ident("d")]))])) }] } })

parse-statement
ALTER SOURCE IF EXISTS n ADD SUBSOURCE a, b.c, c, d.e WITH ()
----
error: Expected one of TEXT, found right parenthesis
ALTER SOURCE IF EXISTS n ADD SUBSOURCE a, b.c, c, d.e WITH ()
                                                            ^

parse-statement
ALTER SOURCE IF EXISTS n ADD TABLE a, b.c AS d
----
ALTER SOURCE IF EXISTS n ADD SUBSOURCE a, b.c AS d
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: true, action: AddSubsources { subsources: [CreateSourceSubsource { reference: UnresolvedItemName([Ident("a")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("b"), Ident("c")]), subsource: Some(Deferred(UnresolvedItemName([Ident("d")]))) }], options: [] } })

parse-statement
ALTER SOURCE IF EXISTS n ADD SOURCE a, b.c AS d
----
error: Expected one of SUBSOURCE or TABLE, found SOURCE
ALTER SOURCE IF EXISTS n ADD SOURCE a, b.c AS d
                             ^

parse-statement
ALTER VIEW name SET (property = true)
----
error: Expected RETAIN, found identifier "property"
ALTER VIEW name SET (property = true)
                     ^

parse-statement
ALTER MATERIALIZED VIEW name SET (property = true)
----
error: Expected RETAIN, found identifier "property"
ALTER MATERIALIZED VIEW name SET (property = true)
                                  ^

parse-statement
ALTER SINK name SET (property = true)
----
error: Expected one of SNAPSHOT, found identifier "property"
ALTER SINK name SET (property = true)
                     ^

parse-statement
ALTER SINK IF EXISTS name SET (SIZE LARGE)
----
error: Expected one of SNAPSHOT, found SIZE
ALTER SINK IF EXISTS name SET (SIZE LARGE)
                               ^

parse-statement
ALTER SINK name RESET (SIZE)
----
error: Expected one of SNAPSHOT, found SIZE
ALTER SINK name RESET (SIZE)
                       ^

parse-statement
ALTER INDEX name RENAME TO name2
----
ALTER INDEX name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Index, if_exists: false, name: Item(UnresolvedItemName([Ident("name")])), to_item_name: Ident("name2") })

parse-statement
ALTER INDEX i1 misplaced
----
error: Expected one of RESET or SET or RENAME or OWNER, found identifier "misplaced"
ALTER INDEX i1 misplaced
               ^

parse-statement
ALTER INDEX i1
----
error: Expected one of RESET or SET or RENAME or OWNER, found EOF
ALTER INDEX i1
              ^

parse-statement
ALTER VIEW name RENAME TO name2
----
ALTER VIEW name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: View, if_exists: false, name: Item(UnresolvedItemName([Ident("name")])), to_item_name: Ident("name2") })

parse-statement
ALTER MATERIALIZED VIEW name RENAME TO name2
----
ALTER MATERIALIZED VIEW name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: MaterializedView, if_exists: false, name: Item(UnresolvedItemName([Ident("name")])), to_item_name: Ident("name2") })

parse-statement
CREATE CLUSTER cluster REPLICAS ()
----
CREATE CLUSTER cluster (REPLICAS = ())
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([])) }], features: [] })

parse-statement
CREATE CLUSTER cluster WITH REPLICAS ()
----
error: Expected one of AVAILABILITY or DISK or INTROSPECTION or MANAGED or REPLICAS or REPLICATION or SIZE or SCHEDULE, found WITH
CREATE CLUSTER cluster WITH REPLICAS ()
                       ^

parse-statement
CREATE CLUSTER cluster REPLICAS (), BADOPT
----
error: Expected one of AVAILABILITY or DISK or INTROSPECTION or MANAGED or REPLICAS or REPLICATION or SIZE or SCHEDULE, found identifier "badopt"
CREATE CLUSTER cluster REPLICAS (), BADOPT
                                    ^

parse-statement
CREATE CLUSTER cluster REPLICAS (a (STORAGECTL ADDRESSES ['host1']))
----
CREATE CLUSTER cluster (REPLICAS = (a (STORAGECTL ADDRESSES = ('host1'))))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: StoragectlAddresses, value: Some(Sequence([Value(String("host1"))])) }] }])) }], features: [] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (COMPUTECTL ADDRESSES ['host1']), b (SIZE '1'))
----
CREATE CLUSTER cluster (REPLICAS = (a (COMPUTECTL ADDRESSES = ('host1')), b (SIZE = '1')))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: ComputectlAddresses, value: Some(Sequence([Value(String("host1"))])) }] }, ReplicaDefinition { name: Ident("b"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }] }])) }], features: [] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (COMPUTE ADDRESSES ['host1'], INTROSPECTION INTERVAL '1s', INTROSPECTION DEBUGGING true), b (SIZE '1', INTROSPECTION INTERVAL 0))
----
CREATE CLUSTER cluster (REPLICAS = (a (COMPUTE ADDRESSES = ('host1'), INTROSPECTION INTERVAL = '1s', INTROSPECTION DEBUGGING = true), b (SIZE = '1', INTROSPECTION INTERVAL = 0)))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: ComputeAddresses, value: Some(Sequence([Value(String("host1"))])) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(String("1s"))) }, ReplicaOption { name: IntrospectionDebugging, value: Some(Value(Boolean(true))) }] }, ReplicaDefinition { name: Ident("b"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(Number("0"))) }] }])) }], features: [] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (SIZE '1'))
----
CREATE CLUSTER cluster (REPLICAS = (a (SIZE = '1')))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }] }])) }], features: [] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (STORAGECTL ADDRESSES ['123'], STORAGE ADDRESSES ['124'], COMPUTECTL ADDRESSES ['host1:2400', 'host2:2400'], COMPUTE ADDRESSES ['host1:2401', 'host2:2401'], WORKERS '1'))
----
CREATE CLUSTER cluster (REPLICAS = (a (STORAGECTL ADDRESSES = ('123'), STORAGE ADDRESSES = ('124'), COMPUTECTL ADDRESSES = ('host1:2400', 'host2:2400'), COMPUTE ADDRESSES = ('host1:2401', 'host2:2401'), WORKERS = '1')))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: StoragectlAddresses, value: Some(Sequence([Value(String("123"))])) }, ReplicaOption { name: StorageAddresses, value: Some(Sequence([Value(String("124"))])) }, ReplicaOption { name: ComputectlAddresses, value: Some(Sequence([Value(String("host1:2400")), Value(String("host2:2400"))])) }, ReplicaOption { name: ComputeAddresses, value: Some(Sequence([Value(String("host1:2401")), Value(String("host2:2401"))])) }, ReplicaOption { name: Workers, value: Some(Value(String("1"))) }] }])) }], features: [] })

parse-statement
CREATE CLUSTER cluster SIZE '1'
----
CREATE CLUSTER cluster (SIZE = '1')
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Size, value: Some(Value(String("1"))) }], features: [] })

parse-statement
CREATE CLUSTER cluster (SIZE '1') FEATURES (enable eager delta joins = true)
----
CREATE CLUSTER cluster (SIZE = '1') FEATURES (ENABLE EAGER DELTA JOINS = true)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Size, value: Some(Value(String("1"))) }], features: [ClusterFeature { name: EnableEagerDeltaJoins, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE CLUSTER cluster REPLICATION FACTOR 1
----
CREATE CLUSTER cluster (REPLICATION FACTOR = 1)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: ReplicationFactor, value: Some(Value(Number("1"))) }], features: [] })

parse-statement
CREATE CLUSTER cluster AVAILABILITY ZONES ('1')
----
CREATE CLUSTER cluster (AVAILABILITY ZONES = ('1'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: AvailabilityZones, value: Some(Sequence([Value(String("1"))])) }], features: [] })

parse-statement
CREATE CLUSTER cluster MANAGED true
----
CREATE CLUSTER cluster (MANAGED = true)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Managed, value: Some(Value(Boolean(true))) }], features: [] })

parse-statement
CREATE CLUSTER cluster MANAGED
----
CREATE CLUSTER cluster (MANAGED)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Managed, value: None }], features: [] })

parse-statement
CREATE CLUSTER cluster MANAGED, DISK = true
----
CREATE CLUSTER cluster (MANAGED, DISK = true)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Managed, value: None }, ClusterOption { name: Disk, value: Some(Value(Boolean(true))) }], features: [] })

parse-statement
CREATE CLUSTER cluster (MANAGED, DISK = true)
----
CREATE CLUSTER cluster (MANAGED, DISK = true)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Managed, value: None }, ClusterOption { name: Disk, value: Some(Value(Boolean(true))) }], features: [] })

parse-statement
CREATE CLUSTER cluster (MANAGED, DISK = true
----
error: Expected right parenthesis, found EOF
CREATE CLUSTER cluster (MANAGED, DISK = true
                                            ^

parse-statement
CREATE CLUSTER cluster MANAGED, DISK = true)
----
error: Expected end of statement, found right parenthesis
CREATE CLUSTER cluster MANAGED, DISK = true)
                                           ^

parse-statement
CREATE CLUSTER cluster INTROSPECTION INTERVAL '1'
----
CREATE CLUSTER cluster (INTROSPECTION INTERVAL = '1')
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: IntrospectionInterval, value: Some(Value(String("1"))) }], features: [] })

parse-statement
CREATE CLUSTER cluster INTROSPECTION DEBUGGING true
----
CREATE CLUSTER cluster (INTROSPECTION DEBUGGING = true)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: IntrospectionDebugging, value: Some(Value(Boolean(true))) }], features: [] })

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = MANUAL)
----
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = MANUAL)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Size, value: Some(Value(String("1"))) }, ClusterOption { name: Schedule, value: Some(ClusterScheduleOptionValue(Manual)) }], features: [] })

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH)
----
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH)
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Size, value: Some(Value(String("1"))) }, ClusterOption { name: Schedule, value: Some(ClusterScheduleOptionValue(Refresh { rehydration_time_estimate: None })) }], features: [] })

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE = '1 hour'))
----
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE = '1 hour'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Size, value: Some(Value(String("1"))) }, ClusterOption { name: Schedule, value: Some(ClusterScheduleOptionValue(Refresh { rehydration_time_estimate: Some(IntervalValue { value: "1 hour", precision_high: Year, precision_low: Second, fsec_max_precision: None }) })) }], features: [] })

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE '1 hour'))
----
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE = '1 hour'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Size, value: Some(Value(String("1"))) }, ClusterOption { name: Schedule, value: Some(ClusterScheduleOptionValue(Refresh { rehydration_time_estimate: Some(IntervalValue { value: "1 hour", precision_high: Year, precision_low: Second, fsec_max_precision: None }) })) }], features: [] })

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE))
----
error: Expected literal string, found right parenthesis
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE))
                                                                                    ^

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE = ))
----
error: Expected literal string, found right parenthesis
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE = ))
                                                                                       ^

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION))
----
error: Expected TIME, found right parenthesis
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION))
                                                                      ^

parse-statement
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE = '1 hour')
----
error: Expected right parenthesis, found EOF
CREATE CLUSTER cluster (SIZE = '1', SCHEDULE = ON REFRESH (REHYDRATION TIME ESTIMATE = '1 hour')
                                                                                                ^

parse-statement
ALTER CLUSTER cluster SET (SIZE '1')
----
ALTER CLUSTER cluster SET (SIZE = '1')
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: Size, value: Some(Value(String("1"))) }]) })

parse-statement
ALTER CLUSTER IF EXISTS cluster SET (MANAGED)
----
ALTER CLUSTER IF EXISTS cluster SET (MANAGED)
=>
AlterCluster(AlterClusterStatement { if_exists: true, name: Ident("cluster"), action: SetOptions([ClusterOption { name: Managed, value: None }]) })

parse-statement
ALTER CLUSTER cluster SET (REPLICATION FACTOR 1)
----
ALTER CLUSTER cluster SET (REPLICATION FACTOR = 1)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: ReplicationFactor, value: Some(Value(Number("1"))) }]) })

parse-statement
ALTER CLUSTER cluster SET (AVAILABILITY ZONES ('1', '2'))
----
ALTER CLUSTER cluster SET (AVAILABILITY ZONES = ('1', '2'))
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: AvailabilityZones, value: Some(Sequence([Value(String("1")), Value(String("2"))])) }]) })

parse-statement
ALTER CLUSTER cluster SET (MANAGED true)
----
ALTER CLUSTER cluster SET (MANAGED = true)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: Managed, value: Some(Value(Boolean(true))) }]) })

parse-statement
ALTER CLUSTER cluster SET (MANAGED)
----
ALTER CLUSTER cluster SET (MANAGED)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: Managed, value: None }]) })

parse-statement
ALTER CLUSTER cluster SET (INTROSPECTION INTERVAL '1')
----
ALTER CLUSTER cluster SET (INTROSPECTION INTERVAL = '1')
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: IntrospectionInterval, value: Some(Value(String("1"))) }]) })

parse-statement
ALTER CLUSTER cluster SET (INTROSPECTION DEBUGGING true)
----
ALTER CLUSTER cluster SET (INTROSPECTION DEBUGGING = true)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: IntrospectionDebugging, value: Some(Value(Boolean(true))) }]) })

parse-statement
ALTER CLUSTER cluster SET (AVAILABILITY ZONES ('a'), INTROSPECTION INTERVAL 1, INTROSPECTION DEBUGGING 1, MANAGED, REPLICAS (), REPLICATION FACTOR 0, SIZE 1)
----
ALTER CLUSTER cluster SET (AVAILABILITY ZONES = ('a'), INTROSPECTION INTERVAL = 1, INTROSPECTION DEBUGGING = 1, MANAGED, REPLICAS = (), REPLICATION FACTOR = 0, SIZE = 1)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: SetOptions([ClusterOption { name: AvailabilityZones, value: Some(Sequence([Value(String("a"))])) }, ClusterOption { name: IntrospectionInterval, value: Some(Value(Number("1"))) }, ClusterOption { name: IntrospectionDebugging, value: Some(Value(Number("1"))) }, ClusterOption { name: Managed, value: None }, ClusterOption { name: Replicas, value: Some(ClusterReplicas([])) }, ClusterOption { name: ReplicationFactor, value: Some(Value(Number("0"))) }, ClusterOption { name: Size, value: Some(Value(Number("1"))) }]) })

parse-statement
ALTER CLUSTER cluster RESET (SIZE)
----
ALTER CLUSTER cluster RESET (SIZE)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([Size]) })

parse-statement
ALTER CLUSTER cluster RESET (REPLICATION FACTOR)
----
ALTER CLUSTER cluster RESET (REPLICATION FACTOR)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([ReplicationFactor]) })

parse-statement
ALTER CLUSTER cluster RESET (REPLICAS)
----
ALTER CLUSTER cluster RESET (REPLICAS)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([Replicas]) })

parse-statement
ALTER CLUSTER cluster RESET (AVAILABILITY ZONES)
----
ALTER CLUSTER cluster RESET (AVAILABILITY ZONES)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([AvailabilityZones]) })

parse-statement
ALTER CLUSTER cluster RESET (MANAGED)
----
ALTER CLUSTER cluster RESET (MANAGED)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([Managed]) })

parse-statement
ALTER CLUSTER cluster RESET (INTROSPECTION INTERVAL)
----
ALTER CLUSTER cluster RESET (INTROSPECTION INTERVAL)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([IntrospectionInterval]) })

parse-statement
ALTER CLUSTER cluster RESET (INTROSPECTION DEBUGGING)
----
ALTER CLUSTER cluster RESET (INTROSPECTION DEBUGGING)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([IntrospectionDebugging]) })

parse-statement
ALTER CLUSTER cluster RESET (AVAILABILITY ZONES, INTROSPECTION INTERVAL, INTROSPECTION DEBUGGING, MANAGED, REPLICAS, REPLICATION FACTOR, SIZE)
----
ALTER CLUSTER cluster RESET (AVAILABILITY ZONES, INTROSPECTION INTERVAL, INTROSPECTION DEBUGGING, MANAGED, REPLICAS, REPLICATION FACTOR, SIZE)
=>
AlterCluster(AlterClusterStatement { if_exists: false, name: Ident("cluster"), action: ResetOptions([AvailabilityZones, IntrospectionInterval, IntrospectionDebugging, Managed, Replicas, ReplicationFactor, Size]) })

parse-statement
CREATE CLUSTER REPLICA replica
----
error: Expected dot, found EOF
CREATE CLUSTER REPLICA replica
                              ^

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small'
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', INTERNAL, BILLED AS 'free'
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', INTERNAL, BILLED AS = 'free')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: Internal, value: None }, ReplicaOption { name: BilledAs, value: Some(Value(String("free"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica (SIZE 'small', INTERNAL, BILLED AS 'free')
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', INTERNAL, BILLED AS = 'free')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: Internal, value: None }, ReplicaOption { name: BilledAs, value: Some(Value(String("free"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', INTERNAL = true, BILLED AS 'free'
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', INTERNAL = true, BILLED AS = 'free')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: Internal, value: Some(Value(Boolean(true))) }, ReplicaOption { name: BilledAs, value: Some(Value(String("free"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', INTERNAL = false, BILLED AS 'free'
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', INTERNAL = false, BILLED AS = 'free')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: Internal, value: Some(Value(Boolean(false))) }, ReplicaOption { name: BilledAs, value: Some(Value(String("free"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', BILLED AS 'free'
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', BILLED AS = 'free')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: BilledAs, value: Some(Value(String("free"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', AVAILABILITY ZONE 'a'
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', AVAILABILITY ZONE = 'a')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', AVAILABILITY ZONE 'a', DISK = false
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', AVAILABILITY ZONE = 'a', DISK = false)
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }, ReplicaOption { name: Disk, value: Some(Value(Boolean(false))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica AVAILABILITY ZONE 'a', AVAILABILITY ZONE 'b'
----
CREATE CLUSTER REPLICA default.replica (AVAILABILITY ZONE = 'a', AVAILABILITY ZONE = 'b')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("b"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', AVAILABILITY ZONE 'a'
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', AVAILABILITY ZONE = 'a')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', INTROSPECTION INTERVAL '1s', INTROSPECTION DEBUGGING = false
----
CREATE CLUSTER REPLICA default.replica (SIZE = 'small', INTROSPECTION INTERVAL = '1s', INTROSPECTION DEBUGGING = false)
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(String("1s"))) }, ReplicaOption { name: IntrospectionDebugging, value: Some(Value(Boolean(false))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica INTROSPECTION INTERVAL = 0, SIZE 'small'
----
CREATE CLUSTER REPLICA default.replica (INTROSPECTION INTERVAL = 0, SIZE = 'small')
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: IntrospectionInterval, value: Some(Value(Number("0"))) }, ReplicaOption { name: Size, value: Some(Value(String("small"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica INTROSPECTION INTERVAL NULL
----
CREATE CLUSTER REPLICA default.replica (INTROSPECTION INTERVAL = NULL)
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: IntrospectionInterval, value: Some(Value(Null)) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica STORAGECTL ADDRESSES ('1', '2'), COMPUTECTL ADDRESSES ('1', '2'), COMPUTE ADDRESSES ('3', '4'), WORKERS 2, INTROSPECTION INTERVAL = NULL
----
CREATE CLUSTER REPLICA default.replica (STORAGECTL ADDRESSES = ('1', '2'), COMPUTECTL ADDRESSES = ('1', '2'), COMPUTE ADDRESSES = ('3', '4'), WORKERS = 2, INTROSPECTION INTERVAL = NULL)
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: StoragectlAddresses, value: Some(Sequence([Value(String("1")), Value(String("2"))])) }, ReplicaOption { name: ComputectlAddresses, value: Some(Sequence([Value(String("1")), Value(String("2"))])) }, ReplicaOption { name: ComputeAddresses, value: Some(Sequence([Value(String("3")), Value(String("4"))])) }, ReplicaOption { name: Workers, value: Some(Value(Number("2"))) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(Null)) }] } })


parse-statement
DROP CLUSTER cluster
----
DROP CLUSTER cluster
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: false, names: [Cluster(Ident("cluster"))], cascade: false })

parse-statement
DROP CLUSTER IF EXISTS cluster
----
DROP CLUSTER IF EXISTS cluster
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: true, names: [Cluster(Ident("cluster"))], cascade: false })

parse-statement
DROP CLUSTER IF EXISTS cluster RESTRICT
----
DROP CLUSTER IF EXISTS cluster
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: true, names: [Cluster(Ident("cluster"))], cascade: false })

parse-statement
DROP CLUSTER REPLICA r1, r2
----
error: Expected dot, found comma
DROP CLUSTER REPLICA r1, r2
                       ^

parse-statement
DROP CLUSTER REPLICA IF EXISTS cluster.replica
----
DROP CLUSTER REPLICA IF EXISTS cluster.replica
=>
DropObjects(DropObjectsStatement { object_type: ClusterReplica, if_exists: true, names: [ClusterReplica(QualifiedReplica { cluster: Ident("cluster"), replica: Ident("replica") })], cascade: false })

parse-statement
DROP CLUSTER REPLICA IF EXISTS replica
----
error: Expected dot, found EOF
DROP CLUSTER REPLICA IF EXISTS replica
                                      ^

parse-statement
DROP CLUSTER IF EXISTS cluster CASCADE
----
DROP CLUSTER IF EXISTS cluster CASCADE
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: true, names: [Cluster(Ident("cluster"))], cascade: true })

parse-statement
CREATE SECRET secret AS decode('c2VjcmV0Cg==', 'base64')
----
CREATE SECRET secret AS decode('c2VjcmV0Cg==', 'base64')
=>
CreateSecret(CreateSecretStatement { name: UnresolvedItemName([Ident("secret")]), if_not_exists: false, value: Function(Function { name: Name(UnresolvedItemName([Ident("decode")])), args: Args { args: [Value(String("c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
CREATE SECRET IF NOT EXISTS secret AS decode('c2VjcmV0Cg==', 'base64')
----
CREATE SECRET IF NOT EXISTS secret AS decode('c2VjcmV0Cg==', 'base64')
=>
CreateSecret(CreateSecretStatement { name: UnresolvedItemName([Ident("secret")]), if_not_exists: true, value: Function(Function { name: Name(UnresolvedItemName([Ident("decode")])), args: Args { args: [Value(String("c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
DROP SECRET secret
----
DROP SECRET secret
=>
DropObjects(DropObjectsStatement { object_type: Secret, if_exists: false, names: [Item(UnresolvedItemName([Ident("secret")]))], cascade: false })

parse-statement
DROP SECRET IF EXISTS secret
----
DROP SECRET IF EXISTS secret
=>
DropObjects(DropObjectsStatement { object_type: Secret, if_exists: true, names: [Item(UnresolvedItemName([Ident("secret")]))], cascade: false })

parse-statement
SHOW SECRETS
----
SHOW SECRETS
=>
Show(ShowObjects(ShowObjectsStatement { object_type: Secret, from: None, filter: None }))

parse-statement
ALTER SECRET IF EXISTS secret RENAME TO secret2
----
ALTER SECRET IF EXISTS secret RENAME TO secret2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Secret, if_exists: true, name: Item(UnresolvedItemName([Ident("secret")])), to_item_name: Ident("secret2") })

parse-statement
ALTER SECRET secret AS decode('new c2VjcmV0Cg==', 'base64')
----
ALTER SECRET secret AS decode('new c2VjcmV0Cg==', 'base64')
=>
AlterSecret(AlterSecretStatement { name: UnresolvedItemName([Ident("secret")]), if_exists: false, value: Function(Function { name: Name(UnresolvedItemName([Ident("decode")])), args: Args { args: [Value(String("new c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
CREATE CONNECTION conn1 FOR KAFKA BROKER 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux', SSH TUNNEL = tunnel;
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux', SSH TUNNEL = tunnel)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: false, values: [ConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: Direct })) }, ConnectionOption { name: SslKey, value: Some(Value(String("foo"))) }, ConnectionOption { name: SslCertificate, value: Some(Value(String("qux"))) }, ConnectionOption { name: SshTunnel, value: Some(Item(Name(UnresolvedItemName([Ident("tunnel")])))) }], with_options: [] })

parse-statement roundtrip
CREATE CONNECTION conn1 TO KAFKA (BROKER 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux');
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux')

parse-statement roundtrip
CREATE CONNECTION conn1 TO KAFKA (SECURITY PROTOCOL = 'foOoO');
----
CREATE CONNECTION conn1 TO KAFKA (SECURITY PROTOCOL = 'foOoO')

parse-statement
CREATE CONNECTION conn1 FOR KAFKA BROKER 'kafka:1234', PROGRESS TOPIC 'my-materialize-progress-topic';
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234', PROGRESS TOPIC = 'my-materialize-progress-topic')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: false, values: [ConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: Direct })) }, ConnectionOption { name: ProgressTopic, value: Some(Value(String("my-materialize-progress-topic"))) }], with_options: [] })

parse-statement
CREATE CONNECTION conn1 FOR KAFKA BROKER 'kafka:1234', SSH TUNNEL tun, SSL CERTIFICATE AUTHORITY 'authority', SASL MECHANISMS 'sasl-mechanisms', SASL USERNAME 'sasl-username', SASL PASSWORD = SECRET sc;
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234', SSH TUNNEL = tun, SSL CERTIFICATE AUTHORITY = 'authority', SASL MECHANISMS = 'sasl-mechanisms', SASL USERNAME = 'sasl-username', SASL PASSWORD = SECRET sc)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: false, values: [ConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: Direct })) }, ConnectionOption { name: SshTunnel, value: Some(Item(Name(UnresolvedItemName([Ident("tun")])))) }, ConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("authority"))) }, ConnectionOption { name: SaslMechanisms, value: Some(Value(String("sasl-mechanisms"))) }, ConnectionOption { name: SaslUsername, value: Some(Value(String("sasl-username"))) }, ConnectionOption { name: SaslPassword, value: Some(Secret(Name(UnresolvedItemName([Ident("sc")])))) }], with_options: [] })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (BROKER 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1);
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: false, values: [ConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [] }) })) }], with_options: [] })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (BROKER 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093, AVAILABILITY ZONE 'az1'));
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1 (PORT = 9093, AVAILABILITY ZONE = 'az1'))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: false, values: [ConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9093"))) }, KafkaBrokerAwsPrivatelinkOption { name: AvailabilityZone, value: Some(Value(String("az1"))) }] }) })) }], with_options: [] })

parse-statement
CREATE CONNECTION IF NOT EXISTS conn1 TO KAFKA (
    BROKERS (
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9092),
        'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093),
        'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1
    )
);
----
CREATE CONNECTION IF NOT EXISTS conn1 TO KAFKA (BROKERS = ('kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT = 9092), 'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT = 9093), 'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: true, values: [ConnectionOption { name: Brokers, value: Some(Sequence([ConnectionKafkaBroker(KafkaBroker { address: "kafka:9092", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9092"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9093", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9093"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9094", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [] }) })])) }], with_options: [] })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (
    BROKERS [
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9092),
        'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093),
        'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1
    ]
);
----
CREATE CONNECTION conn1 TO KAFKA (BROKERS = ('kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT = 9092), 'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT = 9093), 'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: false, values: [ConnectionOption { name: Brokers, value: Some(Sequence([ConnectionKafkaBroker(KafkaBroker { address: "kafka:9092", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9092"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9093", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9093"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9094", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [] }) })])) }], with_options: [] })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (
    BROKERS (
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 [PORT 9092],
    )
);
----
error: Expected right parenthesis, found left square bracket
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 [PORT 9092],
                                                              ^

parse-statement
CREATE CONNECTION conn1 TO KAFKA (
    BROKERS (
        'kafka:9092' USING SSH TUNNEL tunn,
        'kafka:9093' USING SSH TUNNEL tunn
    )
);
----
CREATE CONNECTION conn1 TO KAFKA (BROKERS = ('kafka:9092'USING SSH TUNNEL tunn, 'kafka:9093'USING SSH TUNNEL tunn))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Kafka, if_not_exists: false, values: [ConnectionOption { name: Brokers, value: Some(Sequence([ConnectionKafkaBroker(KafkaBroker { address: "kafka:9092", tunnel: SshTunnel(Name(UnresolvedItemName([Ident("tunn")]))) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9093", tunnel: SshTunnel(Name(UnresolvedItemName([Ident("tunn")]))) })])) }], with_options: [] })

parse-statement
DROP CONNECTION conn1
----
DROP CONNECTION conn1
=>
DropObjects(DropObjectsStatement { object_type: Connection, if_exists: false, names: [Item(UnresolvedItemName([Ident("conn1")]))], cascade: false })

parse-statement
CREATE SOURCE IF NOT EXISTS src1 (a, b, PRIMARY KEY (a) NOT ENFORCED) FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT BYTES
----
CREATE SOURCE IF NOT EXISTS src1 (a, b, PRIMARY KEY (a) NOT ENFORCED) FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT BYTES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [Ident("a"), Ident("b")], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Bytes)), envelope: None, if_not_exists: true, key_constraint: Some(PrimaryKeyNotEnforced { columns: [Ident("a")] }), with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') KEY (a, b) FORMAT BYTES
----
error: Expected FORMAT, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') KEY (a, b) FORMAT BYTES
                                                                 ^

parse-statement
CREATE SOURCE src1 (PRIMARY KEY (key1, key2) NOT ENFORCED) FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT BYTES
----
CREATE SOURCE src1 (PRIMARY KEY (key1, key2) NOT ENFORCED) FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT BYTES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Bytes)), envelope: None, if_not_exists: false, key_constraint: Some(PrimaryKeyNotEnforced { columns: [Ident("key1"), Ident("key2")] }), with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE CONNECTION conn1 FOR CONFLUENT SCHEMA REGISTRY URL 'http://localhost:8081', USERNAME 'user', PASSWORD 'word', PORT 1234, AWS PRIVATELINK apl
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (URL = 'http://localhost:8081', USER = 'user', PASSWORD = 'word', PORT = 1234, AWS PRIVATELINK = apl)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Csr, if_not_exists: false, values: [ConnectionOption { name: Url, value: Some(Value(String("http://localhost:8081"))) }, ConnectionOption { name: User, value: Some(Value(String("user"))) }, ConnectionOption { name: Password, value: Some(Value(String("word"))) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, ConnectionOption { name: AwsPrivatelink, value: Some(ConnectionAwsPrivatelink(ConnectionDefaultAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("apl")])), port: None })) }], with_options: [] })

parse-statement roundtrip
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (URL = 'http://localhost:8081', USERNAME = 'user', PASSWORD = 'word')
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (URL = 'http://localhost:8081', USER = 'user', PASSWORD = 'word')


parse-statement
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK db.schema.item, PORT 8080)
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK = db.schema.item, PORT = 8080)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Csr, if_not_exists: false, values: [ConnectionOption { name: AwsPrivatelink, value: Some(ConnectionAwsPrivatelink(ConnectionDefaultAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])), port: None })) }, ConnectionOption { name: Port, value: Some(Value(Number("8080"))) }], with_options: [] })

parse-statement
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (SSH TUNNEL ssh, SSL CERTIFICATE 'cert', SSL CERTIFICATE AUTHORITY 'auth', SSL KEY 'key')
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (SSH TUNNEL = ssh, SSL CERTIFICATE = 'cert', SSL CERTIFICATE AUTHORITY = 'auth', SSL KEY = 'key')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Csr, if_not_exists: false, values: [ConnectionOption { name: SshTunnel, value: Some(Item(Name(UnresolvedItemName([Ident("ssh")])))) }, ConnectionOption { name: SslCertificate, value: Some(Value(String("cert"))) }, ConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("auth"))) }, ConnectionOption { name: SslKey, value: Some(Value(String("key"))) }], with_options: [] })


parse-statement
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK db.schema.item, PORT 8080, URL 'http://localhost:8081')
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK = db.schema.item, PORT = 8080, URL = 'http://localhost:8081')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection_type: Csr, if_not_exists: false, values: [ConnectionOption { name: AwsPrivatelink, value: Some(ConnectionAwsPrivatelink(ConnectionDefaultAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])), port: None })) }, ConnectionOption { name: Port, value: Some(Value(Number("8080"))) }, ConnectionOption { name: Url, value: Some(Value(String("http://localhost:8081"))) }], with_options: [] })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [] }, key_strategy: None, value_strategy: None, seed: None } }))), envelope: Some(Debezium), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [] }, seed: None } }))), envelope: Some(Debezium), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (SOURCE a.b.c, COLLECTION 'foo'))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (SOURCE a.b.c, COLLECTION 'foo'))
                                                                               ^

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                                               ^

# Note that this will error in planning, as you cannot specify START OFFSET and START TIMESTAMP at the same time
parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (START OFFSET=1, START TIMESTAMP=2, TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (START OFFSET=1, START TIMESTAMP=2, TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                                                                                  ^

# Note that this will error in planning, as START OFFSET must be an array of nums
parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 WITH (START OFFSET="hmm") TOPIC 'baz' ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected one of IGNORE or TIMELINE or TIMESTAMP or RETAIN, found START
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 WITH (START OFFSET="hmm") TOPIC 'baz' ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                     ^

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING SCHEMA 'schema'
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING SCHEMA 'schema'
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Avro(InlineSchema { schema: Schema { schema: "schema" }, with_options: [] }))), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING SCHEMA 'schema' (CONFLUENT WIRE FORMAT = false)
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING SCHEMA 'schema' (CONFLUENT WIRE FORMAT = false)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Avro(InlineSchema { schema: Schema { schema: "schema" }, with_options: [AvroSchemaOption { name: ConfluentWireFormat, value: Some(Value(Boolean(false))) }] }))), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING SCHEMA 'schema' (CONFLUENT WIRE FORMAT = true)
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING SCHEMA 'schema' (CONFLUENT WIRE FORMAT = true)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Avro(InlineSchema { schema: Schema { schema: "schema" }, with_options: [AvroSchemaOption { name: ConfluentWireFormat, value: Some(Value(Boolean(true))) }] }))), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF MESSAGE 'Batch' USING SCHEMA '\x0a300a0d62696'
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF MESSAGE 'Batch' USING SCHEMA '\x0a300a0d62696'
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Protobuf(InlineSchema { message_name: "Batch", schema: Schema { schema: "\\x0a300a0d62696" } }))), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED VALUE SCHEMA '{"some": "seed"}' MESSAGE 'Batch' ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED VALUE SCHEMA '{"some": "seed"}' MESSAGE 'Batch' ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, seed: Some(CsrSeedProtobuf { key: None, value: CsrSeedProtobufSchema { schema: "{\"some\": \"seed\"}", message_name: "Batch" } }) } }))), envelope: Some(Debezium), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, seed: Some(CsrSeedProtobuf { key: Some(CsrSeedProtobufSchema { schema: "{\"some\": \"seed\"}", message_name: "Batch" }), value: CsrSeedProtobufSchema { schema: "123", message_name: "M" } }) } }))), envelope: Some(Debezium), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE UPSERT
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE UPSERT
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, seed: Some(CsrSeedProtobuf { key: Some(CsrSeedProtobufSchema { schema: "{\"some\": \"seed\"}", message_name: "Batch" }), value: CsrSeedProtobufSchema { schema: "123", message_name: "M" } }) } }))), envelope: Some(Upsert), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE MATERIALIZE
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE MATERIALIZE
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, seed: Some(CsrSeedProtobuf { key: Some(CsrSeedProtobufSchema { schema: "{\"some\": \"seed\"}", message_name: "Batch" }), value: CsrSeedProtobufSchema { schema: "123", message_name: "M" } }) } }))), envelope: Some(CdcV2), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE NONE
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "seed"}' MESSAGE 'Batch' VALUE SCHEMA '123' MESSAGE 'M' ENVELOPE NONE
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, seed: Some(CsrSeedProtobuf { key: Some(CsrSeedProtobufSchema { schema: "{\"some\": \"seed\"}", message_name: "Batch" }), value: CsrSeedProtobufSchema { schema: "123", message_name: "M" } }) } }))), envelope: Some(None), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') KEY FORMAT TEXT VALUE FORMAT REGEX '(?P<animal>[^,]+),(?P<food>\w+)' INCLUDE KEY
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') KEY FORMAT TEXT VALUE FORMAT REGEX '(?P<animal>[^,]+),(?P<food>\w+)' INCLUDE KEY
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [Key { alias: None }], format: Some(KeyValue { key: Text, value: Regex("(?P<animal>[^,]+),(?P<food>\\w+)") }), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') KEY FORMAT TEXT VALUE FORMAT CSV WITH 2 COLUMNS DELIMITED BY ','
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') KEY FORMAT TEXT VALUE FORMAT CSV WITH 2 COLUMNS
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(KeyValue { key: Text, value: Csv { columns: Count(2), delimiter: ',' } }), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') KEY FORMAT TEXT VALUE FORMAT CSV WITH 2 COLUMNS DELIMITED BY ';'
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') KEY FORMAT TEXT VALUE FORMAT CSV WITH 2 COLUMNS DELIMITED BY ';'
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(KeyValue { key: Text, value: Csv { columns: Count(2), delimiter: ';' } }), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn (AVRO KEY FULLNAME = 'some.neat.class.foo', AVRO VALUE FULLNAME = 'some.neat.class.bar')
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn (AVRO KEY FULLNAME = 'some.neat.class.foo', AVRO VALUE FULLNAME = 'some.neat.class.bar')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [CsrConfigOption { name: AvroKeyFullname, value: Some(Value(String("some.neat.class.foo"))) }, CsrConfigOption { name: AvroValueFullname, value: Some(Value(String("some.neat.class.bar"))) }] }, key_strategy: None, value_strategy: None, seed: None } }))), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED VALUE SCHEMA '{"some": "schema"}' ENVELOPE NONE
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED VALUE SCHEMA '{"some": "schema"}' ENVELOPE NONE
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, key_strategy: None, value_strategy: None, seed: Some(CsrSeedAvro { key_schema: None, value_schema: "{\"some\": \"schema\"}" }) } }))), envelope: Some(None), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "schema"}' VALUE SCHEMA '123' ENVELOPE NONE
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "schema"}' VALUE SCHEMA '123' ENVELOPE NONE
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, key_strategy: None, value_strategy: None, seed: Some(CsrSeedAvro { key_schema: Some("{\"some\": \"schema\"}"), value_schema: "123" }) } }))), envelope: Some(None), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') KEY FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn VALUE FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "schema"}' VALUE SCHEMA '123' ENVELOPE NONE
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') KEY FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn VALUE FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "schema"}' VALUE SCHEMA '123' ENVELOPE NONE
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(KeyValue { key: Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, key_strategy: None, value_strategy: None, seed: None } }), value: Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, key_strategy: None, value_strategy: None, seed: Some(CsrSeedAvro { key_schema: Some("{\"some\": \"schema\"}"), value_schema: "123" }) } }) }), envelope: Some(None), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') KEY FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn VALUE FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "schema"}' VALUE SCHEMA '123' INCLUDE KEY, TIMESTAMP, PARTITION AS "PART2", OFFSET, HEADERS ENVELOPE NONE
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') KEY FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn VALUE FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION csr_conn SEED KEY SCHEMA '{"some": "schema"}' VALUE SCHEMA '123' INCLUDE KEY, TIMESTAMP, PARTITION AS "PART2", OFFSET, HEADERS ENVELOPE NONE
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [Key { alias: None }, Timestamp { alias: None }, Partition { alias: Some(Ident("PART2")) }, Offset { alias: None }, Headers { alias: None }], format: Some(KeyValue { key: Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, key_strategy: None, value_strategy: None, seed: None } }), value: Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("csr_conn")])), options: [] }, key_strategy: None, value_strategy: None, seed: Some(CsrSeedAvro { key_schema: Some("{\"some\": \"schema\"}"), value_schema: "123" }) } }) }), envelope: Some(None), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE golbat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' KEY FORMAT TEXT VALUE FORMAT TEXT INCLUDE KEY ENVELOPE NONE
----
error: Expected CONNECTION, found BROKER
CREATE SOURCE golbat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' KEY FORMAT TEXT VALUE FORMAT TEXT INCLUDE KEY ENVELOPE NONE
                                ^

parse-statement
CREATE SOURCE example FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT CSV WITH HEADER (id, value)
----
CREATE SOURCE example FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT CSV WITH HEADER (id, value)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("example")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Csv { columns: Header { names: [Ident("id"), Ident("value")] }, delimiter: ',' })), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE example FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT CSV WITH 5 COLUMNS
----
CREATE SOURCE example FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT CSV WITH 5 COLUMNS
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("example")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, include_metadata: [], format: Some(Bare(Csv { columns: Count(5), delimiter: ',' })), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE CONNECTION my_ssh_tunnel FOR SSH TUNNEL HOST 'ssh-bastion', PORT 1234, USER 'blah'
----
CREATE CONNECTION my_ssh_tunnel TO SSH TUNNEL (HOST = 'ssh-bastion', PORT = 1234, USER = 'blah')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("my_ssh_tunnel")]), connection_type: Ssh, if_not_exists: false, values: [ConnectionOption { name: Host, value: Some(Value(String("ssh-bastion"))) }, ConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, ConnectionOption { name: User, value: Some(Value(String("blah"))) }], with_options: [] })

parse-statement roundtrip
CREATE CONNECTION my_ssh_tunnel TO SSH TUNNEL (HOST 'ssh-bastion', PORT 1234, USER 'blah')
----
CREATE CONNECTION my_ssh_tunnel TO SSH TUNNEL (HOST = 'ssh-bastion', PORT = 1234, USER = 'blah')

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER
----
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Counter, options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR KEY VALUE (KEYS 1, PARTITIONS 2, TICK INTERVAL '1m', BATCH SIZE 100, SEED 200, VALUE SIZE 150, SNAPSHOT ROUNDS 3, TRANSACTIONAL SNAPSHOT = false)
----
CREATE SOURCE lg FROM LOAD GENERATOR KEY VALUE (KEYS = 1, PARTITIONS = 2, TICK INTERVAL = '1m', BATCH SIZE = 100, SEED = 200, VALUE SIZE = 150, SNAPSHOT ROUNDS = 3, TRANSACTIONAL SNAPSHOT = false)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: KeyValue, options: [LoadGeneratorOption { name: Keys, value: Some(Value(Number("1"))) }, LoadGeneratorOption { name: Partitions, value: Some(Value(Number("2"))) }, LoadGeneratorOption { name: TickInterval, value: Some(Value(String("1m"))) }, LoadGeneratorOption { name: BatchSize, value: Some(Value(Number("100"))) }, LoadGeneratorOption { name: Seed, value: Some(Value(Number("200"))) }, LoadGeneratorOption { name: ValueSize, value: Some(Value(Number("150"))) }, LoadGeneratorOption { name: SnapshotRounds, value: Some(Value(Number("3"))) }, LoadGeneratorOption { name: TransactionalSnapshot, value: Some(Value(Boolean(false))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER (TICK INTERVAL '1s', SCALE FACTOR 1, MAX CARDINALITY 100)
----
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER (TICK INTERVAL = '1s', SCALE FACTOR = 1, MAX CARDINALITY = 100)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Counter, options: [LoadGeneratorOption { name: TickInterval, value: Some(Value(String("1s"))) }, LoadGeneratorOption { name: ScaleFactor, value: Some(Value(Number("1"))) }, LoadGeneratorOption { name: MaxCardinality, value: Some(Value(Number("100"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR MARKETING
----
CREATE SOURCE lg FROM LOAD GENERATOR MARKETING
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Marketing, options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR AUCTION
----
CREATE SOURCE lg FROM LOAD GENERATOR AUCTION
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Auction, options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR DATUMS
----
CREATE SOURCE lg FROM LOAD GENERATOR DATUMS
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Datums, options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR TPCH
----
CREATE SOURCE lg FROM LOAD GENERATOR TPCH
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Tpch, options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red') with (IGNORE KEYS 'true', TIMELINE 'timeline', TIMESTAMP INTERVAL 'interval')
----
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red') WITH (IGNORE KEYS = 'true', TIMELINE = 'timeline', TIMESTAMP INTERVAL = 'interval')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("psychic")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: IgnoreKeys, value: Some(Value(String("true"))) }, CreateSourceOption { name: Timeline, value: Some(Value(String("timeline"))) }, CreateSourceOption { name: TimestampInterval, value: Some(Value(String("interval"))) }], referenced_subsources: None, progress_subsource: None })

parse-statement
ALTER SYSTEM SET wal_level TO logical
----
ALTER SYSTEM SET wal_level = logical
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("wal_level"), to: Values([Ident(Ident("logical"))]) })

parse-statement
ALTER SYSTEM SET wal_level = logical
----
ALTER SYSTEM SET wal_level = logical
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("wal_level"), to: Values([Ident(Ident("logical"))]) })

parse-statement
ALTER SYSTEM SET log_destination TO 'syslog'
----
ALTER SYSTEM SET log_destination = 'syslog'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_destination"), to: Values([Literal(String("syslog"))]) })

parse-statement
ALTER SYSTEM SET log_destination = 'syslog'
----
ALTER SYSTEM SET log_destination = 'syslog'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_destination"), to: Values([Literal(String("syslog"))]) })

parse-statement
ALTER SYSTEM SET shared_buffers TO 42
----
ALTER SYSTEM SET shared_buffers = 42
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("shared_buffers"), to: Values([Literal(Number("42"))]) })

parse-statement
ALTER SYSTEM SET shared_buffers = 42
----
ALTER SYSTEM SET shared_buffers = 42
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("shared_buffers"), to: Values([Literal(Number("42"))]) })

parse-statement
ALTER SYSTEM SET search_path TO default
----
ALTER SYSTEM SET search_path = DEFAULT
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("search_path"), to: Default })

parse-statement
ALTER SYSTEM SET search_path = default
----
ALTER SYSTEM SET search_path = DEFAULT
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("search_path"), to: Default })

parse-statement
ALTER SYSTEM SET log_connections TO 'default'
----
ALTER SYSTEM SET log_connections = 'default'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_connections"), to: Values([Literal(String("default"))]) })

parse-statement
ALTER SYSTEM SET log_connections = 'default'
----
ALTER SYSTEM SET log_connections = 'default'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_connections"), to: Values([Literal(String("default"))]) })

parse-statement
ALTER SYSTEM SET some_array_key = [667, 668]
----
error: Expected variable value, found left square bracket
ALTER SYSTEM SET some_array_key = [667, 668]
                                  ^

parse-statement
ALTER SYSTEM SET quantum_enabled = true
----
ALTER SYSTEM SET quantum_enabled = true
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("quantum_enabled"), to: Values([Literal(Boolean(true))]) })

parse-statement
ALTER SYSTEM SET use_optional = NULL
----
ALTER SYSTEM SET use_optional = NULL
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("use_optional"), to: Values([Literal(Null)]) })

parse-statement
ALTER SYSTEM SET key value
----
error: Expected TO or equals sign, found VALUE
ALTER SYSTEM SET key value
                     ^

parse-statement
ALTER SYSTEM RESET wal_level
----
ALTER SYSTEM RESET wal_level
=>
AlterSystemReset(AlterSystemResetStatement { name: Ident("wal_level") })

parse-statement
ALTER SYSTEM RESET ALL
----
ALTER SYSTEM RESET ALL
=>
AlterSystemResetAll(AlterSystemResetAllStatement)

parse-statement
ALTER SYSTEM RESET
----
error: Expected identifier, found EOF
ALTER SYSTEM RESET
                  ^

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR SCHEMAS (one, two);
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR SCHEMAS (one, two)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(SubsetSchemas([Ident("one"), Ident("two")])), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (TEXT COLUMNS = [foo, foo.bar, foo.bar.qux, foo.bar.qux.qax, foo.bar.qux.qax.baz], DETAILS = 'details') FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (TEXT COLUMNS = (foo, foo.bar, foo.bar.qux, foo.bar.qux.qax, foo.bar.qux.qax.baz), DETAILS = 'details') FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("foo")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar"), Ident("qux")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar"), Ident("qux"), Ident("qax")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar"), Ident("qux"), Ident("qax"), Ident("baz")]))])) }, PgConfigOption { name: Details, value: Some(Value(String("details"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES (foo, bar as qux, baz into zop);
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR TABLES (foo, bar AS qux, baz AS zop)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(SubsetTables([CreateSourceSubsource { reference: UnresolvedItemName([Ident("foo")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("bar")]), subsource: Some(Deferred(UnresolvedItemName([Ident("qux")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("baz")]), subsource: Some(Deferred(UnresolvedItemName([Ident("zop")]))) }])), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar]);
----
error: Expected identifier, found left square bracket
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar]);
                                                                                          ^

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES (baz AS [s1 AS foo.bar]);
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR TABLES (baz AS [s1 AS foo.bar])
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(SubsetTables([CreateSourceSubsource { reference: UnresolvedItemName([Ident("baz")]), subsource: Some(Named(Id("s1", UnresolvedItemName([Ident("foo"), Ident("bar")])))) }])), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar] AS baz);
----
error: Expected identifier, found left square bracket
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar] AS baz);
                                                                                          ^

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR ALL TABLES EXPOSE PROGRESS AS foo.bar;
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR ALL TABLES EXPOSE PROGRESS AS foo.bar
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: Some(Deferred(UnresolvedItemName([Ident("foo"), Ident("bar")]))) })

parse-statement
ALTER CLUSTER foo RENAME TO joe
----
ALTER CLUSTER foo RENAME TO joe
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Cluster, if_exists: false, name: Cluster(Ident("foo")), to_item_name: Ident("joe") })

parse-statement
ALTER CLUSTER IF EXISTS foo RENAME TO joe
----
ALTER CLUSTER IF EXISTS foo RENAME TO joe
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Cluster, if_exists: true, name: Cluster(Ident("foo")), to_item_name: Ident("joe") })

parse-statement
ALTER CLUSTER REPLICA c.foo RENAME TO joe
----
ALTER CLUSTER REPLICA c.foo RENAME TO joe
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: ClusterReplica, if_exists: false, name: ClusterReplica(QualifiedReplica { cluster: Ident("c"), replica: Ident("foo") }), to_item_name: Ident("joe") })

parse-statement
ALTER CLUSTER REPLICA IF EXISTS c.foo RENAME TO joe
----
ALTER CLUSTER REPLICA IF EXISTS c.foo RENAME TO joe
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: ClusterReplica, if_exists: true, name: ClusterReplica(QualifiedReplica { cluster: Ident("c"), replica: Ident("foo") }), to_item_name: Ident("joe") })

parse-statement
DROP OWNED BY joe
----
DROP OWNED BY joe
=>
DropOwned(DropOwnedStatement { role_names: [Ident("joe")], cascade: false })

parse-statement
DROP OWNED BY joe, mike
----
DROP OWNED BY joe, mike
=>
DropOwned(DropOwnedStatement { role_names: [Ident("joe"), Ident("mike")], cascade: false })

parse-statement
DROP OWNED BY joe, mike RESTRICT
----
DROP OWNED BY joe, mike
=>
DropOwned(DropOwnedStatement { role_names: [Ident("joe"), Ident("mike")], cascade: false })

parse-statement
DROP OWNED BY joe, mike CASCADE
----
DROP OWNED BY joe, mike CASCADE
=>
DropOwned(DropOwnedStatement { role_names: [Ident("joe"), Ident("mike")], cascade: true })

parse-statement
ALTER INDEX IF EXISTS alter_index_table_primary_idx SET (RETAIN HISTORY = FOR '1ms')
----
ALTER INDEX IF EXISTS alter_index_table_primary_idx SET (RETAIN HISTORY = FOR '1ms')
=>
AlterIndex(AlterIndexStatement { index_name: UnresolvedItemName([Ident("alter_index_table_primary_idx")]), if_exists: true, action: SetOptions([IndexOption { name: RetainHistory, value: Some(RetainHistoryFor(String("1ms"))) }]) })

parse-statement
ALTER INDEX IF EXISTS alter_index_table_primary_idx RESET (RETAIN HISTORY)
----
ALTER INDEX IF EXISTS alter_index_table_primary_idx RESET (RETAIN HISTORY)
=>
AlterIndex(AlterIndexStatement { index_name: UnresolvedItemName([Ident("alter_index_table_primary_idx")]), if_exists: true, action: ResetOptions([RetainHistory]) })

parse-statement
ALTER CONNECTION IF EXISTS mc RENAME TO ic
----
ALTER CONNECTION IF EXISTS mc RENAME TO ic
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Connection, if_exists: true, name: Item(UnresolvedItemName([Ident("mc")])), to_item_name: Ident("ic") })

parse-statement
ALTER CONNECTION IF EXISTS mc ROTATE KEYS
----
ALTER CONNECTION IF EXISTS mc ROTATE KEYS
=>
AlterConnection(AlterConnectionStatement { name: UnresolvedItemName([Ident("mc")]), if_exists: true, actions: [RotateKeys], with_options: [] })

parse-statement
ALTER CONNECTION IF EXISTS mc ROTATE KEYS WITH (VALIDATE = 'abc')
----
ALTER CONNECTION IF EXISTS mc ROTATE KEYS WITH (VALIDATE = 'abc')
=>
AlterConnection(AlterConnectionStatement { name: UnresolvedItemName([Ident("mc")]), if_exists: true, actions: [RotateKeys], with_options: [AlterConnectionOption { name: Validate, value: Some(Value(String("abc"))) }] })

parse-statement
ALTER CONNECTION IF EXISTS mc ROTATE KEYS WITH (VALIDATE = 'abc'), SET (PROGRESS TOPIC = true),
----
error: Expected end of statement, found comma
ALTER CONNECTION IF EXISTS mc ROTATE KEYS WITH (VALIDATE = 'abc'), SET (PROGRESS TOPIC = true),
                                                                 ^

parse-statement
ALTER CONNECTION IF EXISTS mc SET (PROGRESS TOPIC = true), SET (PROGRESS TOPIC = 'abc'),
----
error: Expected one of ROTATE or SET or RESET or DROP, found EOF
ALTER CONNECTION IF EXISTS mc SET (PROGRESS TOPIC = true), SET (PROGRESS TOPIC = 'abc'),
                                                                                        ^

parse-statement
ALTER CONNECTION IF EXISTS mc SET (BROKER db.schema), RESET (BROKERS = ('abc', def.ghi))
----
error: Expected literal string, found identifier "db"
ALTER CONNECTION IF EXISTS mc SET (BROKER db.schema), RESET (BROKERS = ('abc', def.ghi))
                                          ^

parse-statement
ALTER CONNECTION IF EXISTS mc DROP (BROKER), DROP (BROKER), DROP (BROKER), DROP (BROKER)
----
ALTER CONNECTION IF EXISTS mc DROP (BROKER), DROP (BROKER), DROP (BROKER), DROP (BROKER)
=>
AlterConnection(AlterConnectionStatement { name: UnresolvedItemName([Ident("mc")]), if_exists: true, actions: [DropOption(Broker), DropOption(Broker), DropOption(Broker), DropOption(Broker)], with_options: [] })

parse-statement
ALTER CONNECTION IF EXISTS mc DROP (BROKER), SET (BROKERS = ('abc', def.ghi))
----
error: Expected literal string, found identifier "def"
ALTER CONNECTION IF EXISTS mc DROP (BROKER), SET (BROKERS = ('abc', def.ghi))
                                                                    ^

parse-statement
ALTER CONNECTION IF EXISTS mc DROP (BROKER), SET (BROKERS = ('abc', def.ghi))
----
error: Expected literal string, found identifier "def"
ALTER CONNECTION IF EXISTS mc DROP (BROKER), SET (BROKERS = ('abc', def.ghi))
                                                                    ^

parse-statement
ALTER CONNECTION IF EXISTS mc SET (PORT = 1) WITH (VALIDATE = true)
----
ALTER CONNECTION IF EXISTS mc SET (PORT = 1) WITH (VALIDATE = true)
=>
AlterConnection(AlterConnectionStatement { name: UnresolvedItemName([Ident("mc")]), if_exists: true, actions: [SetOption(ConnectionOption { name: Port, value: Some(Value(Number("1"))) })], with_options: [AlterConnectionOption { name: Validate, value: Some(Value(Boolean(true))) }] })

parse-statement
ALTER CONNECTION IF EXISTS mc RESET (PORT = 1) WITH (VALIDATE = true)
----
error: Expected right parenthesis, found equals sign
ALTER CONNECTION IF EXISTS mc RESET (PORT = 1) WITH (VALIDATE = true)
                                          ^

parse-statement
ALTER CONNECTION IF EXISTS mc DROP (PORT = 1) WITH (VALIDATE = true)
----
error: Expected right parenthesis, found equals sign
ALTER CONNECTION IF EXISTS mc DROP (PORT = 1) WITH (VALIDATE = true)
                                         ^

parse-statement
ALTER CONNECTION IF EXISTS mc SET (PORT = 1) WITH (VALIDATE = true)
----
ALTER CONNECTION IF EXISTS mc SET (PORT = 1) WITH (VALIDATE = true)
=>
AlterConnection(AlterConnectionStatement { name: UnresolvedItemName([Ident("mc")]), if_exists: true, actions: [SetOption(ConnectionOption { name: Port, value: Some(Value(Number("1"))) })], with_options: [AlterConnectionOption { name: Validate, value: Some(Value(Boolean(true))) }] })

parse-statement
VALIDATE CONNECTION kafka_conn
----
VALIDATE CONNECTION kafka_conn
=>
ValidateConnection(ValidateConnectionStatement { name: Name(UnresolvedItemName([Ident("kafka_conn")])) })

parse-statement
INSPECT SHARD 'foo'
----
INSPECT SHARD 'foo'
=>
Show(InspectShard(InspectShardStatement { id: "foo" }))

parse-statement
ALTER MATERIALIZED VIEW snk SET CLUSTER clsname
----
ALTER MATERIALIZED VIEW snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: false, name: UnresolvedItemName([Ident("snk")]), object_type: MaterializedView, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER MATERIALIZED VIEW snk SET CLUSTER db.clsname
----
error: Expected end of statement, found dot
ALTER MATERIALIZED VIEW snk SET CLUSTER db.clsname
                                          ^

parse-statement
ALTER MATERIALIZED VIEW db.snk SET CLUSTER clsname
----
ALTER MATERIALIZED VIEW db.snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: false, name: UnresolvedItemName([Ident("db"), Ident("snk")]), object_type: MaterializedView, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER MATERIALIZED VIEW IF EXISTS snk SET CLUSTER clsname
----
ALTER MATERIALIZED VIEW IF EXISTS snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: true, name: UnresolvedItemName([Ident("snk")]), object_type: MaterializedView, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER MATERIALIZED VIEW snk SET CLUSTER
----
error: Expected identifier, found EOF
ALTER MATERIALIZED VIEW snk SET CLUSTER
                                       ^

parse-statement
ALTER MATERIALIZED VIEW * SET CLUSTER
----
error: Expected identifier, found star
ALTER MATERIALIZED VIEW * SET CLUSTER
                        ^

parse-statement
ALTER SOURCE snk SET CLUSTER clsname
----
ALTER SOURCE snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: false, name: UnresolvedItemName([Ident("snk")]), object_type: Source, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER SOURCE snk SET CLUSTER db.clsname
----
error: Expected end of statement, found dot
ALTER SOURCE snk SET CLUSTER db.clsname
                               ^

parse-statement
ALTER SOURCE db.snk SET CLUSTER clsname
----
ALTER SOURCE db.snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: false, name: UnresolvedItemName([Ident("db"), Ident("snk")]), object_type: Source, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER SOURCE IF EXISTS snk SET CLUSTER clsname
----
ALTER SOURCE IF EXISTS snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: true, name: UnresolvedItemName([Ident("snk")]), object_type: Source, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER SOURCE snk SET CLUSTER
----
error: Expected identifier, found EOF
ALTER SOURCE snk SET CLUSTER
                            ^

parse-statement
ALTER SOURCE * SET CLUSTER
----
error: Expected identifier, found star
ALTER SOURCE * SET CLUSTER
             ^

parse-statement
ALTER SINK snk SET CLUSTER clsname
----
ALTER SINK snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: false, name: UnresolvedItemName([Ident("snk")]), object_type: Sink, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER SINK snk SET CLUSTER db.clsname
----
error: Expected end of statement, found dot
ALTER SINK snk SET CLUSTER db.clsname
                             ^

parse-statement
ALTER SINK db.snk SET CLUSTER clsname
----
ALTER SINK db.snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: false, name: UnresolvedItemName([Ident("db"), Ident("snk")]), object_type: Sink, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER SINK IF EXISTS snk SET CLUSTER clsname
----
ALTER SINK IF EXISTS snk SET CLUSTER clsname
=>
AlterSetCluster(AlterSetClusterStatement { if_exists: true, name: UnresolvedItemName([Ident("snk")]), object_type: Sink, set_cluster: Unresolved(Ident("clsname")) })

parse-statement
ALTER SINK snk SET CLUSTER
----
error: Expected identifier, found EOF
ALTER SINK snk SET CLUSTER
                          ^

parse-statement
ALTER SINK * SET CLUSTER
----
error: Expected identifier, found star
ALTER SINK * SET CLUSTER
           ^

parse-statement
CREATE SOURCE header1 FROM KAFKA CONNECTION conn (TOPIC 'test') FORMAT JSON INCLUDE HEADERS, HEADER 'header3' AS h3, HEADER 'header5' AS h5 BYTES
----
CREATE SOURCE header1 FROM KAFKA CONNECTION conn (TOPIC = 'test') FORMAT JSON INCLUDE HEADERS, HEADER 'header3' AS h3, HEADER 'header5' AS h5 BYTES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("header1")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("test"))) }] }, include_metadata: [Headers { alias: None }, Header { key: "header3", alias: Ident("h3"), use_bytes: false }, Header { key: "header5", alias: Ident("h5"), use_bytes: true }], format: Some(Bare(Json { array: false })), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE header2 FROM KAFKA CONNECTION conn (TOPIC 'test') KEY FORMAT TEXT VALUE FORMAT JSON INCLUDE HEADER 'header1' AS h1, HEADER 'header2' AS h2 BYTES ENVELOPE UPSERT
----
CREATE SOURCE header2 FROM KAFKA CONNECTION conn (TOPIC = 'test') KEY FORMAT TEXT VALUE FORMAT JSON INCLUDE HEADER 'header1' AS h1, HEADER 'header2' AS h2 BYTES ENVELOPE UPSERT
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("header2")]), in_cluster: None, col_names: [], connection: Kafka { connection: Name(UnresolvedItemName([Ident("conn")])), options: [KafkaSourceConfigOption { name: Topic, value: Some(Value(String("test"))) }] }, include_metadata: [Header { key: "header1", alias: Ident("h1"), use_bytes: false }, Header { key: "header2", alias: Ident("h2"), use_bytes: true }], format: Some(KeyValue { key: Text, value: Json { array: false } }), envelope: Some(Upsert), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE s FROM LOAD GENERATOR COUNTER WITH (RETAIN HISTORY FOR '1s');
----
CREATE SOURCE s FROM LOAD GENERATOR COUNTER WITH (RETAIN HISTORY = FOR '1s')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("s")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Counter, options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: RetainHistory, value: Some(RetainHistoryFor(String("1s"))) }], referenced_subsources: None, progress_subsource: None })

parse-statement
ALTER MATERIALIZED VIEW mv SET (RETAIN HISTORY FOR '3m')
----
ALTER MATERIALIZED VIEW mv SET (RETAIN HISTORY FOR '3m')
=>
AlterRetainHistory(AlterRetainHistoryStatement { object_type: MaterializedView, if_exists: false, name: Item(UnresolvedItemName([Ident("mv")])), history: Some(RetainHistoryFor(String("3m"))) })

parse-statement
ALTER MATERIALIZED VIEW mv RESET (RETAIN HISTORY)
----
ALTER MATERIALIZED VIEW mv RESET (RETAIN HISTORY)
=>
AlterRetainHistory(AlterRetainHistoryStatement { object_type: MaterializedView, if_exists: false, name: Item(UnresolvedItemName([Ident("mv")])), history: None })

parse-statement
ALTER SOURCE n RESET (RETAIN HISTORY)
----
ALTER SOURCE n RESET (RETAIN HISTORY)
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: ResetOptions([RetainHistory]) })


parse-statement
ALTER SOURCE n SET (RETAIN HISTORY FOR '1m')
----
ALTER SOURCE n SET (RETAIN HISTORY = FOR '1m')
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: SetOptions([CreateSourceOption { name: RetainHistory, value: Some(RetainHistoryFor(String("1m"))) }]) })


parse-statement
ALTER TABLE n RESET (RETAIN HISTORY)
----
ALTER TABLE n RESET (RETAIN HISTORY)
=>
AlterRetainHistory(AlterRetainHistoryStatement { object_type: Table, if_exists: false, name: Item(UnresolvedItemName([Ident("n")])), history: None })


parse-statement
ALTER TABLE n SET (RETAIN HISTORY FOR '1m')
----
ALTER TABLE n SET (RETAIN HISTORY FOR '1m')
=>
AlterRetainHistory(AlterRetainHistoryStatement { object_type: Table, if_exists: false, name: Item(UnresolvedItemName([Ident("n")])), history: Some(RetainHistoryFor(String("1m"))) })


parse-statement
ALTER INDEX n RESET (RETAIN HISTORY)
----
ALTER INDEX n RESET (RETAIN HISTORY)
=>
AlterIndex(AlterIndexStatement { index_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: ResetOptions([RetainHistory]) })


parse-statement
ALTER INDEX n SET (RETAIN HISTORY FOR '1m')
----
ALTER INDEX n SET (RETAIN HISTORY = FOR '1m')
=>
AlterIndex(AlterIndexStatement { index_name: UnresolvedItemName([Ident("n")]), if_exists: false, action: SetOptions([IndexOption { name: RetainHistory, value: Some(RetainHistoryFor(String("1m"))) }]) })
