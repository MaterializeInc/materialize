# Copyright 2020 sqlparser-rs contributors. All rights reserved.
# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# This file is derived from the sqlparser-rs project, available at
# https://github.com/andygrove/sqlparser-rs. It was incorporated
# directly into Materialize on December 21, 2019.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the LICENSE file at the
# root of this repository, or online at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

parse-statement
CREATE TABLE uk_cities (
    name VARCHAR(100) NOT NULL,
    lat DOUBLE NULL,
    lng DOUBLE,
    constrained INT NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0),
    ref INT REFERENCES othertable (a, b)
)
----
CREATE TABLE uk_cities (name varchar(100) NOT NULL, lat float8 NULL, lng float8, constrained int4 NULL CONSTRAINT pkey PRIMARY KEY NOT NULL UNIQUE CHECK (constrained > 0), ref int4 REFERENCES othertable (a, b))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("uk_cities")]), columns: [ColumnDef { name: Ident("name"), data_type: Other { name: Name(UnresolvedItemName([Ident("varchar")])), typ_mod: [100] }, collation: None, options: [ColumnOptionDef { name: None, option: NotNull }] }, ColumnDef { name: Ident("lat"), data_type: Other { name: Name(UnresolvedItemName([Ident("float8")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }] }, ColumnDef { name: Ident("lng"), data_type: Other { name: Name(UnresolvedItemName([Ident("float8")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("constrained"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: Null }, ColumnOptionDef { name: Some(Ident("pkey")), option: Unique { is_primary: true } }, ColumnOptionDef { name: None, option: NotNull }, ColumnOptionDef { name: None, option: Unique { is_primary: false } }, ColumnOptionDef { name: None, option: Check(Op { op: Op { namespace: [], op: ">" }, expr1: Identifier([Ident("constrained")]), expr2: Some(Value(Number("0"))) }) }] }, ColumnDef { name: Ident("ref"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [ColumnOptionDef { name: None, option: ForeignKey { foreign_table: UnresolvedItemName([Ident("othertable")]), referred_columns: [Ident("a"), Ident("b")] } }] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (a int NOT NULL GARBAGE)
----
error: Expected column option, found identifier "garbage"
CREATE TABLE t (a int NOT NULL GARBAGE)
                               ^

parse-statement
CREATE TABLE t (c int) WITH (foo = 'bar', a = 123)
----
error: Expected end of statement, found WITH
CREATE TABLE t (c int) WITH (foo = 'bar', a = 123)
                       ^

parse-statement
CREATE TABLE types_table (char_col char, bpchar_col bpchar, text_col text, bool_col boolean, date_col date, time_col time, timestamp_col timestamp, uuid_col uuid, double_col double precision);
----
CREATE TABLE types_table (char_col bpchar, bpchar_col bpchar, text_col text, bool_col bool, date_col date, time_col time, timestamp_col timestamp, uuid_col uuid, double_col float8)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("types_table")]), columns: [ColumnDef { name: Ident("char_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("bpchar")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("bpchar_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("bpchar")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("text_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("text")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("bool_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("bool")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("date_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("date")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("time_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("time")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("timestamp_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("timestamp")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("uuid_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("uuid")])), typ_mod: [] }, collation: None, options: [] }, ColumnDef { name: Ident("double_col"), data_type: Other { name: Name(UnresolvedItemName([Ident("float8")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t
----
error: Expected a list of columns in parentheses, found EOF
CREATE TABLE t
              ^

parse-statement
CREATE TABLE t ()
----
CREATE TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t ()
----
CREATE TEMPORARY TABLE t ()
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [], constraints: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE foo (bar int,)
----
error: Expected column name or constraint definition, found right parenthesis
CREATE TABLE foo (bar int,)
                          ^

parse-statement
CREATE TABLE foo (bar int list)
----
CREATE TABLE foo (bar int4 list)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }), collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (bar int list list)
----
CREATE TABLE foo (bar int4 list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("bar"), data_type: List(List(Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] })), collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE tab (foo int,
----
error: Expected column name or constraint definition, found EOF
CREATE TABLE tab (foo int,
                          ^

parse-statement
CREATE TABLE foo (id int, CONSTRAINT address_pkey PRIMARY KEY (address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT address_pkey PRIMARY KEY (address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("address_pkey")), columns: [Ident("address_id")], is_primary: true, nulls_not_distinct: false }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT uk_task UNIQUE (report_date, task_id))
----
CREATE TABLE foo (id int4, CONSTRAINT uk_task UNIQUE (report_date, task_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("uk_task")), columns: [Ident("report_date"), Ident("task_id")], is_primary: false, nulls_not_distinct: false }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT uk_task UNIQUE NULLS NOT DISTINCT (report_date, task_id))
----
CREATE TABLE foo (id int4, CONSTRAINT uk_task UNIQUE NULLS NOT DISTINCT (report_date, task_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: Some(Ident("uk_task")), columns: [Ident("report_date"), Ident("task_id")], is_primary: false, nulls_not_distinct: true }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
----
CREATE TABLE foo (id int4, CONSTRAINT customer_address_id_fkey FOREIGN KEY (address_id) REFERENCES public.address(address_id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: Some(Ident("customer_address_id_fkey")), columns: [Ident("address_id")], foreign_table: Name(UnresolvedItemName([Ident("public"), Ident("address")])), referred_columns: [Ident("address_id")] }], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMPORARY TABLE foo (id int, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
----
CREATE TEMPORARY TABLE foo (id int4, CONSTRAINT ck CHECK (rtrim(ltrim(ref_code)) <> ''))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: Some(Ident("ck")), expr: Op { op: Op { namespace: [], op: "<>" }, expr1: Function(Function { name: UnresolvedItemName([Ident("rtrim")]), args: Args { args: [Function(Function { name: UnresolvedItemName([Ident("ltrim")]), args: Args { args: [Identifier([Ident("ref_code")])], order_by: [] }, filter: None, over: None, distinct: false })], order_by: [] }, filter: None, over: None, distinct: false }), expr2: Some(Value(String(""))) } }], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE foo (id int, PRIMARY KEY (foo, bar))
----
CREATE TABLE foo (id int4, PRIMARY KEY (foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("foo"), Ident("bar")], is_primary: true, nulls_not_distinct: false }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, UNIQUE (id))
----
CREATE TABLE foo (id int4, UNIQUE (id))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Unique { name: None, columns: [Ident("id")], is_primary: false, nulls_not_distinct: false }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
----
CREATE TABLE foo (id int4, FOREIGN KEY (foo, bar) REFERENCES anothertable(foo, bar))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [ForeignKey { name: None, columns: [Ident("foo"), Ident("bar")], foreign_table: Name(UnresolvedItemName([Ident("anothertable")])), referred_columns: [Ident("foo"), Ident("bar")] }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CHECK (end_date > start_date OR end_date IS NULL))
----
CREATE TABLE foo (id int4, CHECK (end_date > start_date OR end_date IS NULL))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: Or { left: Op { op: Op { namespace: [], op: ">" }, expr1: Identifier([Ident("end_date")]), expr2: Some(Identifier([Ident("start_date")])) }, right: IsExpr { expr: Identifier([Ident("end_date")]), construct: Null, negated: false } } }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CHECK (end_date > start_date OR end_date IS UNKNOWN))
----
CREATE TABLE foo (id int4, CHECK (end_date > start_date OR end_date IS UNKNOWN))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: Or { left: Op { op: Op { namespace: [], op: ">" }, expr1: Identifier([Ident("end_date")]), expr2: Some(Identifier([Ident("start_date")])) }, right: IsExpr { expr: Identifier([Ident("end_date")]), construct: Unknown, negated: false } } }], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE foo (id int, CHECK (start_date IS TRUE))
----
CREATE TABLE foo (id int4, CHECK (start_date IS TRUE))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("foo")]), columns: [ColumnDef { name: Ident("id"), data_type: Other { name: Name(UnresolvedItemName([Ident("int4")])), typ_mod: [] }, collation: None, options: [] }], constraints: [Check { name: None, expr: IsExpr { expr: Identifier([Ident("start_date")]), construct: True, negated: false } }], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t (c schema.type)
----
CREATE TEMPORARY TABLE t (c schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE t (c db.schema.type)
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c "db"."schema"."type")
----
CREATE TABLE t (c db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c something.db.schema.type)
----
CREATE TABLE t (c something.db.schema.type)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("something"), Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TEMP TABLE t (c db.schema.type(0,1,100))
----
CREATE TEMPORARY TABLE t (c db.schema.type(0, 1, 100))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("type")])), typ_mod: [0, 1, 100] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: true })

parse-statement
CREATE TABLE t (c time with time zone (0,1,100))
----
error: Expected column option, found left parenthesis
CREATE TABLE t (c time with time zone (0,1,100))
                                      ^

parse-statement
CREATE TABLE t (c t(1+1))
----
error: Expected right parenthesis, found operator "+"
CREATE TABLE t (c t(1+1))
                     ^

parse-statement
CREATE TABLE t (c t(1,))
----
error: Expected literal integer, found right parenthesis
CREATE TABLE t (c t(1,))
                      ^

parse-statement
CREATE TABLE t (c "type"(1))
----
CREATE TABLE t (c type(1))
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: Other { name: Name(UnresolvedItemName([Ident("type")])), typ_mod: [1] }, collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE TABLE t (c "type"(1) list list)
----
CREATE TABLE t (c type(1) list list)
=>
CreateTable(CreateTableStatement { name: UnresolvedItemName([Ident("t")]), columns: [ColumnDef { name: Ident("c"), data_type: List(List(Other { name: Name(UnresolvedItemName([Ident("type")])), typ_mod: [1] })), collation: None, options: [] }], constraints: [], if_not_exists: false, temporary: false })

parse-statement
CREATE DATABASE IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE DATABASE IF EXISTS foo
                   ^

parse-statement
CREATE DATABASE foo.bar
----
error: Expected end of statement, found dot
CREATE DATABASE foo.bar
                   ^

parse-statement
CREATE SCHEMA foo.bar
----
CREATE SCHEMA foo.bar
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedSchemaName([Ident("foo"), Ident("bar")]), if_not_exists: false })

parse-statement
CREATE SCHEMA IF NOT EXISTS foo
----
CREATE SCHEMA IF NOT EXISTS foo
=>
CreateSchema(CreateSchemaStatement { name: UnresolvedSchemaName([Ident("foo")]), if_not_exists: true })

parse-statement
CREATE SCHEMA IF EXISTS foo
----
error: Expected NOT, found EXISTS
CREATE SCHEMA IF EXISTS foo
                 ^

parse-statement
CREATE VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("myschema"), Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: true, definition: ViewDefinition { name: UnresolvedItemName([Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE TEMP VIEW myview AS SELECT foo FROM bar
----
CREATE TEMPORARY VIEW myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: true, definition: ViewDefinition { name: UnresolvedItemName([Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE OR REPLACE VIEW v AS SELECT 1
----
CREATE OR REPLACE VIEW v AS SELECT 1
=>
CreateView(CreateViewStatement { if_exists: Replace, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("v")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE VIEW IF NOT EXISTS v AS SELECT 1
----
CREATE VIEW IF NOT EXISTS v AS SELECT 1
=>
CreateView(CreateViewStatement { if_exists: Skip, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("v")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
----
error: Expected AS, found NOT
CREATE OR REPLACE VIEW IF NOT EXISTS v AS SELECT 1
                          ^

parse-statement
CREATE VIEW v (has, cols) AS SELECT 1, 2
----
CREATE VIEW v (has, cols) AS SELECT 1, 2
=>
CreateView(CreateViewStatement { if_exists: Error, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("v")]), columns: [Ident("has"), Ident("cols")], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }, Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
----
CREATE VIEW IF NOT EXISTS myschema.myview AS SELECT foo FROM bar
=>
CreateView(CreateViewStatement { if_exists: Skip, temporary: false, definition: ViewDefinition { name: UnresolvedItemName([Ident("myschema"), Ident("myview")]), columns: [], query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } } })

parse-statement
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
----
CREATE MATERIALIZED VIEW myschema.myview AS SELECT foo FROM bar
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("myschema"), Ident("myview")]), columns: [], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("bar")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE OR REPLACE MATERIALIZED VIEW v AS SELECT 1
----
CREATE OR REPLACE MATERIALIZED VIEW v AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Replace, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW IF NOT EXISTS v AS SELECT 1
----
CREATE MATERIALIZED VIEW IF NOT EXISTS v AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Skip, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW v (has, cols) AS SELECT 1, 2
----
CREATE MATERIALIZED VIEW v (has, cols) AS SELECT 1, 2
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("v")]), columns: [Ident("has"), Ident("cols")], in_cluster: None, query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }, Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW v IN CLUSTER bar AS SELECT 1
----
CREATE MATERIALIZED VIEW v IN CLUSTER bar AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: Some(Unresolved(Ident("bar"))), query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE MATERIALIZED VIEW v IN CLUSTER [1] AS SELECT 1
----
CREATE MATERIALIZED VIEW v IN CLUSTER [1] AS SELECT 1
=>
CreateMaterializedView(CreateMaterializedViewStatement { if_exists: Error, name: UnresolvedItemName([Ident("v")]), columns: [], in_cluster: Some(Resolved("1")), query: Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } })

parse-statement
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES ('use1-az1', 'use1-az4'))
----
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME = 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES = ('use1-az1', 'use1-az4'))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("privatelinkconn")]), connection: AwsPrivatelink { with_options: [AwsPrivatelinkConnectionOption { name: ServiceName, value: Some(Value(String("com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc"))) }, AwsPrivatelinkConnectionOption { name: AvailabilityZones, value: Some(Sequence([Value(String("use1-az1")), Value(String("use1-az4"))])) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION privatelinkconn FOR AWS PRIVATELINK SERVICE NAME 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES ('use1-az1', 'use1-az4')
----
CREATE CONNECTION privatelinkconn TO AWS PRIVATELINK (SERVICE NAME = 'com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc', AVAILABILITY ZONES = ('use1-az1', 'use1-az4'))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("privatelinkconn")]), connection: AwsPrivatelink { with_options: [AwsPrivatelinkConnectionOption { name: ServiceName, value: Some(Value(String("com.amazonaws.vpce.us-east-1.vpce-svc-0e123abc123198abc"))) }, AwsPrivatelinkConnectionOption { name: AvailabilityZones, value: Some(Sequence([Value(String("use1-az1")), Value(String("use1-az4"))])) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION pgconn FOR postgres HOST foo, PORT 1234, SSL CERTIFICATE AUTHORITY 'foo', SSH TUNNEL tun
----
CREATE CONNECTION pgconn TO POSTGRES (HOST = foo, PORT = 1234, SSL CERTIFICATE AUTHORITY = 'foo', SSH TUNNEL = tun)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("pgconn")]), connection: Postgres { with_options: [PostgresConnectionOption { name: Host, value: Some(Ident(Ident("foo"))) }, PostgresConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, PostgresConnectionOption { name: SslCertificateAuthority, value: Some(Value(String("foo"))) }, PostgresConnectionOption { name: SshTunnel, value: Some(Item(Name(UnresolvedItemName([Ident("tun")])))) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK db.schema.item, PORT 1234)
----
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK = db.schema.item, PORT = 1234)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("pgconn")]), connection: Postgres { with_options: [PostgresConnectionOption { name: AwsPrivatelink, value: Some(Item(Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])))) }, PostgresConnectionOption { name: Port, value: Some(Value(Number("1234"))) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK db.schema.item, PORT 1234, HOST foo)
----
CREATE CONNECTION pgconn TO POSTGRES (AWS PRIVATELINK = db.schema.item, PORT = 1234, HOST = foo)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("pgconn")]), connection: Postgres { with_options: [PostgresConnectionOption { name: AwsPrivatelink, value: Some(Item(Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])))) }, PostgresConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, PostgresConnectionOption { name: Host, value: Some(Ident(Ident("foo"))) }] }, if_not_exists: false })


parse-statement
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red');
----
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("psychic")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (REPLICATION FACTOR = 7, RETENTION MS = 10000, RETENTION BYTES = 10000000000, TOPIC 'topic') FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (REPLICATION FACTOR = 7, RETENTION MS = 10000, RETENTION BYTES = 10000000000, TOPIC = 'topic') FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: ReplicationFactor, value: Some(Value(Number("7"))) }, KafkaConfigOption { name: RetentionMs, value: Some(Value(Number("10000"))) }, KafkaConfigOption { name: RetentionBytes, value: Some(Value(Number("10000000000"))) }, KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: None }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SOURCE psychic IN CLUSTER c FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red');
----
CREATE SOURCE psychic IN CLUSTER c FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("psychic")]), in_cluster: Some(Unresolved(Ident("c"))), col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') KEY (a, b) FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: Some(KafkaSinkKey { key_columns: [Ident("a"), Ident("b")], not_enforced: false }) }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: Some(KafkaSinkKey { key_columns: [Ident("a"), Ident("b")], not_enforced: true }) }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
----
CREATE SINK foo IN CLUSTER c FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') KEY (a, b) NOT ENFORCED FORMAT BYTES
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: Some(Unresolved(Ident("c"))), if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: Some(KafkaSinkKey { key_columns: [Ident("a"), Ident("b")], not_enforced: true }) }, format: Some(Bytes), envelope: None, with_options: [] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) CONSISTENCY (TOPIC 'consistency' FORMAT BYTES) FORMAT BYTES
----
error: Expected end of statement, found identifier "consistency"
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY (a, b) CONSISTENCY (TOPIC 'consistency' FORMAT BYTES) FORMAT BYTES
                                                                              ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY FORMAT BYTES
----
error: Expected end of statement, found KEY
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') KEY FORMAT BYTES
                                                                   ^

parse-statement
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
----
error: Expected NOT, found EXISTS
CREATE SINK IF EXISTS foo FROM bar INTO 'baz'
               ^

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SNAPSHOT = true)
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SNAPSHOT = false)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SNAPSHOT = false)
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(false))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SIZE = 'xlarge')
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SIZE = 'xlarge')
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Size, value: Some(Value(String("xlarge"))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SIZE = 'xlarge', SNAPSHOT = true)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SIZE = 'xlarge', SNAPSHOT = true)
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Size, value: Some(Value(String("xlarge"))) }, CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC 'topic') FORMAT BYTES WITH (SIZE = 'xlarge', SNAPSHOT = true)
----
CREATE SINK foo FROM bar INTO KAFKA CONNECTION baz (TOPIC = 'topic') FORMAT BYTES WITH (SIZE = 'xlarge', SNAPSHOT = true)
=>
CreateSink(CreateSinkStatement { name: UnresolvedItemName([Ident("foo")]), in_cluster: None, if_not_exists: false, from: Name(UnresolvedItemName([Ident("bar")])), connection: Kafka { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("baz")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("topic"))) }] }, key: None }, format: Some(Bytes), envelope: None, with_options: [CreateSinkOption { name: Size, value: Some(Value(String("xlarge"))) }, CreateSinkOption { name: Snapshot, value: Some(Value(Boolean(true))) }] })

parse-statement
CREATE INDEX foo ON myschema.bar (a, b)
----
CREATE INDEX foo ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo ON myschema.bar USING arrangement (a, b)
----
CREATE INDEX foo ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo ON myschema.bar (a, b) WITH (LOGICAL COMPACTION WINDOW = 0)
----
CREATE INDEX foo ON myschema.bar (a, b) WITH (LOGICAL COMPACTION WINDOW = 0)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [IndexOption { name: LogicalCompactionWindow, value: Some(Value(Number("0"))) }], if_not_exists: false })

parse-statement
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
----
CREATE INDEX fizz ON baz (ascii(x), a IS NOT NULL, (EXISTS (SELECT y FROM boop WHERE boop.z = z)), delta)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("fizz")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("baz")])), key_parts: Some([Function(Function { name: UnresolvedItemName([Ident("ascii")]), args: Args { args: [Identifier([Ident("x")])], order_by: [] }, filter: None, over: None, distinct: false }), IsExpr { expr: Identifier([Ident("a")]), construct: Null, negated: true }, Nested(Exists(Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Expr { expr: Identifier([Ident("y")]), alias: None }], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("boop")])), alias: None }, joins: [] }], selection: Some(Op { op: Op { namespace: [], op: "=" }, expr1: Identifier([Ident("boop"), Ident("z")]), expr2: Some(Identifier([Ident("z")])) }), group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None })), Identifier([Ident("delta")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX ind ON tab ((col + 1))
----
CREATE INDEX ind ON tab ((col + 1))
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("ind")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: Some([Nested(Op { op: Op { namespace: [], op: "+" }, expr1: Identifier([Ident("col")]), expr2: Some(Value(Number("1"))) })]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
----
CREATE INDEX qualifiers ON no_parentheses (alpha.omega)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("qualifiers")), in_cluster: None, on_name: Name(UnresolvedItemName([Ident("no_parentheses")])), key_parts: Some([Identifier([Ident("alpha"), Ident("omega")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo IN CLUSTER bar ON myschema.bar (a, b)
----
CREATE INDEX foo IN CLUSTER bar ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: Some(Unresolved(Ident("bar"))), on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX foo IN CLUSTER [1] ON myschema.bar (a, b)
----
CREATE INDEX foo IN CLUSTER [1] ON myschema.bar (a, b)
=>
CreateIndex(CreateIndexStatement { name: Some(Ident("foo")), in_cluster: Some(Resolved("1")), on_name: Name(UnresolvedItemName([Ident("myschema"), Ident("bar")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX ON tab
----
CREATE DEFAULT INDEX ON tab
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: None, with_options: [], if_not_exists: false })

parse-statement
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
----
CREATE DEFAULT INDEX IF NOT EXISTS ON tab
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: None, with_options: [], if_not_exists: true })

parse-statement
CREATE DEFAULT INDEX ON tab (a, b)
----
error: Expected end of statement, found left parenthesis
CREATE DEFAULT INDEX ON tab (a, b)
                            ^

parse-statement
CREATE INDEX ON tab;
----
error: Expected left parenthesis, found semicolon
CREATE INDEX ON tab;
                   ^

parse-statement
CREATE INDEX ON tab (a, b)
----
CREATE INDEX ON tab (a, b)
=>
CreateIndex(CreateIndexStatement { name: None, in_cluster: None, on_name: Name(UnresolvedItemName([Ident("tab")])), key_parts: Some([Identifier([Ident("a")]), Identifier([Ident("b")])]), with_options: [], if_not_exists: false })

parse-statement
CREATE INDEX IF NOT EXISTS ON tab (a, b)
----
error: Expected index name, found ON
CREATE INDEX IF NOT EXISTS ON tab (a, b)
                           ^

parse-statement
CREATE INDEX myschema.ind ON foo(b)
----
error: Expected ON, found dot
CREATE INDEX myschema.ind ON foo(b)
                     ^

parse-statement
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
----
error: Expected NOT, found EXISTS
CREATE INDEX IF EXISTS myschema.ind ON foo(b)
                ^

parse-statement
DROP DATABASE mydb
----
DROP DATABASE mydb
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: false, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: true })

parse-statement
DROP DATABASE IF EXISTS mydb
----
DROP DATABASE IF EXISTS mydb
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: true, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: true })

parse-statement
DROP DATABASE mydb.nope
----
error: Expected end of statement, found dot
DROP DATABASE mydb.nope
                  ^

parse-statement
DROP DATABASE mydb CASCADE
----
DROP DATABASE mydb
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: false, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: true })

parse-statement
DROP DATABASE mydb RESTRICT
----
DROP DATABASE mydb RESTRICT
=>
DropObjects(DropObjectsStatement { object_type: Database, if_exists: false, names: [Database(UnresolvedDatabaseName(Ident("mydb")))], cascade: false })

parse-statement
DROP DATABASE mydb CASCADE RESTRICT
----
error: Cannot specify both CASCADE and RESTRICT in DROP
DROP DATABASE mydb CASCADE RESTRICT
                           ^

parse-statement
DROP DATABASE mydb RESTRICT CASCADE
----
error: Cannot specify both RESTRICT and CASCADE in DROP
DROP DATABASE mydb RESTRICT CASCADE
                            ^

parse-statement
DROP DATABASE mydb CASCADE CASCADE
----
error: Expected end of statement, found CASCADE
DROP DATABASE mydb CASCADE CASCADE
                           ^

parse-statement
DROP SCHEMA mydb.myschema
----
DROP SCHEMA mydb.myschema
=>
DropObjects(DropObjectsStatement { object_type: Schema, if_exists: false, names: [Schema(UnresolvedSchemaName([Ident("mydb"), Ident("myschema")]))], cascade: false })

parse-statement
DROP TABLE foo
----
DROP TABLE foo
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: false, names: [Item(UnresolvedItemName([Ident("foo")]))], cascade: false })

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE
----
DROP TABLE IF EXISTS foo, bar CASCADE
=>
DropObjects(DropObjectsStatement { object_type: Table, if_exists: true, names: [Item(UnresolvedItemName([Ident("foo")])), Item(UnresolvedItemName([Ident("bar")]))], cascade: true })

parse-statement
DROP TABLE
----
error: Expected identifier, found EOF
DROP TABLE
          ^

parse-statement
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
----
error: Cannot specify both CASCADE and RESTRICT in DROP
DROP TABLE IF EXISTS foo, bar CASCADE RESTRICT
                                      ^

parse-statement
DROP VIEW myschema.myview
----
DROP VIEW myschema.myview
=>
DropObjects(DropObjectsStatement { object_type: View, if_exists: false, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("myview")]))], cascade: false })

parse-statement
DROP MATERIALIZED VIEW myschema.myview
----
DROP MATERIALIZED VIEW myschema.myview
=>
DropObjects(DropObjectsStatement { object_type: MaterializedView, if_exists: false, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("myview")]))], cascade: false })

parse-statement
DROP SOURCE myschema.mydatasource
----
DROP SOURCE myschema.mydatasource
=>
DropObjects(DropObjectsStatement { object_type: Source, if_exists: false, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("mydatasource")]))], cascade: false })

parse-statement
DROP INDEX IF EXISTS myschema.myindex
----
DROP INDEX IF EXISTS myschema.myindex
=>
DropObjects(DropObjectsStatement { object_type: Index, if_exists: true, names: [Item(UnresolvedItemName([Ident("myschema"), Ident("myindex")]))], cascade: false })

parse-statement
SUBSCRIBE foo.bar
----
SUBSCRIBE foo.bar
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None })

parse-statement
SUBSCRIBE TO foo.bar
----
SUBSCRIBE foo.bar
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: None })

parse-statement
SUBSCRIBE foo.bar AS OF 123
----
SUBSCRIBE foo.bar AS OF 123
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Value(Number("123")))), up_to: None })

parse-statement
SUBSCRIBE foo.bar AS OF now()
----
SUBSCRIBE foo.bar AS OF now()
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Function(Function { name: UnresolvedItemName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))), up_to: None })

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT) AS OF now()
----
SUBSCRIBE foo.bar WITH (SNAPSHOT) AS OF now()
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [SubscribeOption { name: Snapshot, value: None }], as_of: Some(At(Function(Function { name: UnresolvedItemName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))), up_to: None })

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT = false, TIMESTAMPS) AS OF now()
----
error: Expected one of PROGRESS or SNAPSHOT, found identifier "timestamps"
SUBSCRIBE foo.bar WITH (SNAPSHOT = false, TIMESTAMPS) AS OF now()
                                          ^

parse-statement
SUBSCRIBE foo.bar WITH (SNAPSHOT false)
----
SUBSCRIBE foo.bar WITH (SNAPSHOT = false)
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [SubscribeOption { name: Snapshot, value: Some(Value(Boolean(false))) }], as_of: None, up_to: None })

parse-statement
SUBSCRIBE (SELECT * FROM a)
----
SUBSCRIBE (SELECT * FROM a)
=>
Subscribe(SubscribeStatement { relation: Query(Query { ctes: Simple([]), body: Select(Select { distinct: None, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: Name(UnresolvedItemName([Ident("a")])), alias: None }, joins: [] }], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }), options: [], as_of: None, up_to: None })

parse-statement
SUBSCRIBE foo.bar AS OF now() UP TO now() + interval '1' day
----
SUBSCRIBE foo.bar AS OF now() UP TO now() + INTERVAL '1' DAY
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: Some(At(Function(Function { name: UnresolvedItemName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }))), up_to: Some(Op { op: Op { namespace: [], op: "+" }, expr1: Function(Function { name: UnresolvedItemName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }), expr2: Some(Value(Interval(IntervalValue { value: "1", precision_high: Year, precision_low: Day, fsec_max_precision: None }))) }) })

parse-statement
SUBSCRIBE foo.bar UP TO now() + interval '1' day
----
SUBSCRIBE foo.bar UP TO now() + INTERVAL '1' DAY
=>
Subscribe(SubscribeStatement { relation: Name(Name(UnresolvedItemName([Ident("foo"), Ident("bar")]))), options: [], as_of: None, up_to: Some(Op { op: Op { namespace: [], op: "+" }, expr1: Function(Function { name: UnresolvedItemName([Ident("now")]), args: Args { args: [], order_by: [] }, filter: None, over: None, distinct: false }), expr2: Some(Value(Interval(IntervalValue { value: "1", precision_high: Year, precision_low: Day, fsec_max_precision: None }))) }) })

parse-statement
CREATE TABLE public.customer (
        customer_id integer DEFAULT nextval(public.customer_customer_id_seq),
        store_id smallint NOT NULL,
        first_name character varying(45) NOT NULL,
        last_name character varying(45) COLLATE "es_ES" NOT NULL,
        email character varying(50),
        address_id smallint NOT NULL,
        activebool boolean DEFAULT true NOT NULL,
        create_date date DEFAULT now()::text NOT NULL,
        last_update timestamp without time zone DEFAULT now() NOT NULL,
        last_update_tz timestamp with time zone,
        active integer NOT NULL
) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
----
error: Expected end of statement, found WITH
) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
  ^

parse-statement roundtrip
CREATE TABLE public.customer (
    customer_id int DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
    store_id smallint NOT NULL,
    first_name character varying(45) NOT NULL,
    last_name character varying(45) NOT NULL,
    info text,
    address_id smallint NOT NULL,
    activebool boolean DEFAULT true NOT NULL,
    create_date date DEFAULT now()::date NOT NULL,
    create_date1 date DEFAULT 'now'::text::date NOT NULL,
    last_update timestamp DEFAULT now(),
    active int
)
----
CREATE TABLE public.customer (customer_id int4 DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL, store_id int2 NOT NULL, first_name varchar(45) NOT NULL, last_name varchar(45) NOT NULL, info text, address_id int2 NOT NULL, activebool bool DEFAULT true NOT NULL, create_date date DEFAULT now()::date NOT NULL, create_date1 date DEFAULT 'now'::text::date NOT NULL, last_update timestamp DEFAULT now(), active int4)

parse-statement roundtrip
CREATE TABLE bazaar.settings (
  settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL,
  user_id uuid UNIQUE,
  value text,
  use_metric boolean DEFAULT true
)
----
CREATE TABLE bazaar.settings (settings_id uuid PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL, user_id uuid UNIQUE, value text, use_metric bool DEFAULT true)

parse-statement roundtrip
CREATE TABLE IF NOT EXISTS foo (bar int)
----
CREATE TABLE IF NOT EXISTS foo (bar int4)

parse-statement
ALTER INDEX name SET (property = true)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name SET (property = true)
                      ^

parse-statement
ALTER INDEX name RESET (property)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name RESET (property)
                        ^

parse-statement
ALTER INDEX IF EXISTS name SET (property = true)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX IF EXISTS name SET (property = true)
                                ^

parse-statement
ALTER INDEX name SET ()
----
error: Expected LOGICAL, found right parenthesis
ALTER INDEX name SET ()
                      ^

parse-statement
ALTER INDEX name RESET ()
----
error: Expected LOGICAL, found right parenthesis
ALTER INDEX name RESET ()
                        ^

parse-statement
ALTER INDEX name SET (property)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name SET (property)
                      ^

parse-statement
ALTER INDEX name RESET (property = true)
----
error: Expected LOGICAL, found identifier "property"
ALTER INDEX name RESET (property = true)
                        ^

parse-statement
ALTER SOURCE name SET (property = true)
----
error: Expected one of IGNORE or SIZE or TIMELINE or TIMESTAMP, found identifier "property"
ALTER SOURCE name SET (property = true)
                       ^

parse-statement
ALTER SOURCE name SET (SIZE LARGE)
----
ALTER SOURCE name SET (SIZE = large)
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("name")]), if_exists: false, action: SetOptions([CreateSourceOption { name: Size, value: Some(Ident(Ident("large"))) }]) })

parse-statement
ALTER SOURCE name RESET (SIZE)
----
ALTER SOURCE name RESET (SIZE)
=>
AlterSource(AlterSourceStatement { source_name: UnresolvedItemName([Ident("name")]), if_exists: false, action: ResetOptions([Size]) })


parse-statement
ALTER VIEW name SET (property = true)
----
error: Expected one of RENAME or OWNER, found SET
ALTER VIEW name SET (property = true)
                ^

parse-statement
ALTER MATERIALIZED VIEW name SET (property = true)
----
error: Expected one of RENAME or OWNER, found SET
ALTER MATERIALIZED VIEW name SET (property = true)
                             ^

parse-statement
ALTER SINK name SET (property = true)
----
error: Expected one of SIZE or SNAPSHOT, found identifier "property"
ALTER SINK name SET (property = true)
                     ^

parse-statement
ALTER SINK name SET (SIZE LARGE)
----
ALTER SINK name SET (SIZE = large)
=>
AlterSink(AlterSinkStatement { sink_name: UnresolvedItemName([Ident("name")]), if_exists: false, action: SetOptions([CreateSinkOption { name: Size, value: Some(Ident(Ident("large"))) }]) })

parse-statement
ALTER SINK name RESET (SIZE)
----
ALTER SINK name RESET (SIZE)
=>
AlterSink(AlterSinkStatement { sink_name: UnresolvedItemName([Ident("name")]), if_exists: false, action: ResetOptions([Size]) })

parse-statement
ALTER INDEX name RENAME TO name2
----
ALTER INDEX name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Index, if_exists: false, name: UnresolvedItemName([Ident("name")]), to_item_name: Ident("name2") })

parse-statement
ALTER INDEX i1 misplaced
----
error: Expected one of RESET or SET or RENAME or OWNER, found identifier "misplaced"
ALTER INDEX i1 misplaced
               ^

parse-statement
ALTER INDEX i1
----
error: Expected one of RESET or SET or RENAME or OWNER, found EOF
ALTER INDEX i1
              ^

parse-statement
ALTER VIEW name RENAME TO name2
----
ALTER VIEW name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: View, if_exists: false, name: UnresolvedItemName([Ident("name")]), to_item_name: Ident("name2") })

parse-statement
ALTER MATERIALIZED VIEW name RENAME TO name2
----
ALTER MATERIALIZED VIEW name RENAME TO name2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: MaterializedView, if_exists: false, name: UnresolvedItemName([Ident("name")]), to_item_name: Ident("name2") })

parse-statement
CREATE CLUSTER cluster REPLICAS ()
----
CREATE CLUSTER cluster REPLICAS ()
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([])) }] })

parse-statement
CREATE CLUSTER cluster WITH REPLICAS ()
----
error: Expected REPLICAS, found WITH
CREATE CLUSTER cluster WITH REPLICAS ()
                       ^

parse-statement
CREATE CLUSTER cluster REPLICAS (), BADOPT
----
error: Expected REPLICAS, found identifier "badopt"
CREATE CLUSTER cluster REPLICAS (), BADOPT
                                    ^

parse-statement
CREATE CLUSTER cluster REPLICAS (a (STORAGECTL ADDRESSES ['host1']))
----
CREATE CLUSTER cluster REPLICAS (a (STORAGECTL ADDRESSES = ('host1')))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: StoragectlAddresses, value: Some(Sequence([Value(String("host1"))])) }] }])) }] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (COMPUTECTL ADDRESSES ['host1']), b (SIZE '1'))
----
CREATE CLUSTER cluster REPLICAS (a (COMPUTECTL ADDRESSES = ('host1')), b (SIZE = '1'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: ComputectlAddresses, value: Some(Sequence([Value(String("host1"))])) }] }, ReplicaDefinition { name: Ident("b"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }] }])) }] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (COMPUTE ADDRESSES ['host1'], INTROSPECTION INTERVAL '1s', INTROSPECTION DEBUGGING true), b (SIZE '1', INTROSPECTION INTERVAL 0))
----
CREATE CLUSTER cluster REPLICAS (a (COMPUTE ADDRESSES = ('host1'), INTROSPECTION INTERVAL = '1s', INTROSPECTION DEBUGGING = true), b (SIZE = '1', INTROSPECTION INTERVAL = 0))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: ComputeAddresses, value: Some(Sequence([Value(String("host1"))])) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(String("1s"))) }, ReplicaOption { name: IntrospectionDebugging, value: Some(Value(Boolean(true))) }] }, ReplicaDefinition { name: Ident("b"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(Number("0"))) }] }])) }] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (IDLE ARRANGEMENT MERGE EFFORT = 100), b (SIZE '1', IDLE ARRANGEMENT MERGE EFFORT 0))
----
CREATE CLUSTER cluster REPLICAS (a (IDLE ARRANGEMENT MERGE EFFORT = 100), b (SIZE = '1', IDLE ARRANGEMENT MERGE EFFORT = 0))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: IdleArrangementMergeEffort, value: Some(Value(Number("100"))) }] }, ReplicaDefinition { name: Ident("b"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }, ReplicaOption { name: IdleArrangementMergeEffort, value: Some(Value(Number("0"))) }] }])) }] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (SIZE '1'))
----
CREATE CLUSTER cluster REPLICAS (a (SIZE = '1'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: Size, value: Some(Value(String("1"))) }] }])) }] })

parse-statement
CREATE CLUSTER cluster REPLICAS (a (STORAGECTL ADDRESSES ['123'], STORAGE ADDRESSES ['124'], COMPUTECTL ADDRESSES ['host1:2400', 'host2:2400'], COMPUTE ADDRESSES ['host1:2401', 'host2:2401'], WORKERS '1'))
----
CREATE CLUSTER cluster REPLICAS (a (STORAGECTL ADDRESSES = ('123'), STORAGE ADDRESSES = ('124'), COMPUTECTL ADDRESSES = ('host1:2400', 'host2:2400'), COMPUTE ADDRESSES = ('host1:2401', 'host2:2401'), WORKERS = '1'))
=>
CreateCluster(CreateClusterStatement { name: Ident("cluster"), options: [ClusterOption { name: Replicas, value: Some(ClusterReplicas([ReplicaDefinition { name: Ident("a"), options: [ReplicaOption { name: StoragectlAddresses, value: Some(Sequence([Value(String("123"))])) }, ReplicaOption { name: StorageAddresses, value: Some(Sequence([Value(String("124"))])) }, ReplicaOption { name: ComputectlAddresses, value: Some(Sequence([Value(String("host1:2400")), Value(String("host2:2400"))])) }, ReplicaOption { name: ComputeAddresses, value: Some(Sequence([Value(String("host1:2401")), Value(String("host2:2401"))])) }, ReplicaOption { name: Workers, value: Some(Value(String("1"))) }] }])) }] })

parse-statement
CREATE CLUSTER REPLICA replica
----
error: Expected dot, found EOF
CREATE CLUSTER REPLICA replica
                              ^

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small'
----
CREATE CLUSTER REPLICA default.replica SIZE = 'small'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', AVAILABILITY ZONE 'a'
----
CREATE CLUSTER REPLICA default.replica SIZE = 'small', AVAILABILITY ZONE = 'a'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica AVAILABILITY ZONE 'a', AVAILABILITY ZONE 'b'
----
CREATE CLUSTER REPLICA default.replica AVAILABILITY ZONE = 'a', AVAILABILITY ZONE = 'b'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("b"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', AVAILABILITY ZONE 'a'
----
CREATE CLUSTER REPLICA default.replica SIZE = 'small', AVAILABILITY ZONE = 'a'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: AvailabilityZone, value: Some(Value(String("a"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica SIZE 'small', INTROSPECTION INTERVAL '1s', INTROSPECTION DEBUGGING = false
----
CREATE CLUSTER REPLICA default.replica SIZE = 'small', INTROSPECTION INTERVAL = '1s', INTROSPECTION DEBUGGING = false
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: Size, value: Some(Value(String("small"))) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(String("1s"))) }, ReplicaOption { name: IntrospectionDebugging, value: Some(Value(Boolean(false))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica INTROSPECTION INTERVAL = 0, SIZE 'small'
----
CREATE CLUSTER REPLICA default.replica INTROSPECTION INTERVAL = 0, SIZE = 'small'
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: IntrospectionInterval, value: Some(Value(Number("0"))) }, ReplicaOption { name: Size, value: Some(Value(String("small"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica INTROSPECTION INTERVAL NULL
----
CREATE CLUSTER REPLICA default.replica INTROSPECTION INTERVAL = NULL
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: IntrospectionInterval, value: Some(Value(Null)) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica IDLE ARRANGEMENT MERGE EFFORT = 100
----
CREATE CLUSTER REPLICA default.replica IDLE ARRANGEMENT MERGE EFFORT = 100
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: IdleArrangementMergeEffort, value: Some(Value(Number("100"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica IDLE ARRANGEMENT MERGE EFFORT 0
----
CREATE CLUSTER REPLICA default.replica IDLE ARRANGEMENT MERGE EFFORT = 0
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: IdleArrangementMergeEffort, value: Some(Value(Number("0"))) }] } })

parse-statement
CREATE CLUSTER REPLICA default.replica STORAGECTL ADDRESSES ('1', '2'), COMPUTECTL ADDRESSES ('1', '2'), COMPUTE ADDRESSES ('3', '4'), WORKERS 2, INTROSPECTION INTERVAL = NULL
----
CREATE CLUSTER REPLICA default.replica STORAGECTL ADDRESSES = ('1', '2'), COMPUTECTL ADDRESSES = ('1', '2'), COMPUTE ADDRESSES = ('3', '4'), WORKERS = 2, INTROSPECTION INTERVAL = NULL
=>
CreateClusterReplica(CreateClusterReplicaStatement { of_cluster: Ident("default"), definition: ReplicaDefinition { name: Ident("replica"), options: [ReplicaOption { name: StoragectlAddresses, value: Some(Sequence([Value(String("1")), Value(String("2"))])) }, ReplicaOption { name: ComputectlAddresses, value: Some(Sequence([Value(String("1")), Value(String("2"))])) }, ReplicaOption { name: ComputeAddresses, value: Some(Sequence([Value(String("3")), Value(String("4"))])) }, ReplicaOption { name: Workers, value: Some(Value(Number("2"))) }, ReplicaOption { name: IntrospectionInterval, value: Some(Value(Null)) }] } })


parse-statement
DROP CLUSTER cluster
----
DROP CLUSTER cluster
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: false, names: [Cluster(Ident("cluster"))], cascade: false })

parse-statement
DROP CLUSTER IF EXISTS cluster
----
DROP CLUSTER IF EXISTS cluster
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: true, names: [Cluster(Ident("cluster"))], cascade: false })

parse-statement
DROP CLUSTER IF EXISTS cluster RESTRICT
----
DROP CLUSTER IF EXISTS cluster
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: true, names: [Cluster(Ident("cluster"))], cascade: false })

parse-statement
DROP CLUSTER REPLICA r1, r2
----
error: Expected dot, found comma
DROP CLUSTER REPLICA r1, r2
                       ^

parse-statement
DROP CLUSTER REPLICA IF EXISTS cluster.replica
----
DROP CLUSTER REPLICA IF EXISTS cluster.replica
=>
DropObjects(DropObjectsStatement { object_type: ClusterReplica, if_exists: true, names: [ClusterReplica(QualifiedReplica { cluster: Ident("cluster"), replica: Ident("replica") })], cascade: false })

parse-statement
DROP CLUSTER REPLICA IF EXISTS replica
----
error: Expected dot, found EOF
DROP CLUSTER REPLICA IF EXISTS replica
                                      ^

parse-statement
DROP CLUSTER IF EXISTS cluster CASCADE
----
DROP CLUSTER IF EXISTS cluster CASCADE
=>
DropObjects(DropObjectsStatement { object_type: Cluster, if_exists: true, names: [Cluster(Ident("cluster"))], cascade: true })

parse-statement
CREATE SECRET secret AS decode('c2VjcmV0Cg==', 'base64')
----
CREATE SECRET secret AS decode('c2VjcmV0Cg==', 'base64')
=>
CreateSecret(CreateSecretStatement { name: UnresolvedItemName([Ident("secret")]), if_not_exists: false, value: Function(Function { name: UnresolvedItemName([Ident("decode")]), args: Args { args: [Value(String("c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
CREATE SECRET IF NOT EXISTS secret AS decode('c2VjcmV0Cg==', 'base64')
----
CREATE SECRET IF NOT EXISTS secret AS decode('c2VjcmV0Cg==', 'base64')
=>
CreateSecret(CreateSecretStatement { name: UnresolvedItemName([Ident("secret")]), if_not_exists: true, value: Function(Function { name: UnresolvedItemName([Ident("decode")]), args: Args { args: [Value(String("c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
DROP SECRET secret
----
DROP SECRET secret
=>
DropObjects(DropObjectsStatement { object_type: Secret, if_exists: false, names: [Item(UnresolvedItemName([Ident("secret")]))], cascade: false })

parse-statement
DROP SECRET IF EXISTS secret
----
DROP SECRET IF EXISTS secret
=>
DropObjects(DropObjectsStatement { object_type: Secret, if_exists: true, names: [Item(UnresolvedItemName([Ident("secret")]))], cascade: false })

parse-statement
SHOW SECRETS
----
SHOW SECRETS
=>
Show(ShowObjects(ShowObjectsStatement { object_type: Secret, from: None, filter: None }))

parse-statement
ALTER SECRET secret RENAME TO secret2
----
ALTER SECRET secret RENAME TO secret2
=>
AlterObjectRename(AlterObjectRenameStatement { object_type: Secret, if_exists: false, name: UnresolvedItemName([Ident("secret")]), to_item_name: Ident("secret2") })

parse-statement
ALTER SECRET secret AS decode('new c2VjcmV0Cg==', 'base64')
----
ALTER SECRET secret AS decode('new c2VjcmV0Cg==', 'base64')
=>
AlterSecret(AlterSecretStatement { name: UnresolvedItemName([Ident("secret")]), if_exists: false, value: Function(Function { name: UnresolvedItemName([Ident("decode")]), args: Args { args: [Value(String("new c2VjcmV0Cg==")), Value(String("base64"))], order_by: [] }, filter: None, over: None, distinct: false }) })

parse-statement
CREATE CONNECTION conn1 FOR KAFKA BROKER 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux';
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: Direct })) }, KafkaConnectionOption { name: SslKey, value: Some(Value(String("foo"))) }, KafkaConnectionOption { name: SslCertificate, value: Some(Value(String("qux"))) }] }, if_not_exists: false })

parse-statement roundtrip
CREATE CONNECTION conn1 TO KAFKA (BROKER 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux');
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234', SSL KEY = 'foo', SSL CERTIFICATE = 'qux')

parse-statement
CREATE CONNECTION conn1 FOR KAFKA BROKER 'kafka:1234', PROGRESS TOPIC 'my-materialize-progress-topic';
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234', PROGRESS TOPIC = 'my-materialize-progress-topic')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: Direct })) }, KafkaConnectionOption { name: ProgressTopic, value: Some(Value(String("my-materialize-progress-topic"))) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (BROKER 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1);
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [] }) })) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (BROKER 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093));
----
CREATE CONNECTION conn1 TO KAFKA (BROKER = 'kafka:1234' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Broker, value: Some(ConnectionKafkaBroker(KafkaBroker { address: "kafka:1234", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9093"))) }] }) })) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (
    BROKERS (
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9092),
        'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093),
        'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1
    )
);
----
CREATE CONNECTION conn1 TO KAFKA (BROKERS = ('kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9092), 'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093), 'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Brokers, value: Some(Sequence([ConnectionKafkaBroker(KafkaBroker { address: "kafka:9092", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9092"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9093", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9093"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9094", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [] }) })])) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (
    BROKERS [
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9092),
        'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093),
        'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1
    ]
);
----
CREATE CONNECTION conn1 TO KAFKA (BROKERS = ('kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9092), 'kafka:9093' USING AWS PRIVATELINK aws.privatelink.c1 (PORT 9093), 'kafka:9094' USING AWS PRIVATELINK aws.privatelink.c1))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Brokers, value: Some(Sequence([ConnectionKafkaBroker(KafkaBroker { address: "kafka:9092", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9092"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9093", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [KafkaBrokerAwsPrivatelinkOption { name: Port, value: Some(Value(Number("9093"))) }] }) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9094", tunnel: AwsPrivatelink(KafkaBrokerAwsPrivatelink { connection: Name(UnresolvedItemName([Ident("aws"), Ident("privatelink"), Ident("c1")])), options: [] }) })])) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION conn1 TO KAFKA (
    BROKERS (
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 [PORT 9092],
    )
);
----
error: Expected right parenthesis, found left square bracket
        'kafka:9092' USING AWS PRIVATELINK aws.privatelink.c1 [PORT 9092],
                                                              ^

parse-statement
CREATE CONNECTION conn1 TO KAFKA (
    BROKERS (
        'kafka:9092' USING SSH TUNNEL tunn,
        'kafka:9093' USING SSH TUNNEL tunn
    )
);
----
CREATE CONNECTION conn1 TO KAFKA (BROKERS = ('kafka:9092'USING SSH TUNNEL tunn, 'kafka:9093'USING SSH TUNNEL tunn))
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Kafka { with_options: [KafkaConnectionOption { name: Brokers, value: Some(Sequence([ConnectionKafkaBroker(KafkaBroker { address: "kafka:9092", tunnel: SshTunnel(Name(UnresolvedItemName([Ident("tunn")]))) }), ConnectionKafkaBroker(KafkaBroker { address: "kafka:9093", tunnel: SshTunnel(Name(UnresolvedItemName([Ident("tunn")]))) })])) }] }, if_not_exists: false })

parse-statement
DROP CONNECTION conn1
----
DROP CONNECTION conn1
=>
DropObjects(DropObjectsStatement { object_type: Connection, if_exists: false, names: [Item(UnresolvedItemName([Ident("conn1")]))], cascade: false })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT BYTES
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT BYTES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka(KafkaSourceConnection { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, key: None }), include_metadata: [], format: Bare(Bytes), envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE CONNECTION conn1 FOR CONFLUENT SCHEMA REGISTRY URL 'http://localhost:8081', USERNAME 'user', PASSWORD 'word'
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (URL = 'http://localhost:8081', USERNAME = 'user', PASSWORD = 'word')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Csr { with_options: [CsrConnectionOption { name: Url, value: Some(Value(String("http://localhost:8081"))) }, CsrConnectionOption { name: Username, value: Some(Value(String("user"))) }, CsrConnectionOption { name: Password, value: Some(Value(String("word"))) }] }, if_not_exists: false })

parse-statement roundtrip
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (URL = 'http://localhost:8081', USERNAME = 'user', PASSWORD = 'word')
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (URL = 'http://localhost:8081', USERNAME = 'user', PASSWORD = 'word')


parse-statement
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK db.schema.item, PORT 8080)
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK = db.schema.item, PORT = 8080)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Csr { with_options: [CsrConnectionOption { name: AwsPrivatelink, value: Some(Item(Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])))) }, CsrConnectionOption { name: Port, value: Some(Value(Number("8080"))) }] }, if_not_exists: false })

parse-statement
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (SSH TUNNEL ssh)
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (SSH TUNNEL = ssh)
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Csr { with_options: [CsrConnectionOption { name: SshTunnel, value: Some(Item(Name(UnresolvedItemName([Ident("ssh")])))) }] }, if_not_exists: false })


parse-statement
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK db.schema.item, PORT 8080, URL 'http://localhost:8081')
----
CREATE CONNECTION conn1 TO CONFLUENT SCHEMA REGISTRY (AWS PRIVATELINK = db.schema.item, PORT = 8080, URL = 'http://localhost:8081')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("conn1")]), connection: Csr { with_options: [CsrConnectionOption { name: AwsPrivatelink, value: Some(Item(Name(UnresolvedItemName([Ident("db"), Ident("schema"), Ident("item")])))) }, CsrConnectionOption { name: Port, value: Some(Value(Number("8080"))) }, CsrConnectionOption { name: Url, value: Some(Value(String("http://localhost:8081"))) }] }, if_not_exists: false })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT AVRO USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka(KafkaSourceConnection { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, key: None }), include_metadata: [], format: Bare(Avro(Csr { csr_connection: CsrConnectionAvro { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [] }, key_strategy: None, value_strategy: None, seed: None } })), envelope: Some(Debezium(Plain)), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })


parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
----
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC = 'baz') FORMAT PROTOBUF USING CONFLUENT SCHEMA REGISTRY CONNECTION conn2 ENVELOPE DEBEZIUM
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("src1")]), in_cluster: None, col_names: [], connection: Kafka(KafkaSourceConnection { connection: KafkaConnection { connection: Name(UnresolvedItemName([Ident("conn1")])), options: [KafkaConfigOption { name: Topic, value: Some(Value(String("baz"))) }] }, key: None }), include_metadata: [], format: Bare(Protobuf(Csr { csr_connection: CsrConnectionProtobuf { connection: CsrConnection { connection: Name(UnresolvedItemName([Ident("conn2")])), options: [] }, seed: None } })), envelope: Some(Debezium(Plain)), if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (SOURCE a.b.c, COLLECTION 'foo'))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (SOURCE a.b.c, COLLECTION 'foo'))
                                                                               ^

parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                                               ^

# Note that this will error in planninf, as you cannot specify START OFFSET and START TIMESTAMP at the same time
parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (START OFFSET=1, START TIMESTAMP=2, TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected end of statement, found left parenthesis
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 (START OFFSET=1, START TIMESTAMP=2, TOPIC 'baz') ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                                                                                  ^

# Note that this will error in planning, as START OFFSET must be an array of nums
parse-statement
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 WITH (START OFFSET="hmm") TOPIC 'baz' ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
----
error: Expected one of IGNORE or SIZE or TIMELINE or TIMESTAMP, found START
CREATE SOURCE src1 FROM KAFKA CONNECTION conn1 WITH (START OFFSET="hmm") TOPIC 'baz' ENVELOPE DEBEZIUM (TRANSACTION METADATA (COLLECTION 'foo', SOURCE a.b.c))
                                                     ^

parse-statement
CREATE SOURCE golbat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' KEY FORMAT TEXT VALUE FORMAT TEXT INCLUDE KEY ENVELOPE NONE WITH (SIZE large)
----
error: Expected CONNECTION, found BROKER
CREATE SOURCE golbat FROM KAFKA BROKER 'zubat' TOPIC 'hoothoot' KEY FORMAT TEXT VALUE FORMAT TEXT INCLUDE KEY ENVELOPE NONE WITH (SIZE large)
                                ^

parse-statement
CREATE CONNECTION my_ssh_tunnel FOR SSH TUNNEL HOST 'ssh-bastion', PORT 1234, USER 'blah'
----
CREATE CONNECTION my_ssh_tunnel TO SSH TUNNEL (HOST = 'ssh-bastion', PORT = 1234, USER = 'blah')
=>
CreateConnection(CreateConnectionStatement { name: UnresolvedItemName([Ident("my_ssh_tunnel")]), connection: Ssh { with_options: [SshConnectionOption { name: Host, value: Some(Value(String("ssh-bastion"))) }, SshConnectionOption { name: Port, value: Some(Value(Number("1234"))) }, SshConnectionOption { name: User, value: Some(Value(String("blah"))) }] }, if_not_exists: false })

parse-statement roundtrip
CREATE CONNECTION my_ssh_tunnel TO SSH TUNNEL (HOST 'ssh-bastion', PORT 1234, USER 'blah')
----
CREATE CONNECTION my_ssh_tunnel TO SSH TUNNEL (HOST = 'ssh-bastion', PORT = 1234, USER = 'blah')

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER
----
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Counter, options: [] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER (TICK INTERVAL '1s')
----
CREATE SOURCE lg FROM LOAD GENERATOR COUNTER (TICK INTERVAL = '1s')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("lg")]), in_cluster: None, col_names: [], connection: LoadGenerator { generator: Counter, options: [LoadGeneratorOption { name: TickInterval, value: Some(Value(String("1s"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: None, progress_subsource: None })

parse-statement
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION 'red') with (SIZE 'small');
----
CREATE SOURCE psychic FROM POSTGRES CONNECTION pgconn (PUBLICATION = 'red') WITH (SIZE = 'small')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("psychic")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pgconn")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("red"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Size, value: Some(Value(String("small"))) }], referenced_subsources: None, progress_subsource: None })

parse-statement
ALTER SYSTEM SET wal_level TO logical
----
ALTER SYSTEM SET wal_level = logical
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("wal_level"), to: Values([Ident(Ident("logical"))]) })

parse-statement
ALTER SYSTEM SET wal_level = logical
----
ALTER SYSTEM SET wal_level = logical
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("wal_level"), to: Values([Ident(Ident("logical"))]) })

parse-statement
ALTER SYSTEM SET log_destination TO 'syslog'
----
ALTER SYSTEM SET log_destination = 'syslog'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_destination"), to: Values([Literal(String("syslog"))]) })

parse-statement
ALTER SYSTEM SET log_destination = 'syslog'
----
ALTER SYSTEM SET log_destination = 'syslog'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_destination"), to: Values([Literal(String("syslog"))]) })

parse-statement
ALTER SYSTEM SET shared_buffers TO 42
----
ALTER SYSTEM SET shared_buffers = 42
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("shared_buffers"), to: Values([Literal(Number("42"))]) })

parse-statement
ALTER SYSTEM SET shared_buffers = 42
----
ALTER SYSTEM SET shared_buffers = 42
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("shared_buffers"), to: Values([Literal(Number("42"))]) })

parse-statement
ALTER SYSTEM SET search_path TO default
----
ALTER SYSTEM SET search_path = DEFAULT
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("search_path"), to: Default })

parse-statement
ALTER SYSTEM SET search_path = default
----
ALTER SYSTEM SET search_path = DEFAULT
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("search_path"), to: Default })

parse-statement
ALTER SYSTEM SET log_connections TO 'default'
----
ALTER SYSTEM SET log_connections = 'default'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_connections"), to: Values([Literal(String("default"))]) })

parse-statement
ALTER SYSTEM SET log_connections = 'default'
----
ALTER SYSTEM SET log_connections = 'default'
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("log_connections"), to: Values([Literal(String("default"))]) })

parse-statement
ALTER SYSTEM SET some_array_key = [667, 668]
----
error: Expected variable value, found left square bracket
ALTER SYSTEM SET some_array_key = [667, 668]
                                  ^

parse-statement
ALTER SYSTEM SET quantum_enabled = true
----
ALTER SYSTEM SET quantum_enabled = true
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("quantum_enabled"), to: Values([Literal(Boolean(true))]) })

parse-statement
ALTER SYSTEM SET use_optional = NULL
----
ALTER SYSTEM SET use_optional = NULL
=>
AlterSystemSet(AlterSystemSetStatement { name: Ident("use_optional"), to: Values([Literal(Null)]) })

parse-statement
ALTER SYSTEM SET key value
----
error: Expected TO or equals sign, found VALUE
ALTER SYSTEM SET key value
                     ^

parse-statement
ALTER SYSTEM RESET wal_level
----
ALTER SYSTEM RESET wal_level
=>
AlterSystemReset(AlterSystemResetStatement { name: Ident("wal_level") })

parse-statement
ALTER SYSTEM RESET ALL
----
ALTER SYSTEM RESET ALL
=>
AlterSystemResetAll(AlterSystemResetAllStatement)

parse-statement
ALTER SYSTEM RESET
----
error: Expected identifier, found EOF
ALTER SYSTEM RESET
                  ^

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR ALL TABLES;
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR ALL TABLES
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR SCHEMAS (one, two);
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR SCHEMAS (one, two)
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [], referenced_subsources: Some(SubsetSchemas([Ident("one"), Ident("two")])), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR ALL TABLES WITH (SIZE = 'small');
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR ALL TABLES WITH (SIZE = 'small')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Size, value: Some(Value(String("small"))) }], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (TEXT COLUMNS = [foo, foo.bar, foo.bar.qux, foo.bar.qux.qax, foo.bar.qux.qax.baz]) FOR ALL TABLES WITH (SIZE = 'small');
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (TEXT COLUMNS = (foo, foo.bar, foo.bar.qux, foo.bar.qux.qax, foo.bar.qux.qax.baz)) FOR ALL TABLES WITH (SIZE = 'small')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: TextColumns, value: Some(Sequence([UnresolvedItemName(UnresolvedItemName([Ident("foo")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar"), Ident("qux")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar"), Ident("qux"), Ident("qax")])), UnresolvedItemName(UnresolvedItemName([Ident("foo"), Ident("bar"), Ident("qux"), Ident("qax"), Ident("baz")]))])) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Size, value: Some(Value(String("small"))) }], referenced_subsources: Some(All), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES (foo, bar as qux, baz into zop) WITH (SIZE = 'small');
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR TABLES (foo, bar AS qux, baz AS zop) WITH (SIZE = 'small')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Size, value: Some(Value(String("small"))) }], referenced_subsources: Some(SubsetTables([CreateSourceSubsource { reference: UnresolvedItemName([Ident("foo")]), subsource: None }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("bar")]), subsource: Some(Deferred(UnresolvedItemName([Ident("qux")]))) }, CreateSourceSubsource { reference: UnresolvedItemName([Ident("baz")]), subsource: Some(Deferred(UnresolvedItemName([Ident("zop")]))) }])), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar]) WITH (SIZE = 'small');
----
error: Expected identifier, found left square bracket
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar]) WITH (SIZE = 'small');
                                                                                          ^

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES (baz AS [s1 AS foo.bar]) WITH (SIZE = 'small');
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR TABLES (baz AS [s1 AS foo.bar]) WITH (SIZE = 'small')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Size, value: Some(Value(String("small"))) }], referenced_subsources: Some(SubsetTables([CreateSourceSubsource { reference: UnresolvedItemName([Ident("baz")]), subsource: Some(Named(Id("s1", UnresolvedItemName([Ident("foo"), Ident("bar")])))) }])), progress_subsource: None })

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar] AS baz) WITH (SIZE = 'small');
----
error: Expected identifier, found left square bracket
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR TABLES ([s1 AS foo.bar] AS baz) WITH (SIZE = 'small');
                                                                                          ^

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') WITH (SIZE = 'small') FOR ALL TABLES;
----
error: Expected end of statement, found FOR
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') WITH (SIZE = 'small') FOR ALL TABLES;
                                                                                                    ^

parse-statement
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION 'mz_source') FOR ALL TABLES EXPOSE PROGRESS AS foo.bar WITH (SIZE = 'small');
----
CREATE SOURCE mz_source FROM POSTGRES CONNECTION pg (PUBLICATION = 'mz_source') FOR ALL TABLES EXPOSE PROGRESS AS foo.bar WITH (SIZE = 'small')
=>
CreateSource(CreateSourceStatement { name: UnresolvedItemName([Ident("mz_source")]), in_cluster: None, col_names: [], connection: Postgres { connection: Name(UnresolvedItemName([Ident("pg")])), options: [PgConfigOption { name: Publication, value: Some(Value(String("mz_source"))) }] }, include_metadata: [], format: None, envelope: None, if_not_exists: false, key_constraint: None, with_options: [CreateSourceOption { name: Size, value: Some(Value(String("small"))) }], referenced_subsources: Some(All), progress_subsource: Some(Deferred(UnresolvedItemName([Ident("foo"), Ident("bar")]))) })

parse-statement
GRANT admin TO joe
----
GRANT admin TO joe
=>
GrantRole(GrantRoleStatement { role_name: Ident("admin"), member_names: [Ident("joe")] })

parse-statement
GRANT scientist TO GROUP joseph
----
GRANT scientist TO joseph
=>
GrantRole(GrantRoleStatement { role_name: Ident("scientist"), member_names: [Ident("joseph")] })

parse-statement
GRANT admin TO joe, mike
----
GRANT admin TO joe, mike
=>
GrantRole(GrantRoleStatement { role_name: Ident("admin"), member_names: [Ident("joe"), Ident("mike")] })

parse-statement
GRANT scientist TO GROUP joseph, michael
----
GRANT scientist TO joseph, michael
=>
GrantRole(GrantRoleStatement { role_name: Ident("scientist"), member_names: [Ident("joseph"), Ident("michael")] })

parse-statement
REVOKE doctor FROM joe
----
REVOKE doctor FROM joe
=>
RevokeRole(RevokeRoleStatement { role_name: Ident("doctor"), member_names: [Ident("joe")] })

parse-statement
REVOKE ability_to_practice_law_in_arkansas FROM GROUP joseph
----
REVOKE ability_to_practice_law_in_arkansas FROM joseph
=>
RevokeRole(RevokeRoleStatement { role_name: Ident("ability_to_practice_law_in_arkansas"), member_names: [Ident("joseph")] })

parse-statement
REVOKE doctor FROM joe, mike
----
REVOKE doctor FROM joe, mike
=>
RevokeRole(RevokeRoleStatement { role_name: Ident("doctor"), member_names: [Ident("joe"), Ident("mike")] })

parse-statement
REVOKE ability_to_practice_law_in_arkansas FROM GROUP joseph, michael
----
REVOKE ability_to_practice_law_in_arkansas FROM joseph, michael
=>
RevokeRole(RevokeRoleStatement { role_name: Ident("ability_to_practice_law_in_arkansas"), member_names: [Ident("joseph"), Ident("michael")] })

parse-statement
ALTER CLUSTER foo OWNER TO joe
----
ALTER CLUSTER foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Cluster, if_exists: false, name: Cluster(Ident("foo")), new_owner: Ident("joe") })

parse-statement
ALTER CLUSTER IF EXISTS foo OWNER TO joe
----
ALTER CLUSTER IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Cluster, if_exists: true, name: Cluster(Ident("foo")), new_owner: Ident("joe") })

parse-statement
ALTER CLUSTER REPLICA c.foo OWNER TO joe
----
ALTER CLUSTER REPLICA c.foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: ClusterReplica, if_exists: false, name: ClusterReplica(QualifiedReplica { cluster: Ident("c"), replica: Ident("foo") }), new_owner: Ident("joe") })

parse-statement
ALTER CLUSTER REPLICA IF EXISTS c.foo OWNER TO joe
----
ALTER CLUSTER REPLICA IF EXISTS c.foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: ClusterReplica, if_exists: true, name: ClusterReplica(QualifiedReplica { cluster: Ident("c"), replica: Ident("foo") }), new_owner: Ident("joe") })

parse-statement
ALTER DATABASE foo OWNER TO joe
----
ALTER DATABASE foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Database, if_exists: false, name: Database(UnresolvedDatabaseName(Ident("foo"))), new_owner: Ident("joe") })

parse-statement
ALTER DATABASE IF EXISTS foo OWNER TO joe
----
ALTER DATABASE IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Database, if_exists: true, name: Database(UnresolvedDatabaseName(Ident("foo"))), new_owner: Ident("joe") })

parse-statement
ALTER SCHEMA foo OWNER TO joe
----
ALTER SCHEMA foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Schema, if_exists: false, name: Schema(UnresolvedSchemaName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SCHEMA IF EXISTS foo OWNER TO joe
----
ALTER SCHEMA IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Schema, if_exists: true, name: Schema(UnresolvedSchemaName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SCHEMA bar.foo OWNER TO joe
----
ALTER SCHEMA bar.foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Schema, if_exists: false, name: Schema(UnresolvedSchemaName([Ident("bar"), Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SCHEMA IF EXISTS bar.foo OWNER TO joe
----
ALTER SCHEMA IF EXISTS bar.foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Schema, if_exists: true, name: Schema(UnresolvedSchemaName([Ident("bar"), Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER TABLE foo OWNER TO joe
----
ALTER TABLE foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Table, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER TABLE IF EXISTS foo OWNER TO joe
----
ALTER TABLE IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Table, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SINK foo OWNER TO joe
----
ALTER SINK foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Sink, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SINK IF EXISTS foo OWNER TO joe
----
ALTER SINK IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Sink, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SOURCE foo OWNER TO joe
----
ALTER SOURCE foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Source, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SOURCE IF EXISTS foo OWNER TO joe
----
ALTER SOURCE IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Source, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER INDEX foo OWNER TO joe
----
ALTER INDEX foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Index, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER INDEX IF EXISTS foo OWNER TO joe
----
ALTER INDEX IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Index, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SECRET foo OWNER TO joe
----
ALTER SECRET foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Secret, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER SECRET IF EXISTS foo OWNER TO joe
----
ALTER SECRET IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Secret, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER CONNECTION foo OWNER TO joe
----
ALTER CONNECTION foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Connection, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER CONNECTION IF EXISTS foo OWNER TO joe
----
ALTER CONNECTION IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: Connection, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER VIEW foo OWNER TO joe
----
ALTER VIEW foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: View, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER VIEW IF EXISTS foo OWNER TO joe
----
ALTER VIEW IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: View, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER MATERIALIZED VIEW foo OWNER TO joe
----
ALTER MATERIALIZED VIEW foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: MaterializedView, if_exists: false, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })

parse-statement
ALTER MATERIALIZED VIEW IF EXISTS foo OWNER TO joe
----
ALTER MATERIALIZED VIEW IF EXISTS foo OWNER TO joe
=>
AlterOwner(AlterOwnerStatement { object_type: MaterializedView, if_exists: true, name: Item(UnresolvedItemName([Ident("foo")])), new_owner: Ident("joe") })
