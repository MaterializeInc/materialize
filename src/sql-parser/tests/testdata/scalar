# Copyright 2020 sqlparser-rs contributors. All rights reserved.
# Copyright Materialize, Inc. All rights reserved.
#
# This file is derived from the sqlparser-rs project, available at
# https://github.com/andygrove/sqlparser-rs. It was incorporated
# directly into Materialize on December 21, 2019.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the LICENSE file at the
# root of this repository, or online at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Parameters

parse-scalar
$1
----
Parameter(1)

parse-scalar
$91 + $42
----
Op { op: "+", expr1: Parameter(91), expr2: Some(Parameter(42)) }

parse-scalar
NOT salary = ''
----
Not { expr: Op { op: "=", expr1: Identifier([Ident("salary")]), expr2: Some(Value(String(""))) } }

parse-scalar
salary <> 'Not Provided' AND salary <> ''
----
And { left: Op { op: "<>", expr1: Identifier([Ident("salary")]), expr2: Some(Value(String("Not Provided"))) }, right: Op { op: "<>", expr1: Identifier([Ident("salary")]), expr2: Some(Value(String(""))) } }

parse-scalar
name LIKE '%a'
----
Op { op: "~~", expr1: Identifier([Ident("name")]), expr2: Some(Value(String("%a"))) }

parse-scalar
name NOT LIKE '%a'
----
Op { op: "!~~", expr1: Identifier([Ident("name")]), expr2: Some(Value(String("%a"))) }

parse-scalar
name LIKE '%a' IS NULL
----
IsNull { expr: Op { op: "~~", expr1: Identifier([Ident("name")]), expr2: Some(Value(String("%a"))) }, negated: false }

parse-scalar
name NOT LIKE '%a' IS NULL
----
IsNull { expr: Op { op: "!~~", expr1: Identifier([Ident("name")]), expr2: Some(Value(String("%a"))) }, negated: false }

parse-scalar
a ~ 'foo'
----
Op { op: "~", expr1: Identifier([Ident("a")]), expr2: Some(Value(String("foo"))) }

parse-scalar
a ~* 'foo'
----
Op { op: "~*", expr1: Identifier([Ident("a")]), expr2: Some(Value(String("foo"))) }

parse-scalar
a !~ 'foo'
----
Op { op: "!~", expr1: Identifier([Ident("a")]), expr2: Some(Value(String("foo"))) }

parse-scalar
a !~* 'foo'
----
Op { op: "!~*", expr1: Identifier([Ident("a")]), expr2: Some(Value(String("foo"))) }

parse-scalar
a !x 'foo'
----
Op { op: "!", expr1: Identifier([Ident("a")]), expr2: Some(Cast { expr: Value(String("foo")), data_type: Other { name: Name(UnresolvedObjectName([Ident("x")])), typ_mod: [] } }) }

parse-scalar
a !x
----
Op { op: "!", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("x")])) }

# Casts

parse-scalar roundtrip
id::bigint
----
id::int8

parse-scalar roundtrip
CAST(id AS BIGINT)
----
id::int8

parse-scalar roundtrip
id::double precision
----
id::float8

parse-scalar roundtrip
id::timestamp with time zone
----
id::timestamptz

parse-scalar roundtrip
(id::timestamp with time zone::timestamp without time zone  )  ::  double precision::text
----
(id::timestamptz::timestamp)::float8::text

parse-scalar roundtrip
CAST(c::jsonb->>'f' AS timestamptz)
----
(c::jsonb ->> 'f')::timestamptz

parse-scalar roundtrip
id::numeric FROM customer
----
error: extra token after expression
id::numeric FROM customer
            ^

parse-scalar roundtrip
CAST(id AS dec)
----
id::numeric

parse-scalar roundtrip
CAST(id AS decimal)
----
id::numeric

# Extract

parse-scalar
EXTRACT(YEAR FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("year")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(MILLENIUM FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("millenium")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(CENTURY FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("century")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(YEAR FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("year")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(ISOYEAR FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("isoyear")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(QUARTER FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("quarter")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(MONTH FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("month")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(DAY FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("day")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(HOUR FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("hour")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(MINUTE FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("minute")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(SECOND FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("second")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(MILLISECONDS FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("milliseconds")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(MICROSECONDS FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("microseconds")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(TIMEZONE FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("timezone")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(TIMEZONE_HOUR FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("timezone_hour")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(TIMEZONE_MINUTE FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("timezone_minute")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(WEEK FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("week")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(DOY FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("doy")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(DOW FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("dow")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(ISODOW FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("isodow")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
EXTRACT(EPOCH FROM d)
----
Function(Function { name: UnresolvedObjectName([Ident("date_part")]), args: Args([Value(String("epoch")), Identifier([Ident("d")])]), filter: None, over: None, distinct: false })

parse-scalar
COALESCE(foo, bar)
----
Coalesce { exprs: [Identifier([Ident("foo")]), Identifier([Ident("bar")])] }

parse-scalar
COALESCE()
----
error: Expected an expression, found right parenthesis
COALESCE()
         ^


parse-scalar
sqrt(id)
----
Function(Function { name: UnresolvedObjectName([Ident("sqrt")]), args: Args([Identifier([Ident("id")])]), filter: None, over: None, distinct: false })

parse-scalar roundtrip
(a + b) - (c + d)
----
(a + b) - (c + d)

parse-scalar roundtrip
CASE WHEN bar IS NULL THEN 'null' WHEN bar = 0 THEN '=0' WHEN bar >= 0 THEN '>=0' ELSE '<0' END
----
CASE WHEN bar IS NULL THEN 'null' WHEN bar = 0 THEN '=0' WHEN bar >= 0 THEN '>=0' ELSE '<0' END

parse-scalar
CASE foo WHEN 1 THEN 'Y' ELSE 'N' END
----
Case { operand: Some(Identifier([Ident("foo")])), conditions: [Value(Number("1"))], results: [Value(String("Y"))], else_result: Some(Value(String("N"))) }

parse-scalar
(SELECT 1) + (SELECT 2)
----
Op { op: "+", expr1: Subquery(Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None }), expr2: Some(Subquery(Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None })) }

parse-scalar
1 < ANY (SELECT 2)
----
AnySubquery { left: Value(Number("1")), op: "<", right: Query { ctes: [], body: Select(Select { distinct: None, projection: [Expr { expr: Value(Number("2")), alias: None }], from: [], selection: None, group_by: [], having: None, options: [] }), order_by: [], limit: None, offset: None } }

parse-scalar
1 < ANY (fn())
----
AnyExpr { left: Value(Number("1")), op: "<", right: Function(Function { name: UnresolvedObjectName([Ident("fn")]), args: Args([]), filter: None, over: None, distinct: false }) }

parse-scalar
LIST[]
----
List([])

parse-scalar
LIST[1, 'foo']
----
List([Value(Number("1")), Value(String("foo"))])

parse-scalar
LIST[LIST[1 + 1, 2], a || b]
----
List([List([Op { op: "+", expr1: Value(Number("1")), expr2: Some(Value(Number("1"))) }, Value(Number("2"))]), Op { op: "||", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }])

parse-scalar
LIST[1,2,3][1]
----
SubscriptIndex { expr: List([Value(Number("1")), Value(Number("2")), Value(Number("3"))]), subscript: Value(Number("1")) }

parse-scalar
LIST[1,2,3][1:1]
----
SubscriptSlice { expr: List([Value(Number("1")), Value(Number("2")), Value(Number("3"))]), positions: [SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }] }

parse-scalar
LIST[1,2,3][:1]
----
SubscriptSlice { expr: List([Value(Number("1")), Value(Number("2")), Value(Number("3"))]), positions: [SubscriptPosition { start: None, end: Some(Value(Number("1"))) }] }

parse-scalar
LIST[1,2,3][1:]
----
SubscriptSlice { expr: List([Value(Number("1")), Value(Number("2")), Value(Number("3"))]), positions: [SubscriptPosition { start: Some(Value(Number("1"))), end: None }] }

parse-scalar
LIST[[1],[2],[3]][1:1, 1:1]
----
SubscriptSlice { expr: List([List([Value(Number("1"))]), List([Value(Number("2"))]), List([Value(Number("3"))])]), positions: [SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }, SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }] }

parse-scalar
LIST[[1],[2],[3]][1:1, 1:1][1]
----
SubscriptIndex { expr: SubscriptSlice { expr: List([List([Value(Number("1"))]), List([Value(Number("2"))]), List([Value(Number("3"))])]), positions: [SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }, SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }] }, subscript: Value(Number("1")) }

parse-scalar
LIST[[1],[2],[3]][1:1, 1:1, 1:1]
----
SubscriptSlice { expr: List([List([Value(Number("1"))]), List([Value(Number("2"))]), List([Value(Number("3"))])]), positions: [SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }, SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }, SubscriptPosition { start: Some(Value(Number("1"))), end: Some(Value(Number("1"))) }] }

parse-scalar
ARRAY[]::int[]
----
Cast { expr: Array([]), data_type: Array(Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }) }

parse-scalar
ARRAY[]::int[][][][]
----
Cast { expr: Array([]), data_type: Array(Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }) }

parse-scalar
ARRAY[]::int[2][2]
----
Cast { expr: Array([]), data_type: Array(Other { name: Name(UnresolvedObjectName([Ident("int4")])), typ_mod: [] }) }

parse-scalar
a -> b
----
Op { op: "->", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a ->> b
----
Op { op: "->>", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a #> b
----
Op { op: "#>", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a #>> b
----
Op { op: "#>>", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a @> b
----
Op { op: "@>", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a <@ b
----
Op { op: "<@", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a ? b
----
Op { op: "?", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a ?| b
----
Op { op: "?|", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a ?& b
----
Op { op: "?&", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a || b
----
Op { op: "||", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a #- b
----
Op { op: "#-", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a @? b
----
Op { op: "@?", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

parse-scalar
a @@ b
----
Op { op: "@@", expr1: Identifier([Ident("a")]), expr2: Some(Identifier([Ident("b")])) }

# Strange operator constructions.

parse-scalar
1*-1
----
Op { op: "*", expr1: Value(Number("1")), expr2: Some(Value(Number("-1"))) }

parse-scalar
1+-1
----
Op { op: "+", expr1: Value(Number("1")), expr2: Some(Value(Number("-1"))) }

parse-scalar
1+-00.00
----
Op { op: "+", expr1: Value(Number("1")), expr2: Some(Op { op: "-", expr1: Value(Number("00.00")), expr2: None }) }

parse-scalar
1+-a
----
Op { op: "+", expr1: Value(Number("1")), expr2: Some(Op { op: "-", expr1: Identifier([Ident("a")]), expr2: None }) }

parse-scalar
1@+2
----
Op { op: "@+", expr1: Value(Number("1")), expr2: Some(Value(Number("2"))) }

parse-scalar
1</*embedded comment*/2
----
Op { op: "<", expr1: Value(Number("1")), expr2: Some(Value(Number("2"))) }

parse-scalar
(x).a
----
FieldAccess { expr: Nested(Identifier([Ident("x")])), field: Ident("a") }

parse-scalar
(x).a.b.c
----
FieldAccess { expr: FieldAccess { expr: FieldAccess { expr: Nested(Identifier([Ident("x")])), field: Ident("a") }, field: Ident("b") }, field: Ident("c") }

parse-scalar
((x).a.b.c)
----
Nested(FieldAccess { expr: FieldAccess { expr: FieldAccess { expr: Nested(Identifier([Ident("x")])), field: Ident("a") }, field: Ident("b") }, field: Ident("c") })

parse-scalar
(((x).a.b).c)
----
Nested(FieldAccess { expr: Nested(FieldAccess { expr: FieldAccess { expr: Nested(Identifier([Ident("x")])), field: Ident("a") }, field: Ident("b") }), field: Ident("c") })

parse-scalar
(((x).a.b)[1].c)
----
Nested(FieldAccess { expr: SubscriptIndex { expr: Nested(FieldAccess { expr: FieldAccess { expr: Nested(Identifier([Ident("x")])), field: Ident("a") }, field: Ident("b") }), subscript: Value(Number("1")) }, field: Ident("c") })

parse-scalar roundtrip
(((x).a.b)[1].c)
----
(((x).a.b)[1].c)

parse-scalar
(1.a)
----
error: Expected right parenthesis, found identifier 'a'
(1.a)
   ^

parse-scalar
(x).*.*
----
WildcardAccess(WildcardAccess(Nested(Identifier([Ident("x")]))))

parse-scalar
((x).*.*)
----
Nested(WildcardAccess(WildcardAccess(Nested(Identifier([Ident("x")])))))

# Special position syntax

parse-scalar
position('om' IN 'Thomas')
----
Function(Function { name: UnresolvedObjectName([Ident("position")]), args: Args([Value(String("om")), Value(String("Thomas"))]), filter: None, over: None, distinct: false })

parse-scalar
"position"('om', 'Thomas')
----
Function(Function { name: UnresolvedObjectName([Ident("position")]), args: Args([Value(String("om")), Value(String("Thomas"))]), filter: None, over: None, distinct: false })

parse-scalar
position('om', 'Thomas')
----
error: Expected IN, found comma
position('om', 'Thomas')
             ^
