# Copyright 2020 sqlparser-rs contributors. All rights reserved.
# Copyright Materialize, Inc. All rights reserved.
#
# This file is derived from the sqlparser-rs project, available at
# https://github.com/andygrove/sqlparser-rs. It was incorporated
# directly into Materialize on December 21, 2019.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the LICENSE file at the
# root of this repository, or online at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

parse-statement roundtrip
SELECT 1
----
SELECT 1

parse-statement roundtrip
(SELECT 1)
----
(SELECT 1)

parse-statement roundtrip
((SELECT 1))
----
((SELECT 1))

parse-statement roundtrip
VALUES (1)
----
VALUES (1)

parse-statement roundtrip
SELECT (1)
----
SELECT (1)

parse-statement roundtrip
SELECT (1, 2)
----
SELECT ROW(1, 2)

parse-statement roundtrip
SELECT (1, 2)
----
SELECT ROW(1, 2)

parse-statement roundtrip
SELECT ROW()
----
SELECT ROW()

parse-statement roundtrip
SELECT ROW(1)
----
SELECT ROW(1)

parse-statement roundtrip
SELECT ROW(1, 2)
----
SELECT ROW(1, 2)

parse-statement
SELECT id, fname, lname FROM customer WHERE id = 1 LIMIT 5
----
SELECT id, fname, lname FROM customer WHERE id = 1 LIMIT 5
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("id")]), alias: None }, Expr { expr: Identifier([Ident("fname")]), alias: None }, Expr { expr: Identifier([Ident("lname")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("id")]), op: Eq, right: Value(Number("1")) }), group_by: [], having: None }), order_by: [], limit: Some(Value(Number("5"))), offset: None, fetch: None }, as_of: None }

# LIMIT should not be parsed as an alias.

parse-statement
SELECT id FROM customer LIMIT 1
----
SELECT id FROM customer LIMIT 1
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("id")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: Some(Value(Number("1"))), offset: None, fetch: None }, as_of: None }

parse-statement
SELECT 1 LIMIT 5
----
SELECT 1 LIMIT 5
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(Number("1")), alias: None }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: Some(Value(Number("5"))), offset: None, fetch: None }, as_of: None }

parse-statement
SELECT DISTINCT name FROM customer
----
SELECT DISTINCT name FROM customer
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: true, projection: [Expr { expr: Identifier([Ident("name")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement roundtrip
SELECT ALL name FROM customer
----
SELECT name FROM customer

parse-statement
SELECT * FROM foo
----
SELECT * FROM foo
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("foo")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT foo.* FROM foo
----
SELECT foo.* FROM foo
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: QualifiedWildcard([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("foo")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT (x).a, (x).a.b.c
----
SELECT (x).a, (x).a.b.c
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: FieldAccess { expr: Nested(Identifier([Ident("x")])), field: Ident("a") }, alias: None }, Expr { expr: FieldAccess { expr: FieldAccess { expr: FieldAccess { expr: Nested(Identifier([Ident("x")])), field: Ident("a") }, field: Ident("b") }, field: Ident("c") }, alias: None }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT (1.a)
----
error:
Parse error:
SELECT (1.a)
          ^
Expected ), found: a

parse-statement
SELECT (x).*.*
----
error:
Parse error:
SELECT (x).*.*
            ^
Expected end of statement, found: .

parse-statement roundtrip
SELECT count(employee.*) FROM "order" JOIN employee ON "order".employee = employee.id
----
SELECT count(employee.*) FROM "order" JOIN employee ON "order".employee = employee.id

parse-statement
SELECT a.col + 1 AS newname FROM foo AS a
----
SELECT a.col + 1 AS newname FROM foo AS a
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: BinaryOp { left: Identifier([Ident("a"), Ident("col")]), op: Plus, right: Value(Number("1")) }, alias: Some(Ident("newname")) }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("foo")]), alias: Some(TableAlias { name: Ident("a"), columns: [], strict: false }) }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement roundtrip
SELECT a.col + 1 AS newname FROM foo AS a
----
SELECT a.col + 1 AS newname FROM foo AS a

parse-statement roundtrip
SELECT a.col + 1 newname FROM foo AS a
----
SELECT a.col + 1 AS newname FROM foo AS a

parse-statement roundtrip
SELECT concat('CONCAT', ' ', 'function')
----
SELECT concat('CONCAT', ' ', 'function')

parse-statement roundtrip
SELECT concat(first_name, ' ', last_name) FROM customer
----
SELECT concat(first_name, ' ', last_name) FROM customer

parse-statement roundtrip
SELECT concat('Concat with ', NULL) AS result_string
----
SELECT concat('Concat with ', NULL) AS result_string

parse-statement roundtrip
SELECT first_name, concat('A', 3, 'chars') FROM customer
----
SELECT first_name, concat('A', 3, 'chars') FROM customer

parse-statement roundtrip
SELECT count(*) FROM customer
----
SELECT count(*) FROM customer

parse-statement
SELECT count(*) FILTER (WHERE foo) FROM customer
----
SELECT count(*) FILTER (WHERE foo) FROM customer
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Function(Function { name: ObjectName([Ident("count")]), args: Star, filter: Some(Identifier([Ident("foo")])), over: None, distinct: false }), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT count(DISTINCT + x) FROM customer
----
SELECT count(DISTINCT + x) FROM customer
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Function(Function { name: ObjectName([Ident("count")]), args: Args([UnaryOp { op: Plus, expr: Identifier([Ident("x")]) }]), filter: None, over: None, distinct: true }), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement roundtrip
SELECT count(ALL + x) FROM customer
----
SELECT count(+ x) FROM customer

parse-statement roundtrip
SELECT count(+ x) FROM customer
----
SELECT count(+ x) FROM customer

# Parameters

parse-statement
SELECT $
----
error:
Parse error:
SELECT $
       ^
parameter marker ($) was not followed by at least one digit

parse-statement
SELECT $q
----
error:
Parse error:
SELECT $q
       ^^
parameter marker ($) was not followed by at least one digit

parse-statement
SELECT $1$2
----
error:
Parse error:
SELECT $1$2
         ^^
Expected end of statement, found: $2

parse-statement
SELECT $18446744073709551616
----
error:
Parse error:
SELECT $18446744073709551616
       ^^^^^^^^^^^^^^^^^^^^^
unable to parse parameter: number too large to fit in target type

parse-statement
SELECT c FROM t WHERE c NOT (
----
error:
Parse error:
SELECT c FROM t WHERE c NOT (
                        ^^^
Expected end of statement, found: NOT

parse-statement roundtrip
SELECT name COLLATE "de_DE" FROM customer
----
SELECT name COLLATE "de_DE" FROM customer

parse-statement roundtrip
SELECT customer.address.state FROM foo
----
SELECT customer.address.state FROM foo

parse-statement
SELECT * FROM customers WHERE segment IN (SELECT segm FROM bar)
----
SELECT * FROM customers WHERE segment IN (SELECT segm FROM bar)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customers")]), alias: None }, joins: [] }], selection: Some(InSubquery { expr: Identifier([Ident("segment")]), subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("segm")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, negated: false }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t WHERE x IN (VALUES (1))
----
SELECT * FROM t WHERE x IN (VALUES (1))
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t")]), alias: None }, joins: [] }], selection: Some(InSubquery { expr: Identifier([Ident("x")]), subquery: Query { ctes: [], body: Values(Values([[Value(Number("1"))]])), order_by: [], limit: None, offset: None, fetch: None }, negated: false }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM customers WHERE age BETWEEN 25 AND 32
----
SELECT * FROM customers WHERE age BETWEEN 25 AND 32
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customers")]), alias: None }, joins: [] }], selection: Some(Between { expr: Identifier([Ident("age")]), negated: false, low: Value(Number("25")), high: Value(Number("32")) }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM customers WHERE age NOT BETWEEN 25 AND 32
----
SELECT * FROM customers WHERE age NOT BETWEEN 25 AND 32
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customers")]), alias: None }, joins: [] }], selection: Some(Between { expr: Identifier([Ident("age")]), negated: true, low: Value(Number("25")), high: Value(Number("32")) }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t WHERE 1 BETWEEN 1 + 2 AND 3 + 4 IS NULL
----
SELECT * FROM t WHERE 1 BETWEEN 1 + 2 AND 3 + 4 IS NULL
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t")]), alias: None }, joins: [] }], selection: Some(IsNull { expr: Between { expr: Value(Number("1")), negated: false, low: BinaryOp { left: Value(Number("1")), op: Plus, right: Value(Number("2")) }, high: BinaryOp { left: Value(Number("3")), op: Plus, right: Value(Number("4")) } }, negated: false }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t WHERE 1 = 1 AND 1 + x BETWEEN 1 AND 2
----
SELECT * FROM t WHERE 1 = 1 AND 1 + x BETWEEN 1 AND 2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: BinaryOp { left: Value(Number("1")), op: Eq, right: Value(Number("1")) }, op: And, right: Between { expr: BinaryOp { left: Value(Number("1")), op: Plus, right: Identifier([Ident("x")]) }, negated: false, low: Value(Number("1")), high: Value(Number("2")) } }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t WHERE 1 = 1 AND 1 + x BETWEEN 1 AND 2
----
SELECT * FROM t WHERE 1 = 1 AND 1 + x BETWEEN 1 AND 2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: BinaryOp { left: Value(Number("1")), op: Eq, right: Value(Number("1")) }, op: And, right: Between { expr: BinaryOp { left: Value(Number("1")), op: Plus, right: Identifier([Ident("x")]) }, negated: false, low: Value(Number("1")), high: Value(Number("2")) } }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT id, fname, lname FROM customer WHERE id < 5 ORDER BY lname ASC, fname DESC, id
----
SELECT id, fname, lname FROM customer WHERE id < 5 ORDER BY lname ASC, fname DESC, id
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("id")]), alias: None }, Expr { expr: Identifier([Ident("fname")]), alias: None }, Expr { expr: Identifier([Ident("lname")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("id")]), op: Lt, right: Value(Number("5")) }), group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("lname")]), asc: Some(true) }, OrderByExpr { expr: Identifier([Ident("fname")]), asc: Some(false) }, OrderByExpr { expr: Identifier([Ident("id")]), asc: None }], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT id, fname, lname FROM customer ORDER BY lname ASC, fname DESC, id
----
SELECT id, fname, lname FROM customer ORDER BY lname ASC, fname DESC, id
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("id")]), alias: None }, Expr { expr: Identifier([Ident("fname")]), alias: None }, Expr { expr: Identifier([Ident("lname")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("lname")]), asc: Some(true) }, OrderByExpr { expr: Identifier([Ident("fname")]), asc: Some(false) }, OrderByExpr { expr: Identifier([Ident("id")]), asc: None }], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT id, fname, lname FROM customer ORDER BY lname ASC, fname DESC, id
----
SELECT id, fname, lname FROM customer ORDER BY lname ASC, fname DESC, id
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("id")]), alias: None }, Expr { expr: Identifier([Ident("fname")]), alias: None }, Expr { expr: Identifier([Ident("lname")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("lname")]), asc: Some(true) }, OrderByExpr { expr: Identifier([Ident("fname")]), asc: Some(false) }, OrderByExpr { expr: Identifier([Ident("id")]), asc: None }], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT id, fname, lname FROM customer WHERE id < 5
ORDER BY lname ASC, fname DESC LIMIT 2
----
SELECT id, fname, lname FROM customer WHERE id < 5 ORDER BY lname ASC, fname DESC LIMIT 2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("id")]), alias: None }, Expr { expr: Identifier([Ident("fname")]), alias: None }, Expr { expr: Identifier([Ident("lname")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("id")]), op: Lt, right: Value(Number("5")) }), group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("lname")]), asc: Some(true) }, OrderByExpr { expr: Identifier([Ident("fname")]), asc: Some(false) }], limit: Some(Value(Number("2"))), offset: None, fetch: None }, as_of: None }

parse-statement
SELECT id, fname, lname FROM customer GROUP BY lname, fname
----
SELECT id, fname, lname FROM customer GROUP BY lname, fname
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("id")]), alias: None }, Expr { expr: Identifier([Ident("fname")]), alias: None }, Expr { expr: Identifier([Ident("lname")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [] }], selection: None, group_by: [Identifier([Ident("lname")]), Identifier([Ident("fname")])], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar GROUP BY foo HAVING count(*) > 1
----
SELECT foo FROM bar GROUP BY foo HAVING count(*) > 1
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [Identifier([Ident("foo")])], having: Some(BinaryOp { left: Function(Function { name: ObjectName([Ident("count")]), args: Star, filter: None, over: None, distinct: false }), op: Gt, right: Value(Number("1")) }) }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar GROUP BY foo HAVING count(*) > 1
----
SELECT foo FROM bar GROUP BY foo HAVING count(*) > 1
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [Identifier([Ident("foo")])], having: Some(BinaryOp { left: Function(Function { name: ObjectName([Ident("count")]), args: Star, filter: None, over: None, distinct: false }), op: Gt, right: Value(Number("1")) }) }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar GROUP BY foo HAVING 1 = 1
----
SELECT foo FROM bar GROUP BY foo HAVING 1 = 1
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [Identifier([Ident("foo")])], having: Some(BinaryOp { left: Value(Number("1")), op: Eq, right: Value(Number("1")) }) }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement roundtrip
SELECT id, fname, lname FROM customer WHERE id = 1 LIMIT ALL
----
SELECT id, fname, lname FROM customer WHERE id = 1

parse-statement roundtrip
SELECT row_number() OVER (ORDER BY dt DESC),
       sum(foo) OVER (PARTITION BY a, b ORDER BY c, d
           ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),
       avg(bar) OVER (ORDER BY a
           RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING),
       max(baz) OVER (ORDER BY a
           ROWS UNBOUNDED PRECEDING)
       FROM foo
----
SELECT row_number() OVER (ORDER BY dt DESC), sum(foo) OVER (PARTITION BY a, b ORDER BY c, d ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), avg(bar) OVER (ORDER BY a RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING), max(baz) OVER (ORDER BY a ROWS UNBOUNDED PRECEDING) FROM foo

parse-statement roundtrip
SELECT a, count(1), min(b), max(b) FROM foo GROUP BY a
----
SELECT a, count(1), min(b), max(b) FROM foo GROUP BY a

parse-statement roundtrip
SELECT a + b, 2 + a, 2.5 + a, a_f + b_f, 2 + a_f, 2.5 + a_f FROM c
----
SELECT a + b, 2 + a, 2.5 + a, a_f + b_f, 2 + a_f, 2.5 + a_f FROM c

parse-statement roundtrip
SELECT a - b, 2 - a, 2.5 - a, a_f - b_f, 2 - a_f, 2.5 - a_f FROM c
----
SELECT a - b, 2 - a, 2.5 - a, a_f - b_f, 2 - a_f, 2.5 - a_f FROM c

parse-statement roundtrip
SELECT alias."bar baz", myfun(), "simple id" AS "column alias" FROM "a table" AS alias
----
SELECT alias."bar baz", myfun(), "simple id" AS "column alias" FROM "a table" AS alias

parse-statement roundtrip
CREATE TABLE foo (bar int)
----
CREATE TABLE foo (bar int)

parse-statement roundtrip
SELECT * FROM fn(1, 2) AS foo, schema.bar AS bar WITH (nolock)
----
error:
Parse error:
SELECT * FROM fn(1, 2) AS foo, schema.bar AS bar WITH (nolock)
                                                 ^^^^
Expected end of statement, found: WITH

parse-statement
SELECT * FROM t1, t2
----
SELECT * FROM t1, t2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [] }, TableWithJoins { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1a NATURAL JOIN t1b, t2a NATURAL JOIN t2b
----
SELECT * FROM t1a NATURAL JOIN t1b, t2a NATURAL JOIN t2b
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1a")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t1b")]), alias: None }, join_operator: Inner(Natural) }] }, TableWithJoins { relation: Table { name: ObjectName([Ident("t2a")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2b")]), alias: None }, join_operator: Inner(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 CROSS JOIN t2
----
SELECT * FROM t1 CROSS JOIN t2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: CrossJoin }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 JOIN t2 AS foo USING(c1)
----
SELECT * FROM t1 JOIN t2 AS foo USING(c1)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: Some(TableAlias { name: Ident("foo"), columns: [], strict: false }) }, join_operator: Inner(Using([Ident("c1")])) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 JOIN t2 foo USING(c1)
----
SELECT * FROM t1 JOIN t2 AS foo USING(c1)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: Some(TableAlias { name: Ident("foo"), columns: [], strict: false }) }, join_operator: Inner(Using([Ident("c1")])) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 NATURAL JOIN t2
----
SELECT * FROM t1 NATURAL JOIN t2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: Inner(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 NATURAL LEFT JOIN t2
----
SELECT * FROM t1 NATURAL LEFT JOIN t2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: LeftOuter(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 NATURAL RIGHT JOIN t2
----
SELECT * FROM t1 NATURAL RIGHT JOIN t2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: RightOuter(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 NATURAL FULL JOIN t2
----
SELECT * FROM t1 NATURAL FULL JOIN t2
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: FullOuter(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM t1 natural
----
error:
Parse error:
SELECT * FROM t1 natural
                        ^
Expected a join type after NATURAL, found: EOF

parse-statement
SELECT c1, c2 FROM t1, t4 JOIN t2 ON t2.c = t1.c LEFT JOIN t3 USING(q, c) WHERE t4.c = t1.c
----
SELECT c1, c2 FROM t1, t4 JOIN t2 ON t2.c = t1.c LEFT JOIN t3 USING(q, c) WHERE t4.c = t1.c
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("c1")]), alias: None }, Expr { expr: Identifier([Ident("c2")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [] }, TableWithJoins { relation: Table { name: ObjectName([Ident("t4")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: Inner(On(BinaryOp { left: Identifier([Ident("t2"), Ident("c")]), op: Eq, right: Identifier([Ident("t1"), Ident("c")]) })) }, Join { relation: Table { name: ObjectName([Ident("t3")]), alias: None }, join_operator: LeftOuter(Using([Ident("q"), Ident("c")])) }] }], selection: Some(BinaryOp { left: Identifier([Ident("t4"), Ident("c")]), op: Eq, right: Identifier([Ident("t1"), Ident("c")]) }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM a NATURAL JOIN (b NATURAL JOIN (c NATURAL JOIN d NATURAL JOIN e)) NATURAL JOIN (f NATURAL JOIN (g NATURAL JOIN h))
----
SELECT * FROM a NATURAL JOIN (b NATURAL JOIN (c NATURAL JOIN d NATURAL JOIN e)) NATURAL JOIN (f NATURAL JOIN (g NATURAL JOIN h))
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("a")]), alias: None }, joins: [Join { relation: NestedJoin(TableWithJoins { relation: Table { name: ObjectName([Ident("b")]), alias: None }, joins: [Join { relation: NestedJoin(TableWithJoins { relation: Table { name: ObjectName([Ident("c")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("d")]), alias: None }, join_operator: Inner(Natural) }, Join { relation: Table { name: ObjectName([Ident("e")]), alias: None }, join_operator: Inner(Natural) }] }), join_operator: Inner(Natural) }] }), join_operator: Inner(Natural) }, Join { relation: NestedJoin(TableWithJoins { relation: Table { name: ObjectName([Ident("f")]), alias: None }, joins: [Join { relation: NestedJoin(TableWithJoins { relation: Table { name: ObjectName([Ident("g")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("h")]), alias: None }, join_operator: Inner(Natural) }] }), join_operator: Inner(Natural) }] }), join_operator: Inner(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM (a NATURAL JOIN b) NATURAL JOIN c
----
SELECT * FROM (a NATURAL JOIN b) NATURAL JOIN c
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: NestedJoin(TableWithJoins { relation: Table { name: ObjectName([Ident("a")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("b")]), alias: None }, join_operator: Inner(Natural) }] }), joins: [Join { relation: Table { name: ObjectName([Ident("c")]), alias: None }, join_operator: Inner(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM (((a NATURAL JOIN b)))
----
SELECT * FROM (((a NATURAL JOIN b)))
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: NestedJoin(TableWithJoins { relation: NestedJoin(TableWithJoins { relation: NestedJoin(TableWithJoins { relation: Table { name: ObjectName([Ident("a")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("b")]), alias: None }, join_operator: Inner(Natural) }] }), joins: [] }), joins: [] }), joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM a NATURAL JOIN (((b NATURAL JOIN c)))
----
SELECT * FROM a NATURAL JOIN (((b NATURAL JOIN c)))
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("a")]), alias: None }, joins: [Join { relation: NestedJoin(TableWithJoins { relation: NestedJoin(TableWithJoins { relation: NestedJoin(TableWithJoins { relation: Table { name: ObjectName([Ident("b")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("c")]), alias: None }, join_operator: Inner(Natural) }] }), joins: [] }), joins: [] }), join_operator: Inner(Natural) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM (a NATURAL JOIN (b))
----
error:
Parse error:
SELECT * FROM (a NATURAL JOIN (b))
                                ^
Expected joined table, found: )

parse-statement
SELECT c1 FROM t1 INNER JOIN t2 USING(c1)
----
SELECT c1 FROM t1 JOIN t2 USING(c1)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("c1")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: Inner(Using([Ident("c1")])) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT c1 FROM t1 LEFT OUTER JOIN t2 USING(c1)
----
SELECT c1 FROM t1 LEFT JOIN t2 USING(c1)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("c1")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: LeftOuter(Using([Ident("c1")])) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT c1 FROM t1 RIGHT OUTER JOIN t2 USING(c1)
----
SELECT c1 FROM t1 RIGHT JOIN t2 USING(c1)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("c1")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: RightOuter(Using([Ident("c1")])) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT c1 FROM t1 FULL OUTER JOIN t2 USING(c1)
----
SELECT c1 FROM t1 FULL JOIN t2 USING(c1)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("c1")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("t1")]), alias: None }, joins: [Join { relation: Table { name: ObjectName([Ident("t2")]), alias: None }, join_operator: FullOuter(Using([Ident("c1")])) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM a OUTER JOIN b ON 1
----
error:
Parse error:
SELECT * FROM a OUTER JOIN b ON 1
                ^^^^^
Expected LEFT, RIGHT, or FULL, found: OUTER

parse-statement
WITH
  a AS (SELECT 1 AS foo),
  b AS (SELECT 2 AS bar)
SELECT foo + bar FROM a, b
----
WITH a AS (SELECT 1 AS foo), b AS (SELECT 2 AS bar) SELECT foo + bar FROM a, b
=>
Select { query: Query { ctes: [Cte { alias: TableAlias { name: Ident("a"), columns: [], strict: false }, query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(Number("1")), alias: Some(Ident("foo")) }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None } }, Cte { alias: TableAlias { name: Ident("b"), columns: [], strict: false }, query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(Number("2")), alias: Some(Ident("bar")) }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None } }], body: Select(Select { distinct: false, projection: [Expr { expr: BinaryOp { left: Identifier([Ident("foo")]), op: Plus, right: Identifier([Ident("bar")]) }, alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("a")]), alias: None }, joins: [] }, TableWithJoins { relation: Table { name: ObjectName([Ident("b")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
CREATE VIEW v AS
  WITH
    a AS (SELECT 1 AS foo),
    b AS (SELECT 2 AS bar)
  SELECT foo + bar FROM a, b
----
CREATE VIEW v AS WITH a AS (SELECT 1 AS foo), b AS (SELECT 2 AS bar) SELECT foo + bar FROM a, b
=>
CreateView { name: ObjectName([Ident("v")]), columns: [], with_options: [], query: Query { ctes: [Cte { alias: TableAlias { name: Ident("a"), columns: [], strict: false }, query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(Number("1")), alias: Some(Ident("foo")) }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None } }, Cte { alias: TableAlias { name: Ident("b"), columns: [], strict: false }, query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(Number("2")), alias: Some(Ident("bar")) }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None } }], body: Select(Select { distinct: false, projection: [Expr { expr: BinaryOp { left: Identifier([Ident("foo")]), op: Plus, right: Identifier([Ident("bar")]) }, alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("a")]), alias: None }, joins: [] }, TableWithJoins { relation: Table { name: ObjectName([Ident("b")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, if_exists: Error, temporary: false, materialized: false }

parse-statement roundtrip
WITH cte (col1, col2) AS (SELECT foo, bar FROM baz) SELECT * FROM cte
----
WITH cte (col1, col2) AS (SELECT foo, bar FROM baz) SELECT * FROM cte

parse-statement roundtrip
SELECT a.x, b.y FROM (SELECT x FROM foo) AS a CROSS JOIN (SELECT y FROM bar) AS b
----
SELECT a.x, b.y FROM (SELECT x FROM foo) AS a CROSS JOIN (SELECT y FROM bar) AS b

parse-statement roundtrip
SELECT a.x, b.y FROM (SELECT x FROM foo) AS a (x) CROSS JOIN (SELECT y FROM bar) AS b (y)
----
SELECT a.x, b.y FROM (SELECT x FROM foo) AS a (x) CROSS JOIN (SELECT y FROM bar) AS b (y)

parse-statement roundtrip
SELECT * FROM (((SELECT 1)))
----
SELECT * FROM (((SELECT 1)))

parse-statement roundtrip
SELECT * FROM t NATURAL JOIN (((SELECT 1)))
----
SELECT * FROM t NATURAL JOIN (((SELECT 1)))

parse-statement roundtrip
SELECT * FROM (((SELECT 1) UNION (SELECT 2)) AS t1 NATURAL JOIN t2)
----
SELECT * FROM (((SELECT 1) UNION (SELECT 2)) AS t1 NATURAL JOIN t2)

parse-statement roundtrip
SELECT * FROM ((SELECT 1) AS t)
----
error:
Parse error:
SELECT * FROM ((SELECT 1) AS t)
                              ^
Expected joined table, found: )

parse-statement roundtrip
SELECT * FROM (VALUES (1), (2), (3))
----
SELECT * FROM (VALUES (1), (2), (3))

parse-statement roundtrip
SELECT * FROM (VALUES (1), (2), (3)), (VALUES (1, 2, 3))
----
SELECT * FROM (VALUES (1), (2), (3)), (VALUES (1, 2, 3))

parse-statement roundtrip
SELECT * FROM (VALUES (1)) UNION VALUES (1)
----
SELECT * FROM (VALUES (1)) UNION VALUES (1)

parse-statement roundtrip
SELECT * FROM t WHERE EXISTS (SELECT 1)
----
SELECT * FROM t WHERE EXISTS (SELECT 1)

parse-statement roundtrip
SELECT * FROM t WHERE NOT EXISTS (SELECT 1)
----
SELECT * FROM t WHERE NOT EXISTS (SELECT 1)

parse-statement roundtrip
SELECT * FROM t WHERE EXISTS (WITH u AS (SELECT 1) SELECT * FROM u)
----
SELECT * FROM t WHERE EXISTS (WITH u AS (SELECT 1) SELECT * FROM u)

parse-statement roundtrip
SELECT EXISTS (SELECT 1)
----
SELECT EXISTS (SELECT 1)

parse-statement
SELECT foo FROM bar OFFSET 2 ROWS
----
SELECT foo FROM bar OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar WHERE foo = 4 OFFSET 2 ROWS
----
SELECT foo FROM bar WHERE foo = 4 OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("foo")]), op: Eq, right: Value(Number("4")) }), group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar ORDER BY baz OFFSET 2 ROWS
----
SELECT foo FROM bar ORDER BY baz OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("baz")]), asc: None }], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz OFFSET 2 ROWS
----
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("foo")]), op: Eq, right: Value(Number("4")) }), group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("baz")]), asc: None }], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS) OFFSET 2 ROWS
----
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS) OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Derived { lateral: false, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM LATERAL bar(1)
----
SELECT foo FROM bar(1)
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Function { name: ObjectName([Ident("bar")]), args: Args([Value(Number("1"))]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT foo FROM LATERAL bar
----
error:
Parse error:
SELECT foo FROM LATERAL bar
                           ^
Expected (, found: EOF

parse-statement
SELECT 'foo' OFFSET 0 ROWS
----
SELECT 'foo' OFFSET 0 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(String("foo")), alias: None }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("0"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar OFFSET 2
----
SELECT foo FROM bar OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar WHERE foo = 4 OFFSET 2
----
SELECT foo FROM bar WHERE foo = 4 OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("foo")]), op: Eq, right: Value(Number("4")) }), group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar ORDER BY baz OFFSET 2
----
SELECT foo FROM bar ORDER BY baz OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("baz")]), asc: None }], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz OFFSET 2
----
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("foo")]), op: Eq, right: Value(Number("4")) }), group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("baz")]), asc: None }], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM (SELECT * FROM bar OFFSET 2) OFFSET 2
----
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS) OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Derived { lateral: false, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS) OFFSET 2
----
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS) OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Derived { lateral: false, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT foo FROM (SELECT * FROM bar OFFSET 2) OFFSET 2 ROWS
----
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS) OFFSET 2 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Derived { lateral: false, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: None }, as_of: None }

parse-statement
SELECT 'foo' OFFSET 0
----
SELECT 'foo' OFFSET 0 ROWS
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(String("foo")), alias: None }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("0"))), fetch: None }, as_of: None }

parse-statement roundtrip
SELECT foo FROM bar OFFSET 1 ROW
----
SELECT foo FROM bar OFFSET 1 ROWS

parse-statement
SELECT foo FROM bar FETCH FIRST 2 ROWS ONLY
----
SELECT foo FROM bar FETCH FIRST 2 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT 'foo' FETCH FIRST 2 ROWS ONLY
----
SELECT 'foo' FETCH FIRST 2 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Value(String("foo")), alias: None }], from: [], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar FETCH FIRST ROWS ONLY
----
SELECT foo FROM bar FETCH FIRST ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: None }) }, as_of: None }

parse-statement
SELECT foo FROM bar WHERE foo = 4 FETCH FIRST 2 ROWS ONLY
----
SELECT foo FROM bar WHERE foo = 4 FETCH FIRST 2 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("foo")]), op: Eq, right: Value(Number("4")) }), group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar ORDER BY baz FETCH FIRST 2 ROWS ONLY
----
SELECT foo FROM bar ORDER BY baz FETCH FIRST 2 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("baz")]), asc: None }], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz FETCH FIRST 2 ROWS WITH TIES
----
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz FETCH FIRST 2 ROWS WITH TIES
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("foo")]), op: Eq, right: Value(Number("4")) }), group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("baz")]), asc: None }], limit: None, offset: None, fetch: Some(Fetch { with_ties: true, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar FETCH FIRST 50 PERCENT ROWS ONLY
----
SELECT foo FROM bar FETCH FIRST 50 PERCENT ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: true, quantity: Some(Value(Number("50"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY
----
SELECT foo FROM bar WHERE foo = 4 ORDER BY baz OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("foo")]), op: Eq, right: Value(Number("4")) }), group_by: [], having: None }), order_by: [OrderByExpr { expr: Identifier([Ident("baz")]), asc: None }], limit: None, offset: Some(Value(Number("2"))), fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT foo FROM (SELECT * FROM bar FETCH FIRST 2 ROWS ONLY) FETCH FIRST 2 ROWS ONLY
----
SELECT foo FROM (SELECT * FROM bar FETCH FIRST 2 ROWS ONLY) FETCH FIRST 2 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Derived { lateral: false, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY) OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY
----
SELECT foo FROM (SELECT * FROM bar OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY) OFFSET 2 ROWS FETCH FIRST 2 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Derived { lateral: false, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: Some(Value(Number("2"))), fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("2"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar FETCH FIRST 10 ROW ONLY
----
SELECT foo FROM bar FETCH FIRST 10 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("10"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar FETCH NEXT 10 ROW ONLY
----
SELECT foo FROM bar FETCH FIRST 10 ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: Some(Value(Number("10"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar FETCH NEXT 10 ROWS WITH TIES
----
SELECT foo FROM bar FETCH FIRST 10 ROWS WITH TIES
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: true, percent: false, quantity: Some(Value(Number("10"))) }) }, as_of: None }

parse-statement
SELECT foo FROM bar FETCH NEXT ROWS WITH TIES
----
SELECT foo FROM bar FETCH FIRST ROWS WITH TIES
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: true, percent: false, quantity: None }) }, as_of: None }

parse-statement
SELECT foo FROM bar FETCH FIRST ROWS ONLY
----
SELECT foo FROM bar FETCH FIRST ROWS ONLY
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Expr { expr: Identifier([Ident("foo")]), alias: None }], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("bar")]), alias: None }, joins: [] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: Some(Fetch { with_ties: false, percent: false, quantity: None }) }, as_of: None }

parse-statement
SELECT * FROM customer LEFT JOIN (SELECT * FROM "order" WHERE "order".customer = customer.id LIMIT 3) AS "order" ON true
----
SELECT * FROM customer LEFT JOIN (SELECT * FROM "order" WHERE "order".customer = customer.id LIMIT 3) AS "order" ON true
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [Join { relation: Derived { lateral: false, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("order")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("order"), Ident("customer")]), op: Eq, right: Identifier([Ident("customer"), Ident("id")]) }), group_by: [], having: None }), order_by: [], limit: Some(Value(Number("3"))), offset: None, fetch: None }, alias: Some(TableAlias { name: Ident("order"), columns: [], strict: false }) }, join_operator: LeftOuter(On(Value(Boolean(true)))) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM customer LEFT JOIN LATERAL (SELECT * FROM "order" WHERE "order".customer = customer.id LIMIT 3) AS "order" ON true
----
SELECT * FROM customer LEFT JOIN LATERAL (SELECT * FROM "order" WHERE "order".customer = customer.id LIMIT 3) AS "order" ON true
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [Join { relation: Derived { lateral: true, subquery: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("order")]), alias: None }, joins: [] }], selection: Some(BinaryOp { left: Identifier([Ident("order"), Ident("customer")]), op: Eq, right: Identifier([Ident("customer"), Ident("id")]) }), group_by: [], having: None }), order_by: [], limit: Some(Value(Number("3"))), offset: None, fetch: None }, alias: Some(TableAlias { name: Ident("order"), columns: [], strict: false }) }, join_operator: LeftOuter(On(Value(Boolean(true)))) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM customer LEFT JOIN LATERAL generate_series(1, customer.id) ON true
----
SELECT * FROM customer LEFT JOIN generate_series(1, customer.id) ON true
=>
Select { query: Query { ctes: [], body: Select(Select { distinct: false, projection: [Wildcard], from: [TableWithJoins { relation: Table { name: ObjectName([Ident("customer")]), alias: None }, joins: [Join { relation: Function { name: ObjectName([Ident("generate_series")]), args: Args([Value(Number("1")), Identifier([Ident("customer"), Ident("id")])]), alias: None }, join_operator: LeftOuter(On(Value(Boolean(true)))) }] }], selection: None, group_by: [], having: None }), order_by: [], limit: None, offset: None, fetch: None }, as_of: None }

parse-statement
SELECT * FROM a LEFT JOIN LATERAL (b CROSS JOIN c)
----
error:
Parse error:
SELECT * FROM a LEFT JOIN LATERAL (b CROSS JOIN c)
                                   ^
Expected SELECT, VALUES, or a subquery in the query body, found: b
