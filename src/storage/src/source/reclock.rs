// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

//! An operator (`ReclockOperator`) that observes the progress of a stream that is
//! timestamped with some source time `FromTime` and generates bindings that describe how the
//! collection should evolve in target time `IntoTime`.
use differential_dataflow::consolidation;
use differential_dataflow::lattice::Lattice;
use futures::{FutureExt, StreamExt};
use mz_persist_client::error::UpperMismatch;
use mz_repr::Diff;
use mz_storage_client::util::remap_handle::RemapHandle;
use timely::order::PartialOrder;
use timely::progress::frontier::{Antichain, AntichainRef, MutableAntichain};
use timely::progress::Timestamp;

pub mod compat;

/// The `ReclockOperator` is responsible for observing progress in the `FromTime` domain and
/// consume messages from a ticker of progress in the `IntoTime` domain. When the source frontier
/// advances and the ticker ticks the `ReclockOperator` will generate the data that describe this
/// correspondence and write them out to its provided remap handle. The output generated by the
/// reclock operator can be thought of as `Collection<G, FromTime>` where `G::Timestamp` is
/// `IntoTime`.
///
/// The `ReclockOperator` will always maintain the invariant that for any time `IntoTime` the remap
/// collection accumulates into an Antichain where each `FromTime` timestamp has frequency `1`. In
/// other words the remap collection describes a well formed `Antichain<FromTime>` as it is
/// marching forwards.
#[derive(Debug)]
pub struct ReclockOperator<
    FromTime: Timestamp,
    IntoTime: Timestamp + Lattice,
    Handle: RemapHandle<FromTime = FromTime, IntoTime = IntoTime>,
    Clock,
> {
    /// Upper frontier of the partial remap trace
    upper: Antichain<IntoTime>,
    /// The upper frontier in terms of `FromTime`. Any attempt to reclock messages beyond this
    /// frontier will lead to minting new bindings.
    source_upper: MutableAntichain<FromTime>,

    /// A handle allowing this operator to publish updates to and read back from the remap collection
    remap_handle: Handle,
    /// A stream of IntoTime values and upper frontiers, used to drive minting bindings
    /// In the future this will be a timely input to the reclock operator
    clock_stream: Clock,
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ReclockBatch<FromTime, IntoTime> {
    pub updates: Vec<(FromTime, IntoTime, Diff)>,
    pub upper: Antichain<IntoTime>,
}

impl<FromTime, IntoTime, Handle, Clock> ReclockOperator<FromTime, IntoTime, Handle, Clock>
where
    FromTime: Timestamp,
    IntoTime: Timestamp + Lattice,
    Handle: RemapHandle<FromTime = FromTime, IntoTime = IntoTime>,
    Clock: futures::Stream<Item = (IntoTime, Antichain<IntoTime>)> + Unpin,
{
    /// Construct a new [ReclockOperator] from the given collection metadata
    pub async fn new(
        remap_handle: Handle,
        clock_stream: Clock,
    ) -> (Self, ReclockBatch<FromTime, IntoTime>) {
        let upper = remap_handle.upper().clone();

        let mut operator = Self {
            upper: Antichain::from_elem(IntoTime::minimum()),
            source_upper: MutableAntichain::new(),
            remap_handle,
            clock_stream,
        };

        // Load the initial state that might exist in the shard
        let trace_batch = if upper.elements() != [IntoTime::minimum()] {
            operator.sync(upper.borrow()).await
        } else {
            ReclockBatch {
                updates: vec![],
                upper: Antichain::from_elem(IntoTime::minimum()),
            }
        };

        (operator, trace_batch)
    }

    /// Advances the upper of the reclock operator if appropriate
    pub async fn advance(&mut self) -> ReclockBatch<FromTime, IntoTime> {
        // It's fine to call now_or_never here because next() is cancel safe
        match self.clock_stream.next().now_or_never() {
            Some(tick) => {
                let (_, upper) = tick.expect("end of time");
                match self.append_batch(vec![], upper.clone()).await {
                    Ok(trace_batch) => trace_batch,
                    Err(UpperMismatch { current, .. }) => self.sync(current.borrow()).await,
                }
            }
            None => ReclockBatch {
                updates: vec![],
                upper: self.upper.clone(),
            },
        }
    }

    /// Syncs the state of this operator to match that of the persist shard until the provided
    /// frontier
    async fn sync(
        &mut self,
        target_upper: AntichainRef<'_, IntoTime>,
    ) -> ReclockBatch<FromTime, IntoTime> {
        let mut updates: Vec<(FromTime, IntoTime, Diff)> = Vec::new();

        // Tail the remap collection until we reach the target upper frontier. Note that, in the
        // common case, we are also the writer, so we are waiting to read-back what we wrote
        while PartialOrder::less_than(&self.upper.borrow(), &target_upper) {
            let (mut batch, upper) = self
                .remap_handle
                .next()
                .await
                .expect("requested data after empty antichain");
            self.upper = upper;
            updates.append(&mut batch);
        }

        self.source_upper.update_iter(
            updates
                .iter()
                .map(|(src_ts, _dest_ts, diff)| (src_ts.clone(), *diff)),
        );

        ReclockBatch {
            updates,
            upper: self.upper.clone(),
        }
    }

    pub async fn mint(
        &mut self,
        new_source_upper: AntichainRef<'_, FromTime>,
    ) -> ReclockBatch<FromTime, IntoTime> {
        // The updates to the remap trace that occured during minting.
        let mut batch = ReclockBatch {
            updates: vec![],
            upper: self.upper.clone(),
        };

        while *self.upper == [IntoTime::minimum()]
            || PartialOrder::less_than(&self.source_upper.frontier(), &new_source_upper)
        {
            let (ts, mut upper) = self
                .clock_stream
                .by_ref()
                .skip_while(|(_ts, upper)| {
                    std::future::ready(PartialOrder::less_equal(
                        &upper.borrow(),
                        &self.upper.borrow(),
                    ))
                })
                .next()
                .await
                .expect("clock stream ended without reaching the empty frontier");

            // If source is closed, close remap shard as well.
            if new_source_upper.is_empty() {
                upper = Antichain::new();
            }

            // If this is the first binding we mint then we will mint it at the minimum target
            // timestamp. The first source upper is always the upper of the snapshot and by mapping
            // it to the minimum target timestamp we make it so that the final shard never appears
            // empty at any timestamp.
            let binding_ts = if *self.upper == [IntoTime::minimum()] {
                IntoTime::minimum()
            } else {
                ts
            };

            let mut updates = vec![];
            for src_ts in self.source_upper.frontier().iter().cloned() {
                updates.push((src_ts, binding_ts.clone(), -1));
            }
            for src_ts in new_source_upper.iter().cloned() {
                updates.push((src_ts, binding_ts.clone(), 1));
            }
            consolidation::consolidate_updates(&mut updates);

            let new_batch = match self.append_batch(updates, upper).await {
                Ok(trace_batch) => trace_batch,
                Err(UpperMismatch { current, .. }) => self.sync(current.borrow()).await,
            };
            batch.updates.extend(new_batch.updates);
            batch.upper = new_batch.upper;
        }

        batch
    }

    /// Appends the provided updates to the remap collection at the next available minting
    /// IntoTime and updates this operator's in-memory state accordingly.
    ///
    /// If an attempt to mint bindings fails due to another process having raced and appended
    /// bindings concurrently then the current global upper will be returned as an error. This is
    /// the frontier that this operator must be synced to for a future append attempt to have any
    /// chance of success.
    async fn append_batch(
        &mut self,
        updates: Vec<(FromTime, IntoTime, Diff)>,
        new_upper: Antichain<IntoTime>,
    ) -> Result<ReclockBatch<FromTime, IntoTime>, UpperMismatch<IntoTime>> {
        match self
            .remap_handle
            .compare_and_append(updates, self.upper.clone(), new_upper.clone())
            .await
        {
            // We have successfully produced data in the remap collection so let's read back what
            // we wrote to update our local state
            Ok(()) => Ok(self.sync(new_upper.borrow()).await),
            Err(mismatch) => Err(mismatch),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::cell::RefCell;
    use std::rc::Rc;
    use std::sync::Arc;
    use std::time::Duration;

    use futures::Stream;
    use mz_build_info::DUMMY_BUILD_INFO;
    use mz_ore::metrics::MetricsRegistry;
    use mz_ore::now::SYSTEM_TIME;
    use mz_persist_client::cache::PersistClientCache;
    use mz_persist_client::cfg::PersistConfig;
    use mz_persist_client::rpc::PubSubClientConnection;
    use mz_persist_client::{PersistLocation, ShardId};
    use mz_repr::{GlobalId, RelationDesc, ScalarType, Timestamp};
    use mz_storage_client::util::remap_handle::RemapHandle;
    use mz_storage_types::controller::CollectionMetadata;
    use mz_storage_types::sources::kafka::RangeBound;
    use mz_storage_types::sources::MzOffset;
    use mz_timely_util::order::Partitioned;
    use once_cell::sync::Lazy;
    use timely::progress::Timestamp as _;

    use super::*;

    // 15 minutes
    static PERSIST_READER_LEASE_TIMEOUT_MS: Duration = Duration::from_secs(60 * 15);

    static PERSIST_CACHE: Lazy<Arc<PersistClientCache>> = Lazy::new(|| {
        let persistcfg = PersistConfig::new_default_configs(&DUMMY_BUILD_INFO, SYSTEM_TIME.clone());
        persistcfg.set_reader_lease_duration(PERSIST_READER_LEASE_TIMEOUT_MS);
        Arc::new(PersistClientCache::new(
            persistcfg,
            &MetricsRegistry::new(),
            |_, _| PubSubClientConnection::noop(),
        ))
    });

    static PROGRESS_DESC: Lazy<RelationDesc> = Lazy::new(|| {
        RelationDesc::empty()
            .with_column(
                "partition",
                ScalarType::Range {
                    element_type: Box::new(ScalarType::Int32),
                }
                .nullable(false),
            )
            .with_column("offset", ScalarType::UInt64.nullable(true))
    });

    async fn make_test_operator(
        shard: ShardId,
        as_of: Antichain<Timestamp>,
    ) -> (
        ReclockOperator<
            Partitioned<RangeBound<i32>, MzOffset>,
            Timestamp,
            impl RemapHandle<FromTime = Partitioned<RangeBound<i32>, MzOffset>, IntoTime = Timestamp>,
            impl Stream<Item = (Timestamp, Antichain<Timestamp>)>,
        >,
        ReclockBatch<Partitioned<RangeBound<i32>, MzOffset>, Timestamp>,
    ) {
        let metadata = CollectionMetadata {
            persist_location: PersistLocation {
                blob_uri: "mem://".to_owned(),
                consensus_uri: "mem://".to_owned(),
            },
            remap_shard: Some(shard),
            data_shard: ShardId::new(),
            status_shard: None,
            relation_desc: RelationDesc::empty(),
            txns_shard: None,
        };

        let clock_stream = futures::stream::iter((0..).map(|seconds| {
            let ts = Timestamp::from(seconds * 1000);
            let upper = Antichain::from_elem(ts.step_forward());
            (ts, upper)
        }));

        let write_frontier = Rc::new(RefCell::new(Antichain::from_elem(Timestamp::minimum())));

        let remap_handle = crate::source::reclock::compat::PersistHandle::new(
            Arc::clone(&*PERSIST_CACHE),
            metadata,
            as_of.clone(),
            write_frontier,
            GlobalId::Explain,
            "unittest",
            0,
            1,
            PROGRESS_DESC.clone(),
            GlobalId::Explain,
        )
        .await
        .unwrap();

        let (mut operator, initial_batch) = ReclockOperator::new(remap_handle, clock_stream).await;

        // In the tests we always reclock the minimum source frontier to the minimum target
        // frontier, which we do in this step.
        let initial_batch = if *initial_batch.upper == [Timestamp::minimum()] {
            operator
                .mint(Antichain::from_elem(Partitioned::minimum()).borrow())
                .await
        } else {
            initial_batch
        };

        (operator, initial_batch)
    }

    /// Generates a `Partitioned<RangeBound<i32>, MzOffset>` antichain where all the provided
    /// partitions are at the specified offset and the gaps in between are filled with range
    /// timestamps at offset zero.
    fn partitioned_frontier<I>(items: I) -> Antichain<Partitioned<RangeBound<i32>, MzOffset>>
    where
        I: IntoIterator<Item = (i32, MzOffset)>,
    {
        let mut frontier = Antichain::new();
        let mut prev = RangeBound::NegInfinity;
        for (pid, offset) in items {
            assert!(prev < RangeBound::before(pid));
            let gap = Partitioned::new_range(prev, RangeBound::before(pid), MzOffset::from(0));
            frontier.extend([
                gap,
                Partitioned::new_singleton(RangeBound::exact(pid), offset),
            ]);
            prev = RangeBound::after(pid);
        }
        frontier.insert(Partitioned::new_range(
            prev,
            RangeBound::PosInfinity,
            MzOffset::from(0),
        ));
        frontier
    }

    #[mz_ore::test(tokio::test)]
    #[cfg_attr(miri, ignore)] // error: unsupported operation: can't call foreign function `decNumberFromInt32` on OS `linux`
    async fn test_basic_usage() {
        let (mut operator, initial_batch) =
            make_test_operator(ShardId::new(), Antichain::from_elem(0.into())).await;
        let expected = ReclockBatch {
            updates: vec![(
                Partitioned::new_range(RangeBound::NegInfinity, RangeBound::PosInfinity, 0.into()),
                0.into(),
                1,
            )],
            upper: Antichain::from_elem(1.into()),
        };
        assert_eq!(expected, initial_batch);

        // Reclock offsets 1 and 3 to timestamp 1000
        let source_upper = partitioned_frontier([(0, MzOffset::from(4))]);
        let batch = operator.mint(source_upper.borrow()).await;
        let expected = ReclockBatch {
            updates: vec![
                (
                    Partitioned::new_range(
                        RangeBound::NegInfinity,
                        RangeBound::before(0),
                        0.into(),
                    ),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_range(RangeBound::after(0), RangeBound::PosInfinity, 0.into()),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_singleton(RangeBound::exact(0), 4.into()),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_range(
                        RangeBound::NegInfinity,
                        RangeBound::PosInfinity,
                        0.into(),
                    ),
                    1000.into(),
                    -1,
                ),
            ],
            upper: Antichain::from_elem(1001.into()),
        };
        assert_eq!(expected, batch);
    }

    #[mz_ore::test(tokio::test)]
    #[cfg_attr(miri, ignore)] // error: unsupported operation: can't call foreign function `decNumberFromInt32` on OS `linux`
    async fn test_concurrency() {
        // Create two operators pointing to the same shard
        let shared_shard = ShardId::new();
        let (mut op_a, initial_batch_a) =
            make_test_operator(shared_shard, Antichain::from_elem(0.into())).await;
        let (mut op_b, initial_batch_b) =
            make_test_operator(shared_shard, Antichain::from_elem(0.into())).await;
        let expected = ReclockBatch {
            updates: vec![(
                Partitioned::new_range(RangeBound::NegInfinity, RangeBound::PosInfinity, 0.into()),
                0.into(),
                1,
            )],
            upper: Antichain::from_elem(1.into()),
        };
        assert_eq!(expected, initial_batch_a);
        assert_eq!(expected, initial_batch_b);

        // Reclock offsets 1 and 2 to timestamp 1000 from operator A
        let source_upper = partitioned_frontier([(0, MzOffset::from(3))]);
        let batch = op_a.mint(source_upper.borrow()).await;
        let expected = ReclockBatch {
            updates: vec![
                (
                    Partitioned::new_range(
                        RangeBound::NegInfinity,
                        RangeBound::before(0),
                        0.into(),
                    ),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_range(RangeBound::after(0), RangeBound::PosInfinity, 0.into()),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_singleton(RangeBound::exact(0), 3.into()),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_range(
                        RangeBound::NegInfinity,
                        RangeBound::PosInfinity,
                        0.into(),
                    ),
                    1000.into(),
                    -1,
                ),
            ],
            upper: Antichain::from_elem(1001.into()),
        };
        assert_eq!(expected, batch);

        // Advance the time of operator B by 10 seconds
        op_b.clock_stream.by_ref().take(10).count().await;

        // Mint from operator B that doesn't yet know about the mint that happened from operator A.
        // Operator B should attempt to mint in one go, fail, re-sync, and retry the mint and
        // return the combined bindings.
        let source_upper = partitioned_frontier([(0, MzOffset::from(5))]);
        let batch = op_b.mint(source_upper.borrow()).await;
        let expected = ReclockBatch {
            updates: vec![
                // Previous bindings discovered
                (
                    Partitioned::new_range(
                        RangeBound::NegInfinity,
                        RangeBound::before(0),
                        0.into(),
                    ),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_range(RangeBound::after(0), RangeBound::PosInfinity, 0.into()),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_singleton(RangeBound::exact(0), 3.into()),
                    1000.into(),
                    1,
                ),
                (
                    Partitioned::new_range(
                        RangeBound::NegInfinity,
                        RangeBound::PosInfinity,
                        0.into(),
                    ),
                    1000.into(),
                    -1,
                ),
                // New bindings produced
                (
                    Partitioned::new_singleton(RangeBound::exact(0), 3.into()),
                    11000.into(),
                    -1,
                ),
                (
                    Partitioned::new_singleton(RangeBound::exact(0), 5.into()),
                    11000.into(),
                    1,
                ),
            ],
            upper: Antichain::from_elem(11001.into()),
        };
        assert_eq!(expected, batch);
    }
}
