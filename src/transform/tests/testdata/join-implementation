# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

cat
(defsource x [int32 int64 int32])
----
ok

opt
(join [(get x) (get x)] [[#0 #3]])
----
----
%0 =
| Get x (u0)
| ArrangeBy (#0)

%1 =
| Get x (u0)

%2 =
| Join %0 %1 (= #0 #3)
| | implementation = Differential %1 %0.(#0)
| Project (#0..=#2, #0, #4, #5)
----
----

# tests single-input predicates properly get pushed out of join equivalences
# using different combinations of literals and non-literals with different multiplicities

opt
(join [(get x)] [[#0 #1 #2]])
----
%0 =
| Get x (u0)
| Filter (((#0) IS NULL && (#1) IS NULL) || (#0 = #1)), (((#0) IS NULL && (#2) IS NULL) || (#0 = #2)), (((#1) IS NULL && (#2) IS NULL) || (#1 = #2))

opt
(join [(get x)] [[#0 #2 #1 #2]])
----
%0 =
| Get x (u0)
| Filter (((#0) IS NULL && (#1) IS NULL) || (#0 = #1)), (((#0) IS NULL && (#2) IS NULL) || (#0 = #2)), (((#1) IS NULL && (#2) IS NULL) || (#1 = #2))

opt
(join [(get x)] [[#0 #1 5]])
----
%0 =
| Get x (u0)
| Filter (#0 = 5), (#1 = 5)

opt
(join [(get x)] [[5 #0 #1]])
----
%0 =
| Get x (u0)
| Filter (#0 = 5), (#1 = 5)

opt
(join [(get x) (get x)] [[5 #0 5 #3]])
----
----
%0 = Let l0 =
| Get x (u0)
| Filter (#0 = 5)

%1 =
| Get %0 (l0)
| ArrangeBy ()

%2 =
| Join %1 %0
| | implementation = Differential %0 %1.()
----
----

opt
(join [(get x) (get x)] [[5 9 #0 #3]])
----
%0 =
| Constant

# test that JoinImplementation properly lifts MapFilterProjects
# The choice of MFP in the test is arbitrary; to ensure that MFP lifting is
# being correctly tested, make sure that:
# * the optimized result has at least one Map, one Filter, and one Project
#   after the join.
# * the project reorders columns in some way.
# * the filter has at least one predicate that refers to a mapped column.

opt
(join
    [
        (project (filter (map (reduce (get x) [#0] [(sum_int32 #1)]) [(call_unary
    neg_int32 #1)]) [(call_binary lt #1 #2)])[#2 #1 #0])
        (get x)
    ]
    [[#2 #3]]
)
----
----
%0 =
| Get x (u0)
| Project (#0, #1)
| Reduce group=(#0)
| | agg sum(#1)
| ArrangeBy (#0)

%1 =
| Get x (u0)

%2 =
| Join %0 %1 (= #0 #2)
| | implementation = Differential %1 %0.(#0)
| Filter (#1 < -(#1))
| Map -(#1)
| Project (#5, #1, #0, #0, #3, #4)
----
----

## MFPs don't get lifted if join is not using a pre-existing arrangement on that input.

opt
(join
    [
        (project (filter (map (get x) [(call_unary neg_int32 #1)]) [(call_binary
        lt #1 #0)])[#1 #3 #0])
        (reduce (get x) [#0] [(sum_int32 #1)])]
    [[#1 #3]]
)
----
----
%0 =
| Get x (u0)
| Filter (#1 < #0)
| Map -(#1)
| Project (#0, #1, #3)

%1 =
| Get x (u0)
| Project (#0, #1)
| Reduce group=(#0)
| | agg sum(#1)
| ArrangeBy (#0)

%2 =
| Join %0 %1 (= #2 #3)
| | implementation = Differential %0 %1.(#0)
| Project (#1, #2, #0, #2, #4)
----
----

## join equivalence references column created by map being lifted.

opt
(join
    [
        (project (filter (map (reduce (get x) [#0] [(sum_int32 #1)]) [(call_unary
    neg_int32 #1)]) [(call_binary lt #1 #2)])[#1 #2 #0])
        (get x)
        (reduce (get x) [#1] [(max_int32 #2)])
    ]
    [[#2 #3] [#1 #6]]
)
----
----
%0 =
| Get x (u0)
| Project (#0, #1)
| Reduce group=(#0)
| | agg sum(#1)
| ArrangeBy (#0)

%1 =
| Get x (u0)

%2 =
| Get x (u0)
| Project (#1, #2)
| Reduce group=(#0)
| | agg max(#1)
| ArrangeBy (#0)

%3 =
| Join %0 %1 %2 (= #0 #2) (= #5 -(#1))
| | implementation = Differential %1 %0.(#0) %2.(#0)
| Filter (#1 < -(#1))
| Map -(#1)
| Project (#1, #7, #0, #0, #3, #4, #7, #6)
----
----
