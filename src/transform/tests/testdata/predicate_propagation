# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

cat
(defsource x [int32 (int32 false)])
(defsource y [int32 int32])
----
ok

# test column replacements

# Filter

build apply=PredicateKnowledge
(filter (project (constant [[null]] [int64]) [#0 #0]) [(call_binary eq #0 #1)])
----
%0 =
| Constant (null)
| Project (#0, #0)
| Filter (#0 = #0)

predicate-propagation
(filter (project (constant [[null]] [int64]) [#0 #0]) [(call_binary eq #0 #1)])
----
isnull(#0)
(#0 = #1)

build apply=PredicateKnowledge
(filter (project (get x) [#0 #0]) [(call_binary eq #0 #1)])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Filter (#0 = #0)

build apply=PredicateKnowledge
(filter (join [(get x) (get y)] [[#0 #2]]) [(call_binary eq #0 #2)])
----
----
%0 =
| Get x (u0)

%1 =
| Get y (u1)

%2 =
| Join %0 %1 (= #0 #2)
| | implementation = Unimplemented
| Filter (#0 = #0)
----
----

build apply=PredicateKnowledge
(filter (constant [[1] [1]] [int64]) [(call_binary eq #0 2)])
----
%0 =
| Constant

# Reduce

build apply=PredicateKnowledge
(reduce (project (get x) [#0 #0]) [#0 #1] [])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Distinct group=(#0, #0)

build apply=PredicateKnowledge
(reduce (project (get x) [#0 #0]) [#0] [(sum_int32 #1)])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Reduce group=(#0)
| | agg sum(#0)

# count(<non-nullable column>) -> count(true)
build apply=PredicateKnowledge
(reduce (get x) [#0] [(count #1)])
----
%0 =
| Get x (u0)
| Reduce group=(#0)
| | agg count(true)

# ... doesn't apply to count(distinct ...)
build apply=PredicateKnowledge
(reduce (get x) [#0] [(count #1 true)])
----
%0 =
| Get x (u0)
| Reduce group=(#0)
| | agg count(distinct #1)

# IS NOT NULL predicate lifted for aggregate columns
build apply=PredicateKnowledge
(filter (reduce (get x) [#0] [(count #1 true)]) [(call_unary is_null #1)])
----
%0 =
| Constant

build apply=PredicateKnowledge
(filter (reduce (get x) [#0] [(sum_int32 #1)]) [(call_unary is_null #1)])
----
%0 =
| Constant

build apply=PredicateKnowledge
(filter (reduce (get x) [#1] [(sum_int32 #0)]) [(call_unary is_null #1)])
----
%0 =
| Get x (u0)
| Reduce group=(#1)
| | agg sum(#0)
| Filter isnull(#1)

# Map

build apply=PredicateKnowledge
(map (project (get x) [#0 #0]) [#1 (call_binary add_int32 #1 1)])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Map #0, (#0 + 1)

build apply=PredicateKnowledge
(project (filter (map (project (get x) [#0 #0]) [#1 (call_binary add_int32 #1 1)]) [(call_binary eq #0 #2)]) [2 3])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Map #0, (#0 + 1)
| Filter (#0 = #0)
| Project (#2, #3)

predicate-propagation
(map (project (get x) [#0 #0]) [#1 (call_binary add_int32 #1 1)])
----
(#0 = #1)
(#0 = #2)
(#3 = (#0 + 1))

# Union

# #0 = #1 lifted from all branches
build apply=PredicateKnowledge
(map (union [(project (get x) [#0 #0]) (project (get x) [#0 #0])]) [#1 (call_binary add_int32 #1 1)])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Project (#0, #0)

%2 =
| Union %0 %1
| Map #0, (#0 + 1)
----
----

# #0 = #1 not lifted from all branches
build apply=PredicateKnowledge
(map (union [(project (get x) [#0 #0]) (project (get x) [#0 #0]) (get x)]) [#1 (call_binary add_int32 #1 1)])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Project (#0, #0)

%2 =
| Get x (u0)

%3 =
| Union %0 %1 %2
| Map #1, (#1 + 1)
----
----

# #0 = #1 not lifted from all branches
build apply=PredicateKnowledge
(map (union [(project (get x) [#0 #0]) (get x) (project (get x) [#0 #0])]) [#1 (call_binary add_int32 #1 1)])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)

%2 =
| Get x (u0)
| Project (#0, #0)

%3 =
| Union %0 %1 %2
| Map #1, (#1 + 1)
----
----

predicate-propagation
(map (union [(project (get x) [#0 #0]) (get x) (project (get x) [#0 #0])]) [#1 (call_binary add_int32 #1 1)])
----
(#1 = #2)
(#3 = (#1 + 1))

# FlatMap

build apply=PredicateKnowledge
(flat_map (project (get x) [#0 #1 #0 #1]) generate_series_int32 [#3 #2])
----
%0 =
| Get x (u0)
| Project (#0, #1, #0, #1)
| FlatMap generate_series(#1, #0)

# test known_true predicates

build apply=PredicateKnowledge
(filter (filter (get x) [(call_binary gt #0 #1)]) [(call_binary gt #0 #1)])
----
%0 =
| Get x (u0)
| Filter (#0 > #1)
| Filter true

# IS (NOT) NULL info comming from a Constant

build apply=PredicateKnowledge
(filter (constant [[null]] [int64]) [(call_unary is_null #0)])
----
%0 =
| Constant (null)
| Filter true

build apply=PredicateKnowledge
(filter (constant [[null]] [int64]) [(call_unary not (call_unary is_null #0))])
----
%0 =
| Constant (null)
| Filter !(true)

build apply=PredicateKnowledge
(filter (constant [[null] [1]] [int64]) [(call_unary is_null #0)])
----
%0 =
| Constant (null) (1)
| Filter isnull(#0)

build apply=PredicateKnowledge
(filter (constant [[2] [1]] [int64]) [(call_unary is_null #0)])
----
%0 =
| Constant

# IS (NOT) NULL info comming from a Get

# nullable column
build apply=PredicateKnowledge
(filter (get x) [(call_unary is_null #0)])
----
%0 =
| Get x (u0)
| Filter isnull(#0)

# non-nullable column
build apply=PredicateKnowledge
(filter (get x) [(call_unary is_null #1)])
----
%0 =
| Constant

# test known_false predicates

build apply=PredicateKnowledge
(filter (filter (get x) [(call_unary not (call_binary gt #0 #1))]) [(call_binary gt #0 #1)])
----
%0 =
| Constant

predicate-propagation
(filter (filter (get x) [(call_unary not (call_binary gt #0 #1))]) [(call_binary gt #0 #1)])
----
false
!(isnull(#1))
!((#0 > #1))

#
# TODO: improve impossible condition detection
#

build apply=PredicateKnowledge
(filter (get x) [(call_binary eq #0 #1) (call_binary gt #0 10) (call_binary lt #1 10)])
----
%0 =
| Get x (u0)
| Filter (#0 = #1), (#0 > 10), (#1 < 10)

build apply=PredicateKnowledge
(filter (get x) [(call_binary eq #0 #1) (call_binary gt #0 10) (call_binary lt #0 10)])
----
%0 =
| Get x (u0)
| Filter (#0 = #1), (#0 > 10), (#0 < 10)

build apply=PredicateKnowledge
(filter (get x) [(call_unary not (call_binary lt #0 #1)) (call_binary lt #0 #1)])
----
%0 =
| Constant

build apply=PredicateKnowledge
(filter (filter (get x) [(call_unary not (call_binary lt #0 #1))]) [(call_binary lt #0 #1)])
----
%0 =
| Constant

#
# Check that normalization doesn't return more predicates when it's fed with its own output.
#

predicate-propagation
(filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1))])
----
!(isnull(#1))
(#0 = (#0 + #1))

predicate-propagation
(project (filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1))]) [0 1])
----
!(isnull(#1))
(#0 = (#0 + #1))

predicate-propagation
(filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1)) (call_binary eq #0 #1)])
----
!(isnull(#0))
(#0 = #1)
(#0 = (#0 + #0))

predicate-propagation
(project (filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1)) (call_binary eq #0 #1)]) [0 1])
----
!(isnull(#0))
(#0 = #1)
(#0 = (#0 + #0))

predicate-propagation
(filter (get x) [(call_binary eq (call_binary add_int32 #0 #1) (call_binary mul_int32 10 (call_binary add_int32 #0 #1)))])
----
!(isnull(#1))
((#0 + #1) = (10 * (#0 + #1)))

predicate-propagation
(project (filter (get x) [(call_binary eq (call_binary add_int32 #0 #1) (call_binary mul_int32 10 (call_binary add_int32 #0 #1)))]) [0 1])
----
!(isnull(#1))
((#0 + #1) = (10 * (#0 + #1)))

predicate-propagation
(join [(get x) (get x)] [[#0 #2] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)]])
----
!(isnull(#1))
!(isnull(#3))
(#0 = #2)

predicate-propagation
(project (join [(get x) (get x)] [[#0 #2] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)]]) [0 1 2 3])
----
!(isnull(#1))
!(isnull(#3))
(#0 = #2)

predicate-propagation
(join [(get x) (get x)] [[(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [#0 #2] ])
----
!(isnull(#1))
!(isnull(#3))
(#0 = #2)

predicate-propagation
(project (join [(get x) (get x)] [[(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [#0 #2] ]) [0 1 2 3])
----
!(isnull(#1))
!(isnull(#3))
(#0 = #2)

predicate-propagation
(join [(get x) (get x)] [[(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [#0 #2] ])
----
!(isnull(#1))
!(isnull(#3))
(#0 = #2)

predicate-propagation
(project (join [(get x) (get x)] [[(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [#0 #2] ]) [0 1 2 3])
----
!(isnull(#1))
!(isnull(#3))
(#0 = #2)

# expressions in equivalence classes only become simpler.

canonicalize-join
[[
    (call_binary and #0 (call_binary add_int32 #0 #0))
    (call_binary add_int32 #0 #0)
    (call_binary add_int32 #0 (call_binary add_int32 #0 #0))
]]
[int32]
----
((#0 + #0) = (#0 && (#0 + #0)))
((#0 + #0) = (#0 + (#0 + #0)))

canonicalize-join
[
    [#0 #3]
    [#1
        (call_binary add_int32 (call_binary add_int32 #2 #2) #1)
        (call_binary add_int32
            (call_binary add_int32 #2 #2)
            (call_binary add_int32 (call_binary add_int32 #0 #0) #0))
        (call_binary add_int32 (call_binary add_int32 #3 #3) #3)
    ]
]
[int32 int32 int32 int32]
----
(#0 = #3)
(#1 = ((#0 + #0) + #0))
(#1 = ((#2 + #2) + #1))

canonicalize-join
[
    [#0 #3]
    [#1
        (call_binary add_int32 (call_binary add_int32 #2 #2) #1)
        (call_binary add_int32
            (call_binary mul_int32 #4 #5)
            (call_binary add_int32 (call_binary add_int32 #0 #0) #0))
        (call_binary add_int32 (call_binary add_int32 #3 #3) #3)
    ]
    [(call_binary add_int32 #2 #2) (call_binary mul_int32 #4 #5)]
]
[int32 int32 int32 int32 int32 int32]
----
(#0 = #3)
(#1 = ((#0 + #0) + #0))
(#1 = ((#2 + #2) + #1))
((#2 + #2) = (#4 * #5))

canonicalize-join
[[#0 #3 #3] [(call_binary add_int32 #0 #0) #1] [(call_binary add_int32 #3 #3)
#2]]
[int32 int32 int32 int32]
----
(#0 = #3)
(#1 = #2)
(#1 = (#0 + #0))

# replacing expressions with simpler equivalent ones can result in the
# removal of redundant equivalence classes.

canonicalize-join
[[#0 #0 #3] [(call_binary add_int32 #0 #0) (call_binary add_int32 #3 #3)]]
[int32 int32 int32 int32]
----
(#0 = #3)

# test an equivalence class when the number of leaves are the same but the
# number of nonleaves are not.

canonicalize-join
[[
    (call_unary cast_int16_to_int32 #0)
    (call_unary neg_int32 (call_unary cast_int16_to_int32 #0))
    (call_unary neg_int32 (call_unary neg_int32 (call_unary cast_int16_to_int32
    #0)))
]]
[int32]
----
(i16toi32(#0) = -(i16toi32(#0)))

# literals don't get overwritten with equivalent expressions

canonicalize-join
[[
    #0
    (4 int32)
    (call_binary add_int32 #1 (4 int32))
]]
[int32 int32]
----
(4 = #0)
(4 = (#1 + 4))

# functions on literals don't cause cycling
canonicalize-join
[
    [#0 (4 int32)]
    [(call_unary neg_int32 #0) (call_unary neg_int32 #1) (call_unary neg_int32 (4 int32))]
    [(call_binary add_int32 #1 (call_unary neg_int32 #1)) #3]
]
[int32 int32 int32 int32]
----
(#3 = (#1 + -4))
(4 = #0)
(-4 = -(#1))

canonicalize-join
[
    [#0 (4 int32)]
    [(call_unary neg_int32 #0) (call_unary neg_int32 #1)]
    [(call_unary neg_int32 #1) (call_unary neg_int32 (4 int32))]
    [(call_binary add_int32 #1 (call_unary neg_int32 #1)) #3]
]
[int32 int32 int32 int32]
----
(#3 = (#1 + -4))
(4 = #0)
(-4 = -(#1))

# expressions in join equivalences get reduced after simpler equivalent
# expressions are substituted

## constant folding

canonicalize-join
[
    [0 (call_binary add_int64 0 #0)]
    [1234 (call_binary add_int64 (call_binary add_int64 0 #0) 0)]
]
[int64]
----
false

## consecutive nots cancel each other

canonicalize-join
[
    [(call_unary not #0) (call_binary (is_regexp_match true) #1 #2)]
    [false (call_unary not (call_binary (is_regexp_match true) #1 #2))]
]
[bool string string]
----
(false = #0)
(true = (#1 ~* #2))

canonicalize-join
[
    [(call_unary not #0) (call_binary or #0 #1)]
    [false (call_unary not (call_binary or #0 #1))]
]
[bool bool]
----
(false = #0)
(true = #1)

## demorgans

canonicalize-join
[
    [ (call_binary and #2 #3) (call_variadic coalesce [#0 #1 false])]
    [ #0 (call_binary or (call_variadic coalesce [#0 #1 false]) (call_binary and #2 #4))]
]
[bool bool bool bool bool]
----
(#0 = (#2 && (#3 || #4)))
((#2 && #3) = coalesce(#0, #1, false))

## decompose is_null

canonicalize-join
[
    [ (call_binary add_int32 #2 #3) (call_variadic coalesce [#0 #1 false])]
    [ #0 (call_unary is_null (call_variadic coalesce [#0 #1 false]))]
]
[int32 int32 int32 int32]
----
(#0 = (isnull(#2) || isnull(#3)))
((#2 + #3) = coalesce(#0, #1, false))
