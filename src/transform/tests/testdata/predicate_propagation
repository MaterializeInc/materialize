# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

cat
(defsource x [int32 (int32 false)])
(defsource y [int32 int32])
----
ok

# test column replacements

# Filter

build apply=PredicateKnowledge
(filter (project (constant [[null]] [int64]) [#0 #0]) [(call_binary eq #0 #1)])
----
%0 =
| Constant

predicate-propagation
(filter (project (constant [[null]] [int64]) [#0 #0]) [(call_binary eq #0 #1)])
----
Equivalence[#0 #1]
false
!(isnull(#0))

build apply=PredicateKnowledge
(filter (project (get x) [#0 #0]) [(call_binary eq #0 #1)])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Filter (#0 = #0)

build apply=PredicateKnowledge
(filter (join [(get x) (get y)] [[#0 #2]]) [(call_binary eq #0 #2)])
----
----
%0 =
| Get x (u0)

%1 =
| Get y (u1)

%2 =
| Join %0 %1 (= #0 #2)
| | implementation = Unimplemented
| Filter (#0 = #0)
----
----

build apply=PredicateKnowledge
(filter (constant [[1] [1]] [int64]) [(call_binary eq #0 2)])
----
%0 =
| Constant

# Reduce

build apply=PredicateKnowledge
(reduce (project (get x) [#0 #0]) [#0 #1] [])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Distinct group=(#0, #0)

build apply=PredicateKnowledge
(reduce (project (get x) [#0 #0]) [#0] [(sum_int32 #1)])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Reduce group=(#0)
| | agg sum(#0)

# count(<non-nullable column>) -> count(true)
build apply=PredicateKnowledge
(reduce (get x) [#0] [(count #1)])
----
%0 =
| Get x (u0)
| Reduce group=(#0)
| | agg count(true)

# ... doesn't apply to count(distinct ...)
build apply=PredicateKnowledge
(reduce (get x) [#0] [(count #1 true)])
----
%0 =
| Get x (u0)
| Reduce group=(#0)
| | agg count(distinct #1)

# IS NOT NULL predicate lifted for aggregate columns
build apply=PredicateKnowledge
(filter (reduce (get x) [#0] [(count #1 true)]) [(call_unary is_null #1)])
----
%0 =
| Constant

build apply=PredicateKnowledge
(filter (reduce (get x) [#0] [(sum_int32 #1)]) [(call_unary is_null #1)])
----
%0 =
| Constant

build apply=PredicateKnowledge
(filter (reduce (get x) [#1] [(sum_int32 #0)]) [(call_unary is_null #1)])
----
%0 =
| Get x (u0)
| Reduce group=(#1)
| | agg sum(#0)
| Filter isnull(#1)

# Map

build apply=PredicateKnowledge
(map (project (get x) [#0 #0]) [#1 (call_binary add_int32 #1 1)])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Map #0, (#0 + 1)

build apply=PredicateKnowledge
(project (filter (map (project (get x) [#0 #0]) [#1 (call_binary add_int32 #1 1)]) [(call_binary eq #0 #2)]) [2 3])
----
%0 =
| Get x (u0)
| Project (#0, #0)
| Map #0, (#0 + 1)
| Filter (#0 = #0)
| Project (#2, #3)

# Union

# #0 = #1 lifted from all branches
build apply=PredicateKnowledge
(map (union [(project (get x) [#0 #0]) (project (get x) [#0 #0])]) [#1 (call_binary add_int32 #1 1)])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Project (#0, #0)

%2 =
| Union %0 %1
| Map #0, (#0 + 1)
----
----

build apply=PredicateKnowledge
(map (union [(project (get x) [#0 #0]) (filter(get x) [(call_binary eq #0 #1)])]) [#1 (call_binary add_int32 #1 1)])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Filter (#0 = #1)

%2 =
| Union %0 %1
| Map #0, (#0 + 1)
----
----

build apply=PredicateKnowledge
(reduce (union [(project (get x) [#0 #0]) (filter(get x) [(call_binary eq #0 #1)])]) [#0 #1] [])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Filter (#0 = #1)

%2 =
| Union %0 %1
| Distinct group=(#0, #0)
----
----

build apply=PredicateKnowledge
(reduce (project (union [(project (get x) [#0 #0]) (filter(get x) [(call_binary eq #0 #1)])]) [0 1]) [#0 #1] [])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Filter (#0 = #1)

%2 =
| Union %0 %1
| Project (#0, #1)
| Distinct group=(#0, #0)
----
----

build apply=PredicateKnowledge
(let l (union [(project (get x) [#0 #0]) (filter (get x) [(call_binary eq #0 #1)])]) (reduce (project (get l) [0 1]) [#0 #1] []))
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Filter (#0 = #1)

%2 = Let l0 =
| Union %0 %1

%3 =
| Get %2 (l0)
| Project (#0, #1)
| Distinct group=(#0, #0)
----
----

predicate-propagation
(let l (union [(project (get x) [#0 #0]) (filter (get x) [(call_binary eq #0 #1)])]) (get l))
----
Equivalence[#0 #1]

predicate-propagation
(let l (union [(project (get x) [#0 #0]) (filter (get x) [(call_binary eq #0 #1)])]) (project (get l) [0 1]))
----
Equivalence[#0 #1]

predicate-propagation
(join [(project (get x) [0 0]) (get x)] [])
----
Equivalence[#0 #1]
!(isnull(#3))

predicate-propagation
(join [(get x) (project (get x) [0 0]) (get x)] [])
----
Equivalence[#2 #3]
!(isnull(#1))
!(isnull(#5))

predicate-propagation
(join [(get x) (project (get x) [0 0]) (get x)] [[#0 #2]])
----
Equivalence[#0 #2 #3]
!(isnull(#1))
!(isnull(#5))


predicate-propagation
(join [(get x) (project (get x) [0 0]) (get x)] [[#0 #2 #4]])
----
Equivalence[#0 #2 #3 #4]
!(isnull(#1))
!(isnull(#5))

predicate-propagation
(join [(project (get x) [0 0]) (project (get x) [0 0]) (project (get x) [0 0])] [[#0 #2]])
----
Equivalence[#0 #1 #2 #3]
Equivalence[#4 #5]

# all columns belongs in the same equivalence
predicate-propagation
(join [(project (get x) [0 0]) (project (get x) [0 0]) (project (get x) [0 0])] [[#0 #2 #4]])
----
Equivalence[#0 #1 #2 #3 #4 #5]

predicate-propagation
(join [(filter (get x) [(call_binary eq #0 #1)]) (project (get x) [0 0]) (project (get x) [0 0])] [[#0 #2 #4]])
----
Equivalence[#0 #1 #2 #3 #4 #5]
!(isnull(#0))

build apply=PredicateKnowledge
(reduce (join [(project (get x) [0 0]) (project (get x) [0 0]) (project (get x) [0 0])] [[#0 #2 #4]]) [#0 #1 #2 #3 #4 #5] [])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Project (#0, #0)

%2 =
| Get x (u0)
| Project (#0, #0)

%3 =
| Join %0 %1 %2 (= #0 #2 #4)
| | implementation = Unimplemented
| Distinct group=(#0, #0, #0, #0, #0, #0)
----
----

# #0 = #1 not lifted from all branches
build apply=PredicateKnowledge
(map (union [(project (get x) [#0 #0]) (project (get x) [#0 #0]) (get x)]) [#1 (call_binary add_int32 #1 1)])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)
| Project (#0, #0)

%2 =
| Get x (u0)

%3 =
| Union %0 %1 %2
| Map #1, (#1 + 1)
----
----

# #0 = #1 not lifted from all branches
build apply=PredicateKnowledge
(map (union [(project (get x) [#0 #0]) (get x) (project (get x) [#0 #0])]) [#1 (call_binary add_int32 #1 1)])
----
----
%0 =
| Get x (u0)
| Project (#0, #0)

%1 =
| Get x (u0)

%2 =
| Get x (u0)
| Project (#0, #0)

%3 =
| Union %0 %1 %2
| Map #1, (#1 + 1)
----
----

predicate-propagation
(map (union [(project (get x) [#0 #0]) (get x) (project (get x) [#0 #0])]) [#1 (call_binary add_int32 #1 1)])
----
Equivalence[#1 #2]
Equivalence[#3 (#1 + 1)]

# FlatMap

build apply=PredicateKnowledge
(flat_map (project (get x) [#0 #1 #0 #1]) generate_series_int32 [#3 #2])
----
%0 =
| Get x (u0)
| Project (#0, #1, #0, #1)
| FlatMap generate_series(#1, #0)

# test known_true predicates

build apply=PredicateKnowledge
(filter (filter (get x) [(call_binary gt #0 #1)]) [(call_binary gt #0 #1)])
----
%0 =
| Get x (u0)
| Filter (#0 > #1)
| Filter true

# IS (NOT) NULL info comming from a Constant

build apply=PredicateKnowledge
(filter (constant [[null]] [int64]) [(call_unary is_null #0)])
----
%0 =
| Constant (null)
| Filter true

build apply=PredicateKnowledge
(filter (constant [[null]] [int64]) [(call_unary not (call_unary is_null #0))])
----
%0 =
| Constant

build apply=PredicateKnowledge
(filter (constant [[null] [1]] [int64]) [(call_unary is_null #0)])
----
%0 =
| Constant (null) (1)
| Filter isnull(#0)

build apply=PredicateKnowledge
(filter (constant [[2] [1]] [int64]) [(call_unary is_null #0)])
----
%0 =
| Constant

# IS (NOT) NULL info comming from a Get

# nullable column
build apply=PredicateKnowledge
(filter (get x) [(call_unary is_null #0)])
----
%0 =
| Get x (u0)
| Filter isnull(#0)

# non-nullable column
build apply=PredicateKnowledge
(filter (get x) [(call_unary is_null #1)])
----
%0 =
| Constant

# test known_false predicates

build apply=PredicateKnowledge
(filter (filter (get x) [(call_unary not (call_binary gt #0 #1))]) [(call_binary gt #0 #1)])
----
%0 =
| Get x (u0)
| Filter !((#0 > #1))
| Filter (#0 > #1)

predicate-propagation
(filter (filter (get x) [(call_unary not (call_binary gt #0 #1))]) [(call_binary gt #0 #1)])
----
!(isnull(#0))
!(isnull(#1))
(#0 <= #1)
(#0 > #1)

# Join (non-null contraint propagated via join equivalence): #1 is not null, which implies #2 is not null
build apply=PredicateKnowledge
(filter (join [(get x) (get y)] [[#1 #2]]) [(call_unary not (call_unary is_null #2))])
----
----
%0 =
| Get x (u0)

%1 =
| Get y (u1)

%2 =
| Join %0 %1 (= #1 #2)
| | implementation = Unimplemented
| Filter !(false)
----
----

# #0 is not null from all branches of the union
build apply=PredicateKnowledge
(filter (join [(union [(get x) (constant [[1 2]] [(int32 false) (int32 false)])]) (get y)] [[#1 #2]]) [(call_unary not (call_unary is_null #2))])
----
----
%0 =
| Get x (u0)

%1 =
| Constant (1, 2)

%2 =
| Union %0 %1

%3 =
| Get y (u1)

%4 =
| Join %2 %3 (= #1 #2)
| | implementation = Unimplemented
| Filter !(false)
----
----

build apply=PredicateKnowledge
(filter (join [(get x) (get y)] [[#1 #2]]) [(call_unary is_null #2)])
----
%0 =
| Constant

#
# TODO: improve impossible condition detection
#

build apply=PredicateKnowledge
(filter (get x) [(call_binary eq #0 #1) (call_binary gt #0 10) (call_binary lt #1 10)])
----
%0 =
| Get x (u0)
| Filter (#0 = #1), (#0 > 10), (#1 < 10)

build apply=PredicateKnowledge
(filter (get x) [(call_binary eq #0 #1) (call_binary gt #0 10) (call_binary lt #0 10)])
----
%0 =
| Get x (u0)
| Filter (#0 = #1), (#0 > 10), (#0 < 10)

build apply=PredicateKnowledge
(filter (get x) [(call_unary not (call_binary lt #0 #1)) (call_binary lt #0 #1)])
----
%0 =
| Get x (u0)
| Filter !((#0 < #1)), (#0 < #1)

build apply=PredicateKnowledge
(filter (filter (get x) [(call_unary not (call_binary lt #0 #1))]) [(call_binary lt #0 #1)])
----
%0 =
| Get x (u0)
| Filter !((#0 < #1))
| Filter (#0 < #1)

predicate-propagation
(join [(get x) (get x)] [[#0 #2 (1 int32)] [(call_binary sub_int32 #2 (1 int32)) #1]])
----
Equivalence[0 #1]
Equivalence[1 #0 #2]
!(isnull(#3))

#
# Check that normalization doesn't return more predicates when it's fed with its own output.
#

predicate-propagation
(filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1))])
----
Equivalence[#0 (#0 + #1)]
!(isnull(#0))
!(isnull(#1))

predicate-propagation
(project (filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1))]) [0 1])
----
Equivalence[#0 (#0 + #1)]
!(isnull(#0))
!(isnull(#1))

predicate-propagation
(filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1)) (call_binary eq #0 #1)])
----
Equivalence[#0 #1 (#0 + #1)]
!(isnull(#0))

predicate-propagation
(project (filter (get x) [(call_binary eq #0 (call_binary add_int32 #0 #1)) (call_binary eq #0 #1)]) [0 1])
----
Equivalence[#0 #1 (#0 + #1)]
!(isnull(#0))

predicate-propagation
(filter (get x) [(call_binary eq (call_binary add_int32 #0 #1) (call_binary mul_int32 10 (call_binary add_int32 #0 #1)))])
----
Equivalence[(#0 + #1) (10 * (#0 + #1))]
!(isnull(#0))
!(isnull(#1))

predicate-propagation
(project (filter (get x) [(call_binary eq (call_binary add_int32 #0 #1) (call_binary mul_int32 10 (call_binary add_int32 #0 #1)))]) [0 1])
----
Equivalence[(#0 + #1) (10 * (#0 + #1))]
!(isnull(#0))
!(isnull(#1))

predicate-propagation
(join [(get x) (get x)] [[#0 #2] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)]])
----
Equivalence[#0 #2]
!(isnull(#1))
!(isnull(#3))

predicate-propagation
(project (join [(get x) (get x)] [[#0 #2] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)]]) [0 1 2 3])
----
Equivalence[#0 #2]
!(isnull(#1))
!(isnull(#3))

predicate-propagation
(join [(get x) (get x)] [[(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [#0 #2] ])
----
Equivalence[#0 #2]
!(isnull(#1))
!(isnull(#3))

predicate-propagation
(project (join [(get x) (get x)] [[(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [#0 #2] ]) [0 1 2 3])
----
Equivalence[#0 #2]
!(isnull(#1))
!(isnull(#3))

predicate-propagation
(join [(get x) (get x)] [[(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [#0 #2] ])
----
Equivalence[#0 #2]
!(isnull(#1))
!(isnull(#3))

predicate-propagation
(project (join [(get x) (get x)] [[(call_binary add_int32 (call_binary add_int32 #0 1) 1) (call_binary add_int32 (call_binary add_int32 #2 1) 1)] [(call_binary add_int32 #0 1) (call_binary add_int32 #2 1)] [#0 #2] ]) [0 1 2 3])
----
Equivalence[#0 #2]
!(isnull(#1))
!(isnull(#3))

cat
(defsource t1 [int32])
----
ok

build apply=PredicateKnowledge
(let l16
    (let l8
        (project (get t1) [0 0])
        (union [
            (project (get l8) [0 1 0])
            (project (map (project (filter (reduce (project (get l8) [0]) [#0] [(count true)]) [(call_binary gt #1 1)]) [0]) [(err division_by_zero int32)]) [0 0 1])
        ])
    )
    (reduce
        (project
            (get l16)
            [0 1]
        )
        [#0 #1]
        []
    )
)
----
----
%0 = Let l0 =
| Get t1 (u2)
| Project (#0, #0)

%1 =
| Get %3 (l0)
| Project (#0, #1, #0)

%2 =
| Get %3 (l0)
| Project (#0)
| Reduce group=(#0)
| | agg count(true)
| Filter (#1 > 1)
| Project (#0)
| Map (err: division by zero)
| Project (#0, #0, #1)

%3 = Let l0 =
| Union %1 %2

%4 =
| Get %3 (l0)
| Project (#0, #1)
| Distinct group=(#0, #0)
----
----

predicate-propagation
(let l16
    (let l8
        (project (get t1) [0 0])
        (union [
            (project (get l8) [0 1 0])
            (project (map (project (filter (reduce (project (get l8) [0]) [#0] [(count true)]) [(call_binary gt #1 1)]) [0]) [(err division_by_zero int32)]) [0 0 1])
        ])
    )
    (get l16)
)
----
Equivalence[#0 #1]

predicate-propagation
(let l8
    (project (get t1) [0 0])
    (union [
        (project (get l8) [0 1 0])
        (project (map (project (filter (reduce (project (get l8) [0]) [#0] [(count true)]) [(call_binary gt #1 1)]) [0]) [(err division_by_zero int32)]) [0 0 1])
    ])
)
----
Equivalence[#0 #1]

predicate-propagation
(let l8
    (project (get t1) [0 0])
    (get l8)
)
----
Equivalence[#0 #1]

predicate-propagation
(let l8
    (project (get t1) [0 0])
    (project (get l8) [0 1 0])
)
----
Equivalence[#0 #1 #2]

predicate-propagation
(let l8
    (project (get t1) [0 0])
    (project (map (project (filter (reduce (project (get l8) [0]) [#0] [(count true)]) [(call_binary gt #1 1)]) [0]) [(err division_by_zero int32)]) [0 0 1])
)
----
Equivalence[#0 #1]
Equivalence[(err: division by zero) #2]
(err: division by zero)

predicate-propagation
(union [
    (project (get x) [0 0 1])
    (project (get x) [0 0 0])
])
----
Equivalence[#0 #1]

predicate-propagation
(union [
    (project (get x) [0 0 0])
    (project (get x) [1 0 0])
])
----
Equivalence[#1 #2]

predicate-propagation
(union [
    (project (get x) [0 1 0])
    (project (get x) [0 1 0])
])
----
Equivalence[#0 #2]
!(isnull(#1))

predicate-propagation
(union [
    (project (get x) [0 1 0 1])
    (project (get x) [0 1 1 1])
])
----
Equivalence[#1 #3]
!(isnull(#1))

predicate-propagation
(union [
    (project (get x) [0 1 0 1])
    (project (get x) [0 1 0 1])
])
----
Equivalence[#0 #2]
Equivalence[#1 #3]
!(isnull(#1))
