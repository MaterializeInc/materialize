# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

# https://github.com/MaterializeInc/advent-of-code-2023/blob/main/week1/aoc_1214.md

mode cockroach

statement ok
CREATE TABLE input (input TEXT);

statement ok
INSERT INTO input VALUES (
'.O.#....#.#.#.....O..O..O...
.O.#....O....#..#....#####..
.O..##..O..#O...##..#...O...
O.##.OO#O.#...#.#.#.O..##.O.
O..#..OO#...#..#.#O.#.#.OO.#
#.#.#.O.O##...O...#0##..O...
.O#...#..#.O..O.#.##..#..O..');

query I
WITH MUTUALLY RECURSIVE

    lines(r INT, line TEXT) AS (
        SELECT r, regexp_split_to_array(input, '\n')[r] as block
        FROM input, generate_series(1, array_length(regexp_split_to_array(input, '\n'), 1)) r
    ),
    cells(r INT, c INT, symbol TEXT) AS (
        SELECT r, c, substring(line, c, 1)
        FROM lines, generate_series(1, length(line)) c
    ),

    northward(r INT, c INT, symbol TEXT) AS (
        SELECT * FROM northward
        -- Anyone on the move does so
        UNION  ALL SELECT r - 1, c, 'O' FROM north_move
        EXCEPT ALL SELECT r - 1, c, '.' FROM north_move
        UNION  ALL SELECT r, c, '.' FROM north_move
        EXCEPT ALL SELECT r, c, 'O' FROM north_move
        -- Initial state is cells, but not refreshed each round.
        UNION  ALL SELECT * FROM cells
        EXCEPT ALL SELECT * FROM cells_delay
    ),

    -- Each 'O' with a '.' to the north will move.
    north_move(r INT, c INT) AS (
        SELECT n1.r, n1.c
        FROM northward n1, northward n2
        WHERE n1.symbol = 'O'
          AND n1.r = n2.r + 1
          AND n1.c = n2.c
          AND n2.symbol = '.'
    ),

    part1(part1 BIGINT) AS (
        SELECT SUM(1 + (SELECT MAX(r) FROM lines) - r)
        FROM northward
        WHERE symbol = 'O'
    ),

    output (r INT, line TEXT) AS (
        SELECT r, string_agg(symbol, ' ' ORDER BY c)
        FROM northward
        GROUP BY r
    ),

    cells_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM cells )

SELECT * FROM part1;
----
146

query T multiline
EXPLAIN WITH MUTUALLY RECURSIVE

    lines(r INT, line TEXT) AS (
        SELECT r, regexp_split_to_array(input, '\n')[r] as block
        FROM input, generate_series(1, array_length(regexp_split_to_array(input, '\n'), 1)) r
    ),
    cells(r INT, c INT, symbol TEXT) AS (
        SELECT r, c, substring(line, c, 1)
        FROM lines, generate_series(1, length(line)) c
    ),

    northward(r INT, c INT, symbol TEXT) AS (
        SELECT * FROM northward
        -- Anyone on the move does so
        UNION  ALL SELECT r - 1, c, 'O' FROM north_move
        EXCEPT ALL SELECT r - 1, c, '.' FROM north_move
        UNION  ALL SELECT r, c, '.' FROM north_move
        EXCEPT ALL SELECT r, c, 'O' FROM north_move
        -- Initial state is cells, but not refreshed each round.
        UNION  ALL SELECT * FROM cells
        EXCEPT ALL SELECT * FROM cells_delay
    ),

    -- Each 'O' with a '.' to the north will move.
    north_move(r INT, c INT) AS (
        SELECT n1.r, n1.c
        FROM northward n1, northward n2
        WHERE n1.symbol = 'O'
          AND n1.r = n2.r + 1
          AND n1.c = n2.c
          AND n2.symbol = '.'
    ),

    part1(part1 BIGINT) AS (
        SELECT SUM(1 + (SELECT MAX(r) FROM lines) - r)
        FROM northward
        WHERE symbol = 'O'
    ),

    output (r INT, line TEXT) AS (
        SELECT r, string_agg(symbol, ' ' ORDER BY c)
        FROM northward
        GROUP BY r
    ),

    cells_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM cells )

SELECT * FROM part1;
----
Explained Query:
  With
    cte l0 =
      Project (#1, #2)
        Map (array_index(regexp_split_to_array["\n", case_insensitive=false](#0), integer_to_bigint(#1)))
          FlatMap generate_series(1, (regexp_split_to_array["\n", case_insensitive=false](#0) array_length 1), 1)
            ReadStorage materialize.public.input
    cte l1 =
      Reduce aggregates=[max(#0)]
        Project (#0)
          Get l0
    cte l2 =
      Union
        Get l1
        Map (null)
          Union
            Negate
              Project ()
                Get l1
            Constant
              - ()
    cte l3 =
      Project (#0, #2, #3)
        Map (substr(#1, #2, 1))
          FlatMap generate_series(1, char_length(#1), 1)
            Get l0
  Return
    With Mutually Recursive
      cte l4 =
        Threshold
          Union
            Threshold
              Union
                Threshold
                  Union
                    Get l4
                    Project (#2, #1, #3)
                      Map ((#0 - 1), "O")
                        Get l6
                    Negate
                      Project (#2, #1, #3)
                        Map ((#0 - 1), ".")
                          Get l6
                Map (".")
                  Get l6
                Negate
                  Map ("O")
                    Get l6
            Get l3
            Negate
              Get l8
      cte l5 =
        Project (#0, #1)
          Filter (#2 = "O")
            Get l4
      cte l6 =
        Project (#0, #1)
          Join on=(#0 = (#2 + 1) AND #1 = #3) type=differential
            ArrangeBy keys=[[#1, #0]]
              Get l5
            ArrangeBy keys=[[#1, (#0 + 1)]]
              Project (#0, #1)
                Filter (#2 = ".")
                  Get l4
      cte l7 =
        Reduce aggregates=[sum(((1 + #1) - #0))]
          CrossJoin type=differential
            ArrangeBy keys=[[]]
              Project (#0)
                Get l5
            ArrangeBy keys=[[]]
              Union
                Get l2
                Map (null)
                  Union
                    Negate
                      Project ()
                        Get l2
                    Constant
                      - ()
      cte l8 =
        Get l3
    Return
      Union
        Get l7
        Map (null)
          Union
            Negate
              Project ()
                Get l7
            Constant
              - ()

Source materialize.public.input

Target cluster: quickstart

EOF

query I
WITH MUTUALLY RECURSIVE (RETURN AT RECURSION LIMIT 142)

    lines(r INT, line TEXT) AS (
        SELECT r, regexp_split_to_array(input, '\n')[r] as block
        FROM input, generate_series(1, array_length(regexp_split_to_array(input, '\n'), 1)) r
    ),
    cells(r INT, c INT, symbol TEXT) AS (
        SELECT r, c, substring(line, c, 1)
        FROM lines, generate_series(1, length(line)) c
    ),

    -- Where should we start each iteration from?
    -- From `east`, once it exits, but initially `cells`.
    round(r INT, c INT, symbol TEXT) AS (
        SELECT * FROM east
        UNION  ALL SELECT * FROM cells
        EXCEPT ALL SELECT * FROM cells_delay
    ),

    north(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM round
            ),
            northward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM northward
                -- Anyone on the move does so
                UNION  ALL SELECT r - 1, c, 'O' FROM north_move
                EXCEPT ALL SELECT r - 1, c, '.' FROM north_move
                UNION  ALL SELECT r, c, '.' FROM north_move
                EXCEPT ALL SELECT r, c, 'O' FROM north_move
                -- Second time around, the above cancels and `east` is non-empty.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            north_move(r INT, c INT) AS (
                SELECT n1.r, n1.c
                FROM northward n1, northward n2
                WHERE n1.symbol = 'O'
                AND n1.r = n2.r + 1
                AND n1.c = n2.c
                AND n2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )

        SELECT * FROM northward
    ),

     west(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM north
            ),
            westward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM westward
                -- Anyone on the move does so
                UNION  ALL SELECT r, c - 1, 'O' FROM west_move
                EXCEPT ALL SELECT r, c - 1, '.' FROM west_move
                UNION  ALL SELECT r, c, '.' FROM west_move
                EXCEPT ALL SELECT r, c, 'O' FROM west_move
                -- Initial state is cells, but not refreshed each round.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            west_move(r INT, c INT) AS (
                SELECT w1.r, w1.c
                FROM westward w1, westward w2
                WHERE w1.symbol = 'O'
                AND w1.r = w2.r
                AND w1.c = w2.c + 1
                AND w2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )

        SELECT * FROM westward
    ),

    south(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM west
            ),
            southward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM southward
                -- Anyone on the move does so
                UNION  ALL SELECT r + 1, c, 'O' FROM south_move
                EXCEPT ALL SELECT r + 1, c, '.' FROM south_move
                UNION  ALL SELECT r, c, '.' FROM south_move
                EXCEPT ALL SELECT r, c, 'O' FROM south_move
                -- Initial state is cells, but not refreshed each round.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            south_move(r INT, c INT) AS (
                SELECT s1.r, s1.c
                FROM southward s1, southward s2
                WHERE s1.symbol = 'O'
                AND s1.r = s2.r - 1
                AND s1.c = s2.c
                AND s2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )
        SELECT * FROM southward
    ),

    east(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM south
            ),
            eastward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM eastward
                -- Anyone on the move does so
                UNION  ALL SELECT r, c + 1, 'O' FROM east_move
                EXCEPT ALL SELECT r, c + 1, '.' FROM east_move
                UNION  ALL SELECT r, c, '.' FROM east_move
                EXCEPT ALL SELECT r, c, 'O' FROM east_move
                -- Initial state is cells, but not refreshed each round.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            east_move(r INT, c INT) AS (
                SELECT e1.r, e1.c
                FROM eastward e1, eastward e2
                WHERE e1.symbol = 'O'
                AND e1.r = e2.r
                AND e1.c = e2.c - 1
                AND e2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )
        SELECT * FROM eastward
    ),

    output (r INT, line TEXT) AS (
        SELECT r, string_agg(symbol, ' ' ORDER BY c)
        FROM round
        GROUP BY r
    ),

    transitions(source TEXT, target TEXT) AS (
        SELECT
            (SELECT string_agg(symbol, '' ORDER BY r, c) FROM round),
            (SELECT string_agg(symbol, '' ORDER BY r, c) FROM east)
        UNION ALL
        SELECT * FROM transitions
    ),

    part2(part2 BIGINT) AS (
        SELECT SUM(1 + (SELECT MAX(r) FROM lines) - r)
        FROM east
        WHERE symbol = 'O'
    ),

    cells_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM cells )

-- SELECT count, COUNT(*)
-- FROM (
--     SELECT source, target, COUNT(*) count
--     FROM transitions
--     GROUP BY source, target)
-- GROUP BY count;

-- SELECT * FROM output ORDER BY r;

SELECT * FROM part2;
----
105

query T multiline
EXPLAIN WITH MUTUALLY RECURSIVE (RETURN AT RECURSION LIMIT 142)

    lines(r INT, line TEXT) AS (
        SELECT r, regexp_split_to_array(input, '\n')[r] as block
        FROM input, generate_series(1, array_length(regexp_split_to_array(input, '\n'), 1)) r
    ),
    cells(r INT, c INT, symbol TEXT) AS (
        SELECT r, c, substring(line, c, 1)
        FROM lines, generate_series(1, length(line)) c
    ),

    -- Where should we start each iteration from?
    -- From `east`, once it exits, but initially `cells`.
    round(r INT, c INT, symbol TEXT) AS (
        SELECT * FROM east
        UNION  ALL SELECT * FROM cells
        EXCEPT ALL SELECT * FROM cells_delay
    ),

    north(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM round
            ),
            northward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM northward
                -- Anyone on the move does so
                UNION  ALL SELECT r - 1, c, 'O' FROM north_move
                EXCEPT ALL SELECT r - 1, c, '.' FROM north_move
                UNION  ALL SELECT r, c, '.' FROM north_move
                EXCEPT ALL SELECT r, c, 'O' FROM north_move
                -- Second time around, the above cancels and `east` is non-empty.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            north_move(r INT, c INT) AS (
                SELECT n1.r, n1.c
                FROM northward n1, northward n2
                WHERE n1.symbol = 'O'
                AND n1.r = n2.r + 1
                AND n1.c = n2.c
                AND n2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )

        SELECT * FROM northward
    ),

     west(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM north
            ),
            westward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM westward
                -- Anyone on the move does so
                UNION  ALL SELECT r, c - 1, 'O' FROM west_move
                EXCEPT ALL SELECT r, c - 1, '.' FROM west_move
                UNION  ALL SELECT r, c, '.' FROM west_move
                EXCEPT ALL SELECT r, c, 'O' FROM west_move
                -- Initial state is cells, but not refreshed each round.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            west_move(r INT, c INT) AS (
                SELECT w1.r, w1.c
                FROM westward w1, westward w2
                WHERE w1.symbol = 'O'
                AND w1.r = w2.r
                AND w1.c = w2.c + 1
                AND w2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )

        SELECT * FROM westward
    ),

    south(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM west
            ),
            southward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM southward
                -- Anyone on the move does so
                UNION  ALL SELECT r + 1, c, 'O' FROM south_move
                EXCEPT ALL SELECT r + 1, c, '.' FROM south_move
                UNION  ALL SELECT r, c, '.' FROM south_move
                EXCEPT ALL SELECT r, c, 'O' FROM south_move
                -- Initial state is cells, but not refreshed each round.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            south_move(r INT, c INT) AS (
                SELECT s1.r, s1.c
                FROM southward s1, southward s2
                WHERE s1.symbol = 'O'
                AND s1.r = s2.r - 1
                AND s1.c = s2.c
                AND s2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )
        SELECT * FROM southward
    ),

    east(r INT, c INT, symbol TEXT) AS (
        WITH MUTUALLY RECURSIVE
            start(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM south
            ),
            eastward(r INT, c INT, symbol TEXT) AS (
                SELECT * FROM eastward
                -- Anyone on the move does so
                UNION  ALL SELECT r, c + 1, 'O' FROM east_move
                EXCEPT ALL SELECT r, c + 1, '.' FROM east_move
                UNION  ALL SELECT r, c, '.' FROM east_move
                EXCEPT ALL SELECT r, c, 'O' FROM east_move
                -- Initial state is cells, but not refreshed each round.
                UNION  ALL SELECT * FROM start
                EXCEPT ALL SELECT * FROM start_delay
            ),
            -- Each 'O' with a '.' in front of them will move.
            east_move(r INT, c INT) AS (
                SELECT e1.r, e1.c
                FROM eastward e1, eastward e2
                WHERE e1.symbol = 'O'
                AND e1.r = e2.r
                AND e1.c = e2.c - 1
                AND e2.symbol = '.'
            ),
            start_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM start )
        SELECT * FROM eastward
    ),

    output (r INT, line TEXT) AS (
        SELECT r, string_agg(symbol, ' ' ORDER BY c)
        FROM round
        GROUP BY r
    ),

    transitions(source TEXT, target TEXT) AS (
        SELECT
            (SELECT string_agg(symbol, '' ORDER BY r, c) FROM round),
            (SELECT string_agg(symbol, '' ORDER BY r, c) FROM east)
        UNION ALL
        SELECT * FROM transitions
    ),

    part2(part2 BIGINT) AS (
        SELECT SUM(1 + (SELECT MAX(r) FROM lines) - r)
        FROM east
        WHERE symbol = 'O'
    ),

    cells_delay(r INT, c INT, symbol TEXT) AS ( SELECT * FROM cells )

-- SELECT count, COUNT(*)
-- FROM (
--     SELECT source, target, COUNT(*) count
--     FROM transitions
--     GROUP BY source, target)
-- GROUP BY count;

-- SELECT * FROM output ORDER BY r;

SELECT * FROM part2;
----
Explained Query:
  With
    cte l0 =
      Project (#1, #2)
        Map (array_index(regexp_split_to_array["\n", case_insensitive=false](#0), integer_to_bigint(#1)))
          FlatMap generate_series(1, (regexp_split_to_array["\n", case_insensitive=false](#0) array_length 1), 1)
            ReadStorage materialize.public.input
    cte l1 =
      Reduce aggregates=[max(#0)]
        Project (#0)
          Get l0
    cte l2 =
      Union
        Get l1
        Map (null)
          Union
            Negate
              Project ()
                Get l1
            Constant
              - ()
    cte l3 =
      Project (#0, #2, #3)
        Map (substr(#1, #2, 1))
          FlatMap generate_series(1, char_length(#1), 1)
            Get l0
  Return
    With Mutually Recursive
      cte [recursion_limit=142, return_at_limit] l4 =
        Threshold
          Union
            Get l20
            Get l3
            Negate
              Get l22
      cte l8 =
        With Mutually Recursive
          cte l5 =
            Threshold
              Union
                Threshold
                  Union
                    Threshold
                      Union
                        Get l5
                        Project (#2, #1, #3)
                          Map ((#0 - 1), "O")
                            Get l6
                        Negate
                          Project (#2, #1, #3)
                            Map ((#0 - 1), ".")
                              Get l6
                    Map (".")
                      Get l6
                    Negate
                      Map ("O")
                        Get l6
                Get l4
                Negate
                  Get l7
          cte l6 =
            Project (#0, #1)
              Join on=(#0 = (#2 + 1) AND #1 = #3) type=differential
                ArrangeBy keys=[[#1, #0]]
                  Project (#0, #1)
                    Filter (#2 = "O")
                      Get l5
                ArrangeBy keys=[[#1, (#0 + 1)]]
                  Project (#0, #1)
                    Filter (#2 = ".")
                      Get l5
          cte l7 =
            Get l4
        Return
          Get l5
      cte l12 =
        With Mutually Recursive
          cte l9 =
            Threshold
              Union
                Threshold
                  Union
                    Threshold
                      Union
                        Get l9
                        Project (#0, #2, #3)
                          Map ((#1 - 1), "O")
                            Get l10
                        Negate
                          Project (#0, #2, #3)
                            Map ((#1 - 1), ".")
                              Get l10
                    Map (".")
                      Get l10
                    Negate
                      Map ("O")
                        Get l10
                Get l8
                Negate
                  Get l11
          cte l10 =
            Project (#0, #1)
              Join on=(#0 = #2 AND #1 = (#3 + 1)) type=differential
                ArrangeBy keys=[[#0, #1]]
                  Project (#0, #1)
                    Filter (#2 = "O")
                      Get l9
                ArrangeBy keys=[[#0, (#1 + 1)]]
                  Project (#0, #1)
                    Filter (#2 = ".")
                      Get l9
          cte l11 =
            Get l8
        Return
          Get l9
      cte l16 =
        With Mutually Recursive
          cte l13 =
            Threshold
              Union
                Threshold
                  Union
                    Threshold
                      Union
                        Get l13
                        Project (#2, #1, #3)
                          Map ((#0 + 1), "O")
                            Get l14
                        Negate
                          Project (#2, #1, #3)
                            Map ((#0 + 1), ".")
                              Get l14
                    Map (".")
                      Get l14
                    Negate
                      Map ("O")
                        Get l14
                Get l12
                Negate
                  Get l15
          cte l14 =
            Project (#0, #1)
              Join on=(#0 = (#2 - 1) AND #1 = #3) type=differential
                ArrangeBy keys=[[#1, #0]]
                  Project (#0, #1)
                    Filter (#2 = "O")
                      Get l13
                ArrangeBy keys=[[#1, (#0 - 1)]]
                  Project (#0, #1)
                    Filter (#2 = ".")
                      Get l13
          cte l15 =
            Get l12
        Return
          Get l13
      cte [recursion_limit=142, return_at_limit] l20 =
        With Mutually Recursive
          cte l17 =
            Threshold
              Union
                Threshold
                  Union
                    Threshold
                      Union
                        Get l17
                        Project (#0, #2, #3)
                          Map ((#1 + 1), "O")
                            Get l18
                        Negate
                          Project (#0, #2, #3)
                            Map ((#1 + 1), ".")
                              Get l18
                    Map (".")
                      Get l18
                    Negate
                      Map ("O")
                        Get l18
                Get l16
                Negate
                  Get l19
          cte l18 =
            Project (#0, #1)
              Join on=(#0 = #2 AND #1 = (#3 - 1)) type=differential
                ArrangeBy keys=[[#0, #1]]
                  Project (#0, #1)
                    Filter (#2 = "O")
                      Get l17
                ArrangeBy keys=[[#0, (#1 - 1)]]
                  Project (#0, #1)
                    Filter (#2 = ".")
                      Get l17
          cte l19 =
            Get l16
        Return
          Get l17
      cte l21 =
        Reduce aggregates=[sum(((1 + #1) - #0))]
          CrossJoin type=differential
            ArrangeBy keys=[[]]
              Project (#0)
                Filter (#2 = "O")
                  Get l20
            ArrangeBy keys=[[]]
              Union
                Get l2
                Map (null)
                  Union
                    Negate
                      Project ()
                        Get l2
                    Constant
                      - ()
      cte [recursion_limit=142, return_at_limit] l22 =
        Get l3
    Return
      Union
        Get l21
        Map (null)
          Union
            Negate
              Project ()
                Get l21
            Constant
              - ()

Source materialize.public.input

Target cluster: quickstart

EOF
