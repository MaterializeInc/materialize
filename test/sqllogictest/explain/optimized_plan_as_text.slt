# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

simple conn=mz_system,user=mz_system
ALTER SYSTEM SET enable_table_keys = true
----
COMPLETE 0

statement ok
CREATE TABLE t (
  a int,
  b int
);

statement ok
CREATE TABLE u (
  c int,
  d int
);

statement ok
CREATE TABLE v (
  e int,
  f int
);

statement ok
CREATE INDEX t_a_idx ON t(a);

statement ok
CREATE VIEW ov AS SELECT * FROM t ORDER BY b asc, a desc LIMIT 5;

statement ok
CREATE VIEW iv AS
SELECT * FROM t WHERE a IS NOT NULL;

statement ok
CREATE INDEX iv_a_idx ON iv(a);

statement ok
CREATE INDEX iv_b_idx ON iv(b);

# This is an identical index to the above (on the same object, on the same key)
statement ok
CREATE INDEX iv_b_idx_2 ON iv(b);

statement ok
CREATE MATERIALIZED VIEW mv AS
SELECT * FROM t WHERE a IS NOT NULL;

mode cockroach

# Test constant error.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT 1 / 0
----
Explained Query (fast path):
  Error "division by zero"

EOF

# Test constant with two elements.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
(SELECT 1, 2) UNION ALL (SELECT 1, 2) UNION ALL (SELECT 3, 4)
----
Explained Query (fast path):
  Constant
    - ((1, 2) x 2)
    - (3, 4)

EOF

# Test introspection queries (index found based on cluster auto-routing).
query T multiline
EXPLAIN SELECT * FROM mz_internal.mz_source_status_history
----
Explained Query (fast path):
  Project (#1, #0, #2..=#4)
    ReadIndex on=mz_internal.mz_source_status_history mz_source_status_history_ind=[*** full scan ***]

Used Indexes:
  - mz_internal.mz_source_status_history_ind (*** full scan ***)

EOF

# Test basic linear chains (fast path).
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT 1, a + b as c FROM t WHERE a > 0 and b < 0 and a + b > 0
----
Explained Query (fast path):
  Project (#3, #2)
    Filter (#0 > 0) AND (#1 < 0) AND (#2 > 0)
      Map ((#0 + #1), 1)
        ReadIndex on=materialize.public.t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test basic linear chains (slow path).
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT 1, a + b as c FROM mv WHERE a > 0 and b < 0 and a + b > 0
----
Explained Query:
  Project (#3, #2)
    Filter (#1 < 0) AND (#0 > 0) AND (#2 > 0)
      Map ((#0 + #1), 1)
        ReadStorage materialize.public.mv

Source materialize.public.mv
  filter=((#0 > 0) AND (#1 < 0) AND ((#0 + #1) > 0))

EOF

# Test table functions in the select clause (FlatMap).
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT generate_series(a, b) from t
----
Explained Query:
  Project (#2)
    FlatMap generate_series(#0, #1, 1)
      ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test Threshold, Union, Distinct, Negate.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT a FROM t EXCEPT SELECT b FROM mv
----
Explained Query:
  Threshold
    Union
      Distinct project=[#0]
        Project (#0)
          ReadIndex on=t t_a_idx=[*** full scan ***]
      Negate
        Distinct project=[#0]
          Project (#1)
            ReadStorage materialize.public.mv

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test Threshold, Union, Distinct, Negate.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT a FROM t EXCEPT ALL SELECT b FROM mv
----
Explained Query:
  Threshold
    Union
      Project (#0)
        ReadIndex on=t t_a_idx=[*** full scan ***]
      Negate
        Project (#1)
          ReadStorage materialize.public.mv

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test TopK.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT * FROM ov
----
Explained Query:
  TopK order_by=[#1 asc nulls_last, #0 desc nulls_first] limit=5
    ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test Finish.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT * FROM t ORDER BY b asc, a desc LIMIT 5
----
Explained Query (fast path):
  Finish order_by=[#1 asc nulls_last, #0 desc nulls_first] limit=5 output=[#0, #1]
    ReadIndex on=materialize.public.t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test Reduce (global).
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT abs(min(a) - max(a)) FROM t
----
Explained Query:
  Return
    Project (#2)
      Map (abs((#0 - #1)))
        Union
          Get l0
          Map (null, null)
            Union
              Negate
                Project ()
                  Get l0
              Constant
                - ()
  With
    cte l0 =
      Reduce aggregates=[min(#0), max(#0)]
        Project (#0)
          ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test Reduce (local).
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT abs(min(a) - max(a)) FROM t GROUP BY b
----
Explained Query:
  Project (#3)
    Map (abs((#1 - #2)))
      Reduce group_by=[#1] aggregates=[min(#0), max(#0)]
        ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test EXISTS subqueries.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT * FROM t WHERE EXISTS(SELECT * FROM mv WHERE t.a < mv.a) AND EXISTS(SELECT * FROM mv WHERE t.b > mv.b)
----
Explained Query:
  Return
    Project (#0, #1)
      Join on=(#1 = #2) type=differential
        ArrangeBy keys=[[#1]]
          Get l0
        ArrangeBy keys=[[#0]]
          Distinct project=[#0]
            Project (#0)
              Filter (#0 > #1)
                CrossJoin type=differential
                  ArrangeBy keys=[[]]
                    Distinct project=[#0]
                      Project (#1)
                        Get l0
                  ArrangeBy keys=[[]]
                    Project (#1)
                      ReadStorage materialize.public.mv
  With
    cte l0 =
      Project (#0, #1)
        Join on=(#0 = #2) type=differential
          ArrangeBy keys=[[#0]]
            ReadIndex on=t t_a_idx=[differential join]
          ArrangeBy keys=[[#0]]
            Distinct project=[#0]
              Project (#0)
                Filter (#0 < #1)
                  CrossJoin type=differential
                    ArrangeBy keys=[[]]
                      Distinct project=[#0]
                        Project (#0)
                          ReadIndex on=t t_a_idx=[*** full scan ***]
                    ArrangeBy keys=[[]]
                      Project (#0)
                        ReadStorage materialize.public.mv

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***, differential join)

EOF

# Test SELECT subqueries.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT (SELECT iv.a FROM iv WHERE iv.b = t.b LIMIT 1), (SELECT mv.a FROM mv WHERE mv.b = t.b LIMIT 1) FROM t
----
Explained Query:
  Return
    Project (#2, #4)
      Join on=(#0 = #1 = #3) type=delta
        ArrangeBy keys=[[#0]]
          Get l0
        ArrangeBy keys=[[#0]]
          Union
            Get l3
            Map (null)
              Union
                Negate
                  Project (#0)
                    Get l3
                Get l1
        ArrangeBy keys=[[#0]]
          Union
            Get l4
            Map (null)
              Union
                Negate
                  Project (#0)
                    Get l4
                Get l1
  With
    cte l4 =
      TopK group_by=[#0] limit=1
        Project (#0, #1)
          Filter (#0) IS NOT NULL
            Join on=(#0 = #2) type=differential
              Get l2
              ArrangeBy keys=[[#1]]
                Filter (#1) IS NOT NULL
                  ReadStorage materialize.public.mv
    cte l3 =
      TopK group_by=[#0] limit=1
        Project (#0, #1)
          Filter (#0) IS NOT NULL
            Join on=(#0 = #2) type=differential
              Get l2
              ArrangeBy keys=[[#1]]
                ReadIndex on=iv iv_b_idx=[differential join]
    cte l2 =
      ArrangeBy keys=[[#0]]
        Get l1
    cte l1 =
      Distinct project=[#0]
        Get l0
    cte l0 =
      Project (#1)
        ReadIndex on=t t_a_idx=[*** full scan ***]

Source materialize.public.mv
  filter=((#1) IS NOT NULL)

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)
  - materialize.public.iv_b_idx (differential join)

EOF

# Test outer joins (ON syntax).
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT t1.a, t2.a
FROM t as t1
LEFT JOIN t as t2 ON t1.b = t2.b
RIGHT JOIN t as t3 ON t2.b = t3.b
----
Explained Query:
  Return
    Union
      Map (null, null)
        Union
          Negate
            Project ()
              Join on=(#0 = #1) type=differential
                ArrangeBy keys=[[#0]]
                  Project (#1)
                    ReadIndex on=t t_a_idx=[*** full scan ***]
                ArrangeBy keys=[[#0]]
                  Distinct project=[#0]
                    Project (#1)
                      Get l2
          Project ()
            ReadIndex on=t t_a_idx=[*** full scan ***]
      Project (#0, #2)
        Get l2
  With
    cte l2 =
      Project (#0..=#2)
        Join on=(#1 = #3 = #4) type=delta
          Get l1
          Get l1
          ArrangeBy keys=[[#0]]
            Project (#1)
              Get l0
    cte l1 =
      ArrangeBy keys=[[#1]]
        Get l0
    cte l0 =
      Filter (#1) IS NOT NULL
        ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test a single CTE.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
WITH x AS (SELECT t.a * t.b as v from t) SELECT a.v + b.v FROM x as a, x as b
----
Explained Query:
  Return
    Project (#2)
      Map ((#0 + #1))
        CrossJoin type=differential
          Get l0
          Get l0
  With
    cte l0 =
      ArrangeBy keys=[[]]
        Project (#2)
          Map ((#0 * #1))
            ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test EXPLAIN INDEX for an indexed source
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
INDEX t_a_idx
----
materialize.public.t_a_idx:
  ArrangeBy keys=[[#0]]
    ReadStorage materialize.public.t

EOF

# Test EXPLAIN INDEX for an indexed view (first index)
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
INDEX iv_a_idx;
----
materialize.public.iv_a_idx:
  ArrangeBy keys=[[#0]]
    ReadGlobalFromSameDataflow materialize.public.iv

materialize.public.iv:
  Filter (#0) IS NOT NULL
    ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test EXPLAIN INDEX for an indexed view (based on a prior index)
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
INDEX iv_b_idx;
----
materialize.public.iv_b_idx:
  ArrangeBy keys=[[#1]]
    ReadIndex on=iv iv_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.iv_a_idx (*** full scan ***, index export)

EOF

# Test EXPLAIN INDEX for an indexed view where the index is exactly the same as a prior index.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
INDEX iv_b_idx_2;
----
materialize.public.iv_b_idx_2:
  ArrangeBy keys=[[#1]]
    ReadIndex on=iv iv_b_idx=[plan root (no new arrangement)]

Used Indexes:
  - materialize.public.iv_b_idx (plan root (no new arrangement), index export)

Notices:
  - Notice: The current index is identical to materialize.public.iv_b_idx, which is also defined on iv(b).
    Hint: Please drop all indexes except the first index created on iv(b) and recreate all dependent objects.

EOF

# Test multiple CTEs: a case where we cannot pull the let statement up through
# the join because the local l0 is correlated against the lhs of the enclosing join.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT
  *
FROM
  (
    SELECT * FROM t
  ) as r1
  CROSS JOIN LATERAL (
    WITH r2 as (
      SELECT MAX(r1.a * t.a) AS m FROM t
    )
    SELECT * FROM r2 WHERE r2.m != r1.a
  ) as r3
  CROSS JOIN LATERAL (
    WITH r4 as (
      SELECT MAX(r1.a * t.a) AS m FROM t
    )
    SELECT * FROM r4 WHERE r4.m != r1.a OR (r4.m IS NOT NULL AND r1.a IS NULL)
  ) as r5;
----
Explained Query:
  Return
    Project (#0..=#2, #4)
      Filter (#0 != #4)
        Join on=(#0 = #3) type=differential
          ArrangeBy keys=[[#0]]
            Get l2
          ArrangeBy keys=[[#0]]
            Reduce group_by=[#0] aggregates=[max((#0 * #1))]
              CrossJoin type=differential
                ArrangeBy keys=[[]]
                  Distinct project=[#0]
                    Project (#0)
                      Get l2
                Get l1
  With
    cte l2 =
      Project (#0, #1, #3)
        Filter (#0 != #3)
          Join on=(#0 = #2) type=differential
            ArrangeBy keys=[[#0]]
              ReadIndex on=t t_a_idx=[differential join]
            ArrangeBy keys=[[#0]]
              Reduce group_by=[#0] aggregates=[max((#0 * #1))]
                CrossJoin type=differential
                  ArrangeBy keys=[[]]
                    Distinct project=[#0]
                      Get l0
                  Get l1
    cte l1 =
      ArrangeBy keys=[[]]
        Get l0
    cte l0 =
      Project (#0)
        ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***, differential join)

EOF

# Test cross join.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT t1.a, t2.a FROM t as t1, t as t2
----
Explained Query:
  Return
    CrossJoin type=differential
      Get l0
      Get l0
  With
    cte l0 =
      ArrangeBy keys=[[]]
        Project (#0)
          ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Test cyclic join.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT t1.a, t2.a
FROM
  t as t1,
  t as t2,
  t as t3
WHERE t1.b = t2.b AND t2.b = t3.b
----
Explained Query:
  Return
    Project (#0, #2)
      Join on=(#1 = #3 = #4) type=delta
        Get l1
        Get l1
        ArrangeBy keys=[[#0]]
          Project (#1)
            Get l0
  With
    cte l1 =
      ArrangeBy keys=[[#1]]
        Get l0
    cte l0 =
      Filter (#1) IS NOT NULL
        ReadIndex on=t t_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)

EOF

# Create indexes required for differential join tests

statement ok
CREATE INDEX u_c_idx ON U(c);

statement ok
CREATE INDEX u_d_idx ON U(d);

statement ok
CREATE INDEX v_e_idx ON V(e);

# Test a differential join.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT a, b, c, d, e, f
FROM t, u, v
WHERE a = c and d = e and b = f
----
Explained Query:
  Project (#0, #1, #0, #3, #3, #1)
    Filter (#0) IS NOT NULL AND (#3) IS NOT NULL
      Join on=(#0 = #2 AND #1 = #5 AND #3 = #4) type=delta
        ArrangeBy keys=[[#0], [#0, #1]]
          Filter (#0) IS NOT NULL AND (#1) IS NOT NULL
            ReadIndex on=t t_a_idx=[*** full scan ***]
        ArrangeBy keys=[[#0], [#1]]
          ReadIndex on=u u_c_idx=[delta join lookup] u_d_idx=[delta join lookup]
        ArrangeBy keys=[[#0, #1]]
          Filter (#0) IS NOT NULL AND (#1) IS NOT NULL
            ReadIndex on=v v_e_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)
  - materialize.public.u_c_idx (delta join lookup)
  - materialize.public.u_d_idx (delta join lookup)
  - materialize.public.v_e_idx (*** full scan ***)

EOF

# Test a differential join WITH(join implementations).
query T multiline
EXPLAIN OPTIMIZED PLAN WITH(join implementations) AS TEXT FOR
SELECT a, b, c, d, e, f
FROM t, u, v
WHERE a = c and d = e and b = f
----
Explained Query:
  Project (#0, #1, #0, #3, #3, #1)
    Filter (#0) IS NOT NULL AND (#3) IS NOT NULL
      Join on=(#0 = #2 AND #1 = #5 AND #3 = #4) type=delta
        implementation
          %0:t » %1:u[#0]KA » %2:v[#0, #1]KK
          %1:u » %0:t[#0]KA » %2:v[#0, #1]KK
          %2:v » %1:u[#1]KA » %0:t[#0, #1]KK
        ArrangeBy keys=[[#0], [#0, #1]]
          Filter (#0) IS NOT NULL AND (#1) IS NOT NULL
            ReadIndex on=t t_a_idx=[*** full scan ***]
        ArrangeBy keys=[[#0], [#1]]
          ReadIndex on=u u_c_idx=[delta join lookup] u_d_idx=[delta join lookup]
        ArrangeBy keys=[[#0, #1]]
          Filter (#0) IS NOT NULL AND (#1) IS NOT NULL
            ReadIndex on=v v_e_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx (*** full scan ***)
  - materialize.public.u_c_idx (delta join lookup)
  - materialize.public.u_d_idx (delta join lookup)
  - materialize.public.v_e_idx (*** full scan ***)

EOF

# Create indexes required for delta join tests

statement ok
CREATE INDEX t_b_idx ON T(b);

# Test a delta join without WITH(join implementations).
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT a, b, c, d, e, f
FROM t, u, v
WHERE b = c and d = e
----
Explained Query:
  Project (#0, #1, #1, #3, #3, #5)
    Filter (#1) IS NOT NULL AND (#3) IS NOT NULL
      Join on=(#1 = #2 AND #3 = #4) type=delta
        ArrangeBy keys=[[#1]]
          ReadIndex on=t t_b_idx=[delta join 1st input (full scan)]
        ArrangeBy keys=[[#0], [#1]]
          ReadIndex on=u u_c_idx=[delta join lookup] u_d_idx=[delta join lookup]
        ArrangeBy keys=[[#0]]
          ReadIndex on=v v_e_idx=[delta join lookup]

Used Indexes:
  - materialize.public.u_c_idx (delta join lookup)
  - materialize.public.u_d_idx (delta join lookup)
  - materialize.public.v_e_idx (delta join lookup)
  - materialize.public.t_b_idx (delta join 1st input (full scan))

EOF

# Test a delta join WITH(join implementations).
query T multiline
EXPLAIN OPTIMIZED PLAN WITH(join implementations) AS TEXT FOR
SELECT a, b, c, d, e, f
FROM t, u, v
WHERE b = c and d = e
----
Explained Query:
  Project (#0, #1, #1, #3, #3, #5)
    Filter (#1) IS NOT NULL AND (#3) IS NOT NULL
      Join on=(#1 = #2 AND #3 = #4) type=delta
        implementation
          %0:t » %1:u[#0]KA » %2:v[#0]KA
          %1:u » %0:t[#1]KA » %2:v[#0]KA
          %2:v » %1:u[#1]KA » %0:t[#1]KA
        ArrangeBy keys=[[#1]]
          ReadIndex on=t t_b_idx=[delta join 1st input (full scan)]
        ArrangeBy keys=[[#0], [#1]]
          ReadIndex on=u u_c_idx=[delta join lookup] u_d_idx=[delta join lookup]
        ArrangeBy keys=[[#0]]
          ReadIndex on=v v_e_idx=[delta join lookup]

Used Indexes:
  - materialize.public.u_c_idx (delta join lookup)
  - materialize.public.u_d_idx (delta join lookup)
  - materialize.public.v_e_idx (delta join lookup)
  - materialize.public.t_b_idx (delta join 1st input (full scan))

EOF

# Test an IndexedFilter join.
query T multiline
EXPLAIN OPTIMIZED PLAN AS TEXT FOR
SELECT a, max(b)
FROM t
WHERE a = 0
GROUP BY a
----
Explained Query:
  Project (#1, #0)
    Map (0)
      Reduce aggregates=[max(#0)]
        Project (#1)
          ReadIndex on=materialize.public.t t_a_idx=[lookup value=(0)]

Used Indexes:
  - materialize.public.t_a_idx (lookup)

EOF

# Create index for IndexedFilter test

statement ok
CREATE INDEX t_a_b_idx ON T(a,b)

# Test an IndexedFilter join WITH(join implementations).
query T multiline
EXPLAIN OPTIMIZED PLAN WITH(join implementations) AS TEXT FOR
SELECT a, max(b)
FROM t
WHERE (a = 0 AND b = 1) OR (a = 3 AND b = 4) OR (a = 7 AND b = 8)
GROUP BY a
----
Explained Query:
  Reduce group_by=[#0] aggregates=[max(#1)]
    Project (#0, #1)
      ReadIndex on=materialize.public.t t_a_b_idx=[lookup values=[(0, 1); (3, 4); (7, 8)]]

Used Indexes:
  - materialize.public.t_a_b_idx (lookup)

EOF

# Test an IndexedFilter join on fast path WITH(join implementations).
query T multiline
EXPLAIN OPTIMIZED PLAN WITH(join implementations) AS TEXT FOR
SELECT *
FROM t
WHERE (a = 0 AND b = 1) OR (a = 3 AND b = 4) OR (a = 7 AND b = 8)
----
Explained Query (fast path):
  Project (#0, #1)
    ReadIndex on=materialize.public.t t_a_b_idx=[lookup values=[(0, 1); (3, 4); (7, 8)]]

Used Indexes:
  - materialize.public.t_a_b_idx (lookup)

EOF

# Test #17348.

statement ok
CREATE TABLE r(f0 INT, f1 INT, f2 INT, f3 INT, f4 INT, f5 INT, f6 INT, f7 INT, f8 INT, f9 INT, f10 INT, f11 INT, f12 INT, f13 INT, f14 INT, f15 INT, f16 INT);

query T multiline
EXPLAIN SELECT *
FROM r AS r0, r AS r1
WHERE
  r0.f0=r1.f0 AND
  r0.f2=r1.f2 AND
  r0.f3=r1.f3 AND
  r0.f4=r1.f4 AND
  r0.f6=r1.f6 AND
  r0.f8=r1.f8 AND
  r0.f9=r1.f9 AND
  r0.f11=r1.f11 AND
  r0.f12=r1.f12 AND
  r0.f13=r1.f13 AND
  r0.f15=r1.f15 AND
  r0.f16=r1.f16;
----
Explained Query:
  Return
    Project (#0..=#16, #0, #18, #2..=#4, #22, #6, #24, #8, #9, #27, #11..=#13, #31, #15, #16)
      Join on=(#0 = #17 AND #2 = #19 AND #3 = #20 AND #4 = #21 AND #6 = #23 AND #8 = #25 AND #9 = #26 AND #11 = #28 AND #12 = #29 AND #13 = #30 AND #15 = #32 AND #16 = #33) type=differential
        Get l0
        Get l0
  With
    cte l0 =
      ArrangeBy keys=[[#0, #2..=#4, #6, #8, #9, #11..=#13, #15, #16]]
        Filter (#0) IS NOT NULL AND (#2) IS NOT NULL AND (#3) IS NOT NULL AND (#4) IS NOT NULL AND (#6) IS NOT NULL AND (#8) IS NOT NULL AND (#9) IS NOT NULL AND (#11) IS NOT NULL AND (#12) IS NOT NULL AND (#13) IS NOT NULL AND (#15) IS NOT NULL AND (#16) IS NOT NULL
          ReadStorage materialize.public.r

Source materialize.public.r
  filter=((#0) IS NOT NULL AND (#2) IS NOT NULL AND (#3) IS NOT NULL AND (#4) IS NOT NULL AND (#6) IS NOT NULL AND (#8) IS NOT NULL AND (#9) IS NOT NULL AND (#11) IS NOT NULL AND (#12) IS NOT NULL AND (#13) IS NOT NULL AND (#15) IS NOT NULL AND (#16) IS NOT NULL)

EOF

## linear chains is currently disabled for WMR.
statement error not supported
EXPLAIN WITH(linear chains)
WITH MUTUALLY RECURSIVE
    foo (a int, b int) AS (SELECT 1, 2 UNION SELECT a, 7 FROM bar),
    bar (a int) as (SELECT a FROM foo)
SELECT * FROM bar;

# Regression test for #19148: support mz_now() on select from indexed table
# ---

simple conn=mz_system,user=mz_system
ALTER SYSTEM SET enable_rbac_checks TO false;
----
COMPLETE 0

statement ok
DROP SCHEMA IF EXISTS public CASCADE;

simple conn=mz_system,user=mz_system
ALTER SYSTEM RESET enable_rbac_checks;
----
COMPLETE 0

statement ok
CREATE SCHEMA public;

statement ok
CREATE TABLE t(a TIMESTAMP);

statement ok
CREATE DEFAULT INDEX ON t;

# EXPLAIN output is time-dependent, so we don't want show the output here, just
# assert that the query doesn't fail.
statement ok
EXPLAIN SELECT * FROM t WHERE a < mz_now();

# Regression test for #19177
# ---

statement ok
DROP SCHEMA IF EXISTS public CASCADE;

statement ok
CREATE SCHEMA public;

statement ok
CREATE TABLE t1(x text);

statement ok
CREATE TABLE t2(x text);

statement ok
EXPLAIN SELECT * FROM t1, t2 WHERE t1.x || mz_internal.mz_session_id()  = t2.x || mz_internal.mz_session_id();

# Regression test for the join visitation part of #19177
statement ok
EXPLAIN SELECT * FROM t1, t2 WHERE t1.x || mz_now()  = t2.x || mz_now();

query T multiline
EXPLAIN
SELECT lag(x, 3, 'default') IGNORE NULLS OVER (ORDER BY x || x)
FROM t1;
----
Explained Query:
  Project (#2)
    Map (record_get[0](#1))
      FlatMap unnest_list(#0)
        Reduce aggregates=[lag[ignore_nulls=true, order_by=[#0 asc nulls_last]](row(row(row(#0), row(#0, 3, "default")), (#0 || #0)))]
          ReadStorage materialize.public.t1

EOF

query T multiline
EXPLAIN
SELECT first_value(x) OVER (ORDER BY x || x ROWS BETWEEN 5 preceding AND CURRENT ROW)
FROM t1;
----
Explained Query:
  Project (#2)
    Map (record_get[0](#1))
      FlatMap unnest_list(#0)
        Reduce aggregates=[first_value[order_by=[#0 asc nulls_last] rows between 5 preceding and current row](row(row(row(#0), #0), (#0 || #0)))]
          ReadStorage materialize.public.t1

EOF

## "Used indexes" tests

statement ok
CREATE TABLE t (
  a int,
  b int
);

statement ok
CREATE TABLE u (
  c int,
  d int
);

# If two indexes exist on the same table, then "Used indexes" should print the one that we are actually going to use

statement ok
CREATE INDEX u_c ON u(c);

statement ok
CREATE INDEX u_d ON u(d);

query T multiline
EXPLAIN
SELECT *
FROM t, u
WHERE t.b = u.c;
----
Explained Query:
  Project (#0, #1, #1, #3)
    Filter (#1) IS NOT NULL
      Join on=(#1 = #2) type=differential
        ArrangeBy keys=[[#1]]
          Filter (#1) IS NOT NULL
            ReadStorage materialize.public.t
        ArrangeBy keys=[[#0]]
          ReadIndex on=u u_c=[differential join]

Source materialize.public.t
  filter=((#1) IS NOT NULL)

Used Indexes:
  - materialize.public.u_c (differential join)

EOF

query T multiline
EXPLAIN
SELECT *
FROM t, u
WHERE t.b = u.d;
----
Explained Query:
  Project (#0..=#2, #1)
    Filter (#1) IS NOT NULL
      Join on=(#1 = #3) type=differential
        ArrangeBy keys=[[#1]]
          Filter (#1) IS NOT NULL
            ReadStorage materialize.public.t
        ArrangeBy keys=[[#1]]
          ReadIndex on=u u_d=[differential join]

Source materialize.public.t
  filter=((#1) IS NOT NULL)

Used Indexes:
  - materialize.public.u_d (differential join)

EOF

statement ok
DROP INDEX u_c;

# Let's test the weird situation that two identical indexes exist.

statement ok
CREATE INDEX t_a_idx_1 ON t(a);

statement ok
CREATE INDEX t_a_idx_2 ON t(a);

query T multiline
EXPLAIN
SELECT *
FROM t, u
WHERE t.a = u.c
----
Explained Query:
  Project (#0, #1, #0, #3)
    Filter (#0) IS NOT NULL
      Join on=(#0 = #2) type=differential
        ArrangeBy keys=[[#0]]
          ReadIndex on=t t_a_idx_1=[differential join]
        ArrangeBy keys=[[#0]]
          Filter (#0) IS NOT NULL
            ReadIndex on=u u_d=[*** full scan ***]

Used Indexes:
  - materialize.public.u_d (*** full scan ***)
  - materialize.public.t_a_idx_1 (differential join)

EOF

# An index is used two times by the same (self) join. We should show a 1st input and a non-1st input usage.
query T multiline
EXPLAIN
SELECT *
FROM t AS t1, t AS t2, t AS t3
WHERE t1.a = t2.a AND t2.a = t3.a;
----
Explained Query:
  Return
    Project (#0, #1, #0, #3, #0, #5)
      Filter (#0) IS NOT NULL
        Join on=(#0 = #2 = #4) type=delta
          Get l0
          Get l0
          Get l0
  With
    cte l0 =
      ArrangeBy keys=[[#0]]
        ReadIndex on=t t_a_idx_1=[delta join lookup, delta join 1st input (full scan)]

Used Indexes:
  - materialize.public.t_a_idx_1 (delta join lookup, delta join 1st input (full scan))

EOF

# An index is used in both a join and a full scan.
query T multiline
EXPLAIN
(SELECT t1.a + t2.a AS a, t1.b + t2.b AS b
 FROM t AS t1, t AS t2
 WHERE t1.a = t2.a)
UNION
(SELECT *
 FROM t
 WHERE b > 5)
----
Explained Query:
  Return
    Distinct project=[#0, #1]
      Union
        Project (#4, #5)
          Filter (#0) IS NOT NULL
            Map ((#0 + #0), (#1 + #3))
              Join on=(#0 = #2) type=differential
                Get l0
                Get l0
        Filter (#1 > 5)
          ReadIndex on=t t_a_idx_1=[*** full scan ***]
  With
    cte l0 =
      ArrangeBy keys=[[#0]]
        ReadIndex on=t t_a_idx_1=[differential join]

Used Indexes:
  - materialize.public.t_a_idx_1 (*** full scan ***, differential join)

EOF

# An index exists that can't be used for the join because of having the wrong key.
query T multiline
EXPLAIN
(SELECT t1.a + t2.a AS a, t1.b + t2.b AS b
 FROM t AS t1, t AS t2
 WHERE t1.b = t2.b)
UNION
(SELECT *
 FROM t
 WHERE b > 5)
----
Explained Query:
  Return
    Distinct project=[#0, #1]
      Union
        Project (#4, #5)
          Map ((#0 + #2), (#1 + #1))
            Join on=(#1 = #3) type=differential
              Get l0
              Get l0
        Filter (#1 > 5)
          ReadIndex on=t t_a_idx_1=[*** full scan ***]
  With
    cte l0 =
      ArrangeBy keys=[[#1]]
        Filter (#1) IS NOT NULL
          ReadIndex on=t t_a_idx_1=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx_1 (*** full scan ***)

EOF

# Similar to the previous test, but exercises the full scan code inside the context loop of the Get case in
# `collect_index_reqs_inner`, where we don't have an index for the requested key.

statement ok
CREATE TABLE t_non_null (
  a int NOT NULL,
  b int NOT NULL
);

statement ok
CREATE INDEX t_non_null_a_idx ON t_non_null(a);

query T multiline
EXPLAIN
(SELECT t1.a + t2.a AS a, t1.b + t2.b AS b
 FROM t_non_null AS t1, t_non_null AS t2
 WHERE t1.b = t2.b)
UNION
(SELECT *
 FROM t_non_null
 WHERE b > 5)
----
Explained Query:
  Return
    Distinct project=[#0, #1]
      Union
        Project (#4, #5)
          Map ((#0 + #2), (#1 + #1))
            Join on=(#1 = #3) type=differential
              Get l0
              Get l0
        Filter (#1 > 5)
          ReadIndex on=t_non_null t_non_null_a_idx=[*** full scan ***]
  With
    cte l0 =
      ArrangeBy keys=[[#1]]
        ReadIndex on=t_non_null t_non_null_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_non_null_a_idx (*** full scan ***)

EOF

# This has 1 more full scan than the previous test, because the join needs 2 different arrangements.
# (But we print only one full scan due to deduplication.)
query T multiline
EXPLAIN
(SELECT t1.a + t2.a AS a, t1.b + t2.b AS b
 FROM t_non_null AS t1, t_non_null AS t2
 WHERE t1.b = t2.b + 1)
UNION
(SELECT *
 FROM t_non_null
 WHERE b > 5)
----
Explained Query:
  Distinct project=[#0, #1]
    Union
      Project (#4, #5)
        Map ((#0 + #2), (#1 + #3))
          Join on=(#1 = (#3 + 1)) type=differential
            ArrangeBy keys=[[#1]]
              ReadIndex on=t_non_null t_non_null_a_idx=[*** full scan ***]
            ArrangeBy keys=[[(#1 + 1)]]
              ReadIndex on=t_non_null t_non_null_a_idx=[*** full scan ***]
      Filter (#1 > 5)
        ReadIndex on=t_non_null t_non_null_a_idx=[*** full scan ***]

Used Indexes:
  - materialize.public.t_non_null_a_idx (*** full scan ***)

EOF

# An index is used in both a lookup and a full scan.
query T multiline
EXPLAIN
SELECT * FROM t
UNION
SELECT * FROM t WHERE a = 5;
----
Explained Query:
  Distinct project=[#0, #1]
    Union
      ReadIndex on=t t_a_idx_2=[*** full scan ***]
      Project (#0, #1)
        ReadIndex on=materialize.public.t t_a_idx_2=[lookup value=(5)]

Used Indexes:
  - materialize.public.t_a_idx_2 (*** full scan ***, lookup)

EOF

# Several lookups using different indexes

statement ok
CREATE INDEX t_b_idx ON t(b);

query T multiline
EXPLAIN
SELECT * FROM t
UNION ALL
SELECT * FROM t WHERE b = 7
UNION ALL
SELECT * FROM t WHERE a = 5
UNION ALL
SELECT * FROM u WHERE c = 3
UNION ALL
SELECT * FROM u WHERE d = 1;
----
Explained Query:
  Union
    ReadIndex on=t t_b_idx=[*** full scan ***]
    Project (#0, #1)
      ReadIndex on=materialize.public.t t_b_idx=[lookup value=(7)]
    Project (#0, #1)
      ReadIndex on=materialize.public.t t_a_idx_2=[lookup value=(5)]
    Filter (#0 = 3)
      ReadIndex on=u u_d=[*** full scan ***]
    Project (#0, #1)
      ReadIndex on=materialize.public.u u_d=[lookup value=(1)]

Used Indexes:
  - materialize.public.u_d (*** full scan ***, lookup)
  - materialize.public.t_a_idx_2 (lookup)
  - materialize.public.t_b_idx (*** full scan ***, lookup)

EOF

# Fast path with a LIMIT and no ORDER BY. This is not a full scan.
query T multiline
EXPLAIN
SELECT a+b as x
FROM t
WHERE a < 7
LIMIT 3;
----
Explained Query (fast path):
  Finish limit=3 output=[#0]
    Project (#2)
      Filter (#0 < 7)
        Map ((#0 + #1))
          ReadIndex on=materialize.public.t t_a_idx_1=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx_1 (fast path limit)

EOF

# Same query without a LIMIT, so full scan
query T multiline
EXPLAIN
SELECT a+b as x
FROM t
WHERE a < 7;
----
Explained Query (fast path):
  Project (#2)
    Filter (#0 < 7)
      Map ((#0 + #1))
        ReadIndex on=materialize.public.t t_a_idx_1=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx_1 (*** full scan ***)

EOF

# Same query with a LIMIT + ORDER BY, so full scan
query T multiline
EXPLAIN
SELECT a+b as x
FROM t
WHERE a < 7
ORDER BY x
LIMIT 3;
----
Explained Query (fast path):
  Finish order_by=[#0 asc nulls_last] limit=3 output=[#0]
    Project (#2)
      Filter (#0 < 7)
        Map ((#0 + #1))
          ReadIndex on=materialize.public.t t_a_idx_1=[*** full scan ***]

Used Indexes:
  - materialize.public.t_a_idx_1 (*** full scan ***)

EOF

# We should choose an index whose key is a unique key (if exists)
statement ok
CREATE TABLE t4(
    a int,
    b int primary key,
    c int
);

statement ok
CREATE INDEX t4_idx_a ON t4(a);

statement ok
CREATE INDEX t4_idx_b ON t4(b);

statement ok
CREATE INDEX t4_idx_c ON t4(c);

query T multiline
EXPLAIN
SELECT * FROM t4;
----
Explained Query (fast path):
  Project (#1, #0, #2)
    ReadIndex on=materialize.public.t4 t4_idx_b=[*** full scan ***]

Used Indexes:
  - materialize.public.t4_idx_b (*** full scan ***)

EOF
