# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.


statement ok
CREATE TABLE t (
  a int,
  b int
)

statement ok
CREATE TABLE u (
  c int,
  d int
)

statement ok
CREATE INDEX t_a_idx ON T(a);

statement ok
CREATE INDEX t_b_idx ON T(b);

statement ok
CREATE VIEW ov AS SELECT * FROM t ORDER BY b asc, a desc LIMIT 5

statement ok
CREATE MATERIALIZED VIEW mv AS
SELECT * FROM t WHERE a IS NOT NULL

mode cockroach

# Test constant error.
query T multiline
EXPLAIN PHYSICAL PLAN WITH(no_fast_path) AS TEXT FOR
SELECT 1 / 0
----
Explained Query
  Error "division by zero"

EOF

# Test constant with two elements.
query T multiline
EXPLAIN PHYSICAL PLAN WITH(no_fast_path) AS TEXT FOR
(SELECT 1, 2) UNION ALL (SELECT 1, 2) UNION ALL (SELECT 3, 4)
----
Explained Query
  Constant
    - ((1, 2) x 2)
    - (3, 4)

EOF


# Test basic linear chains.

# PassArrangements plan (identity transform on an arranged input).
query T multiline
EXPLAIN PHYSICAL PLAN WITH(no_fast_path) AS TEXT FOR
SELECT * FROM t
----
Explained Query
  Get::PassArrangements materialize.public.t
    raw=false
    arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# PassArrangements plan (identity transform on a raw input).
query T multiline
EXPLAIN PHYSICAL PLAN WITH(no_fast_path) AS TEXT FOR
SELECT * FROM u
----
Explained Query
  Get::PassArrangements materialize.public.u
    raw=true

Source materialize.public.u
  Demand (#0, #1)

EOF

# GetArrangement plan (linear transform of an arranged input).
query T multiline
EXPLAIN PHYSICAL PLAN WITH(no_fast_path) AS TEXT FOR
SELECT a + b, 1 FROM t
----
Explained Query
  Get::Arrangement materialize.public.t
    project=(#2, #3)
    map=((#0 + #1), 1)
    key=#0
    raw=false
    arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# GetCollection plan (linear transform of a raw input).
query T multiline
EXPLAIN PHYSICAL PLAN WITH(no_fast_path) AS TEXT FOR
SELECT c + d, 1 FROM u
----
Explained Query
  Get::Collection materialize.public.u
    project=(#2, #3)
    map=((#0 + #1), 1)
    raw=true

Source materialize.public.u
  Demand (#0, #1)

EOF

# TopKBasic plan.
query T multiline
EXPLAIN PHYSICAL PLAN WITH(no_fast_path) AS TEXT FOR
SELECT * FROM ov
----
Explained Query
  TopK::Basic order_by=[#1 asc nulls_last, #0 desc nulls_first] limit=5
    ArrangeBy
      input_key=[#0]
      raw=true
      Get::PassArrangements materialize.public.t
        raw=false
        arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Threshold, Union, Distinct, Negate.
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT a FROM t EXCEPT ALL SELECT b FROM mv
----
Explained Query
  Threshold::Basic ensure_arrangement={ key=[#0], permutation=id, thinning=() }
    ArrangeBy
      raw=false
      arrangements[0]={ key=[#0], permutation=id, thinning=() }
      Union
        Get::Arrangement materialize.public.t
          project=(#0)
          key=#0
          raw=false
          arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }
        Negate
          Get::Collection materialize.public.mv
            project=(#1)
            raw=true

Source materialize.public.mv
  Demand (#1)

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test CTEs.
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
WITH cte(x) as (SELECT a FROM t EXCEPT ALL SELECT b FROM mv)
(SELECT x + 1 FROM cte UNION ALL SELECT x - 1 FROM cte)
----
Explained Query
  Let
    Union
      Get::Arrangement l0
        project=(#1)
        map=((#0 + 1))
        key=#0
        raw=false
        arrangements[0]={ key=[#0], permutation=id, thinning=() }
      Get::Arrangement l0
        project=(#1)
        map=((#0 - 1))
        key=#0
        raw=false
        arrangements[0]={ key=[#0], permutation=id, thinning=() }
    Where
      l0 =
        Threshold::Basic ensure_arrangement={ key=[#0], permutation=id, thinning=() }
          ArrangeBy
            raw=false
            arrangements[0]={ key=[#0], permutation=id, thinning=() }
            Union
              Get::Arrangement materialize.public.t
                project=(#0)
                key=#0
                raw=false
                arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }
              Negate
                Get::Collection materialize.public.mv
                  project=(#1)
                  raw=true

Source materialize.public.mv
  Demand (#1)

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Mfp.
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
WITH cte(x) as (SELECT a FROM t EXCEPT ALL SELECT b FROM mv)
SELECT x * 5 FROM cte WHERE x = 5
----
Explained Query
  Mfp
    project=(#1)
    filter=((#0 = 5))
    map=(25)
    input_key=#0
    input_val=(5)
    Threshold::Basic ensure_arrangement={ key=[#0], permutation=id, thinning=() }
      ArrangeBy
        raw=false
        arrangements[0]={ key=[#0], permutation=id, thinning=() }
        Union
          Get::Arrangement materialize.public.t
            project=(#0)
            key=#0
            raw=false
            arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }
          Negate
            Get::Collection materialize.public.mv
              project=(#1)
              raw=true

Source materialize.public.mv
  Demand (#1)

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test FlatMap.
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT generate_series(a, b) from t
----
Explained Query
  FlatMap generate_series(#0, #1, 1)
    project=(#2)
    input_key=#0
    Get::PassArrangements materialize.public.t
      raw=false
      arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Distinct.
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT DISTINCT a, b FROM t
----
Explained Query
  Reduce::Distinct
    val_plan
      project=()
    key_plan=id
    input_key=#0
    Get::PassArrangements materialize.public.t
      raw=false
      arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Accumulable (with GROUP BY).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  a,
  SUM(b),
  COUNT(DISTINCT b)
FROM t
GROUP BY a
----
Explained Query
  Reduce::Accumulable
    simple_aggrs[0]=(0, 0, sum(#1))
    distinct_aggrs[0]=(1, 1, count(distinct #1))
    val_plan
      project=(#1, #1)
    key_plan
      project=(#0)
    input_key=#0
    Get::PassArrangements materialize.public.t
      raw=false
      arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Accumulable (global aggregate).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  SUM(b),
  COUNT(DISTINCT b)
FROM t
----
Explained Query
  Let
    Union
      ArrangeBy
        input_key=[]
        raw=true
        Get::PassArrangements l0
          raw=false
          arrangements[0]={ key=[], permutation=id, thinning=(#0, #1) }
      Mfp
        project=(#0, #1)
        map=(null, 0)
        Union
          Negate
            Get::Arrangement l0
              project=()
              key=
              raw=false
              arrangements[0]={ key=[], permutation=id, thinning=(#0, #1) }
          Constant
            - ()
    Where
      l0 =
        Reduce::Accumulable
          simple_aggrs[0]=(0, 0, sum(#0))
          distinct_aggrs[0]=(1, 1, count(distinct #0))
          val_plan
            project=(#0, #0)
          key_plan
            project=()
          Get::Arrangement materialize.public.t
            project=(#1)
            key=#0
            raw=false
            arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Hierarchical (with GROUP BY).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  a,
  MIN(b),
  MAX(DISTINCT b)
FROM t
GROUP BY a
----
Explained Query
  Reduce::Hierarchical
    aggr_funcs=[min, max]
    skips=[0, 0]
    buckets=[0, 0]
    val_plan
      project=(#1, #1)
    key_plan
      project=(#0)
    input_key=#0
    Get::PassArrangements materialize.public.t
      raw=false
      arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Hierarchical (global aggregate).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  MIN(b),
  MAX(DISTINCT b)
FROM t
----
Explained Query
  Let
    Union
      ArrangeBy
        input_key=[]
        raw=true
        Get::PassArrangements l0
          raw=false
          arrangements[0]={ key=[], permutation=id, thinning=(#0, #1) }
      Mfp
        project=(#0, #1)
        map=(null, null)
        Union
          Negate
            Get::Arrangement l0
              project=()
              key=
              raw=false
              arrangements[0]={ key=[], permutation=id, thinning=(#0, #1) }
          Constant
            - ()
    Where
      l0 =
        Reduce::Hierarchical
          aggr_funcs=[min, max]
          skips=[0, 0]
          buckets=[0, 0]
          val_plan
            project=(#0, #0)
          key_plan
            project=()
          Get::Arrangement materialize.public.t
            project=(#1)
            key=#0
            raw=false
            arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Basic (with GROUP BY).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  a,
  STRING_AGG(b::text || '1',  ','),
  STRING_AGG(b::text || '2',  ',')
FROM t
GROUP BY a
----
Explained Query
  Reduce::Basic
    aggrs[0]=(0, string_agg(row(row((integer_to_text(#1) || "1"), ","))))
    aggrs[1]=(1, string_agg(row(row((integer_to_text(#1) || "2"), ","))))
    val_plan
      project=(#3, #4)
      map=(integer_to_text(#1), row(row((#2 || "1"), ",")), row(row((#2 || "2"), ",")))
    key_plan
      project=(#0)
    input_key=#0
    Get::PassArrangements materialize.public.t
      raw=false
      arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Basic (global aggregate).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  STRING_AGG(b::text || '1',  ','),
  STRING_AGG(b::text || '2',  ',')
FROM t
----
Explained Query
  Let
    Union
      ArrangeBy
        input_key=[]
        raw=true
        Get::PassArrangements l0
          raw=false
          arrangements[0]={ key=[], permutation=id, thinning=(#0, #1) }
      Mfp
        project=(#0, #1)
        map=(null, null)
        Union
          Negate
            Get::Arrangement l0
              project=()
              key=
              raw=false
              arrangements[0]={ key=[], permutation=id, thinning=(#0, #1) }
          Constant
            - ()
    Where
      l0 =
        Reduce::Basic
          aggrs[0]=(0, string_agg(row(row((integer_to_text(#0) || "1"), ","))))
          aggrs[1]=(1, string_agg(row(row((integer_to_text(#0) || "2"), ","))))
          val_plan
            project=(#2, #3)
            map=(integer_to_text(#0), row(row((#1 || "1"), ",")), row(row((#1 || "2"), ",")))
          key_plan
            project=()
          Get::Arrangement materialize.public.t
            project=(#1)
            key=#0
            raw=false
            arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Collated (with GROUP BY).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  a,
  COUNT(DISTINCT b),
  STRING_AGG(b::text || '1',  ','),
  MIN(b),
  MAX(DISTINCT b),
  SUM(b),
  STRING_AGG(b::text || '2',  ',')
FROM t
GROUP BY a
----
Explained Query
  Reduce::Collation
    aggregate_types=[a, b, h, h, a, b]
    accumulable
      simple_aggrs[0]=(1, 4, sum(#1))
      distinct_aggrs[0]=(0, 0, count(distinct #1))
    hierarchical
      aggr_funcs=[min, max]
      skips=[2, 0]
      buckets=[2, 0]
    basic
      aggrs[0]=(1, string_agg(row(row((integer_to_text(#1) || "1"), ","))))
      aggrs[1]=(5, string_agg(row(row((integer_to_text(#1) || "2"), ","))))
    val_plan
      project=(#1, #3, #1, #1, #1, #4)
      map=(integer_to_text(#1), row(row((#2 || "1"), ",")), row(row((#2 || "2"), ",")))
    key_plan
      project=(#0)
    input_key=#0
    Get::PassArrangements materialize.public.t
      raw=false
      arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF

# Test Reduce::Collated (global aggregate).
query T multiline
EXPLAIN PHYSICAL PLAN AS TEXT FOR
SELECT
  COUNT(DISTINCT b),
  STRING_AGG(b::text || '1',  ','),
  MIN(b),
  MAX(DISTINCT b),
  SUM(b),
  STRING_AGG(b::text || '2',  ',')
FROM t
----
Explained Query
  Let
    Union
      ArrangeBy
        input_key=[]
        raw=true
        Get::PassArrangements l0
          raw=false
          arrangements[0]={ key=[], permutation=id, thinning=(#0..=#5) }
      Mfp
        project=(#0..=#5)
        map=(0, null, null, null, null, null)
        Union
          Negate
            Get::Arrangement l0
              project=()
              key=
              raw=false
              arrangements[0]={ key=[], permutation=id, thinning=(#0..=#5) }
          Constant
            - ()
    Where
      l0 =
        Reduce::Collation
          aggregate_types=[a, b, h, h, a, b]
          accumulable
            simple_aggrs[0]=(1, 4, sum(#0))
            distinct_aggrs[0]=(0, 0, count(distinct #0))
          hierarchical
            aggr_funcs=[min, max]
            skips=[2, 0]
            buckets=[2, 0]
          basic
            aggrs[0]=(1, string_agg(row(row((integer_to_text(#0) || "1"), ","))))
            aggrs[1]=(5, string_agg(row(row((integer_to_text(#0) || "2"), ","))))
          val_plan
            project=(#0, #2, #0, #0, #0, #3)
            map=(integer_to_text(#0), row(row((#1 || "1"), ",")), row(row((#1 || "2"), ",")))
          key_plan
            project=()
          Get::Arrangement materialize.public.t
            project=(#1)
            key=#0
            raw=false
            arrangements[0]={ key=[#0], permutation=id, thinning=(#1) }

Used Indexes:
  - materialize.public.t_a_idx

EOF
