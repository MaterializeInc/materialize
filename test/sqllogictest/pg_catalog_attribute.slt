# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

mode cockroach


# Verify that pg_attribute works for all column types.
statement ok
CREATE TABLE coltypes(
c__bool _bool,
c__bpchar _bpchar,
c__bytea _bytea,
c__char _char,
c__date _date,
c__float4 _float4,
c__float8 _float8,
c__int2 _int2,
c__int4 _int4,
c__int8 _int8,
c__interval _interval,
c__jsonb _jsonb,
c__numeric _numeric,
c__oid _oid,
c__regproc _regproc,
c__text _text,
c__time _time,
c__timestamp _timestamp,
c__timestamptz _timestamptz,
c__uuid _uuid,
c__varchar _varchar,
c_bool bool,
c_bpchar bpchar,
c_bytea bytea,
c_char char,
c_date date,
c_float4 float4,
c_float8 float8,
c_int2 int2,
c_int4 int4,
c_int8 int8,
c_interval interval,
c_jsonb jsonb,
c_numeric numeric,
c_oid oid,
c_regproc regproc,
c_text text,
c_time time,
c_timestamp timestamp,
c_timestamptz timestamptz,
c_uuid uuid,
c_varchar varchar,
c_varchar10 varchar(10)
);
----

query ITI
SELECT atttypid, attname, atttypmod FROM pg_attribute WHERE attrelid = (SELECT oid FROM mz_tables WHERE name='coltypes') ORDER BY atttypid
----
16  c_bool  -1
17  c_bytea  -1
20  c_int8  -1
21  c_int2  -1
23  c_int4  -1
24  c_regproc  -1
25  c_text  -1
26  c_oid  -1
700  c_float4  -1
701  c_float8  -1
1000  c__bool  -1
1001  c__bytea  -1
1002  c__char  -1
1005  c__int2  -1
1007  c__int4  -1
1008  c__regproc  -1
1009  c__text  -1
1014  c__bpchar  -1
1015  c__varchar  -1
1016  c__int8  -1
1021  c__float4  -1
1022  c__float8  -1
1028  c__oid  -1
1042  c_char  5
1042  c_bpchar  5
1043  c_varchar  -1
1043  c_varchar10  14
1082  c_date  -1
1083  c_time  -1
1114  c_timestamp  -1
1115  c__timestamp  -1
1182  c__date  -1
1183  c__time  -1
1184  c_timestamptz  -1
1185  c__timestamptz  -1
1186  c_interval  -1
1187  c__interval  -1
1231  c__numeric  -1
1700  c_numeric  2555947
2950  c_uuid  -1
2951  c__uuid  -1
3802  c_jsonb  -1
3807  c__jsonb  -1

# Generated queries are unsupported
query B
SELECT DISTINCT(attgenerated = '') FROM pg_attribute
----
true

# Let's check go-jet's `getColumnsMetaData` query:
# https://github.com/go-jet/jet/blob/master/generator/postgres/query_set.go#L69
# In particular, the `greatest(1, attr.attndims)` workaround should work also in Materialize.

statement ok
CREATE TYPE int4_named_list AS LIST (ELEMENT TYPE = int4);

statement ok
CREATE TABLE attndims_test(
    c_int4 int4,
    c_text text,
    c_int4_array int4[],
    c_text_array text[],
    c_int4_list int4 list,
    c_text_list text list,
    c_int4_list_list int4 list list,
    c_int4_list_list_list int4 list list list,
    c_int4_named_list int4_named_list
);

query TTTTTTTTTT
select
    attr.attname as "column.Name",
    col_description(attr.attrelid, attr.attnum) as "column.Comment",
    exists(
        select 1
        from pg_catalog.pg_index indx
        where attr.attrelid = indx.indrelid and attr.attnum = any(indx.indkey) and indx.indisprimary
    ) as "column.IsPrimaryKey",
    not attr.attnotnull as "column.isNullable",
    attr.attgenerated = 's' as "column.isGenerated",
    attr.atthasdef as "column.hasDefault",
    (case when tp.typcategory = 'A' then greatest(1, attr.attndims) --cockroach num dims fix
          else 0
        end) as "dataType.dimensions",
    (case coalesce(elem.typtype, tp.typtype)
         when 'b' then 'base'
         when 'd' then 'base'
         when 'e' then 'enum'
         when 'r' then 'range'
        end) as "dataType.Kind",
    (case when tp.typtype = 'd' then (select pg_type.typname from pg_catalog.pg_type where pg_type.oid = tp.typbasetype)
          when tp.typcategory = 'A' then elem.typname
          else tp.typname
        end) as "dataType.Name",
    false as "dataType.isUnsigned"
from pg_catalog.pg_attribute as attr
     join pg_catalog.pg_class as cls on cls.oid = attr.attrelid
     join pg_catalog.pg_namespace as ns on ns.oid = cls.relnamespace
     join pg_catalog.pg_type as tp on tp.oid = attr.atttypid
	 left join pg_catalog.pg_type elem ON tp.typelem = elem.oid -- only for arrays
where
    ns.nspname = 'public' and
    cls.relname = 'attndims_test' and
    not attr.attisdropped and
    attr.attnum > 0
order by
    attr.attnum;
----
c_int4  NULL  false  true  false  true  0  base  int4  false
c_text  NULL  false  true  false  true  0  base  text  false
c_int4_array  NULL  false  true  false  true  1  base  int4  false
c_text_array  NULL  false  true  false  true  1  base  text  false
c_int4_list  NULL  false  true  false  true  0  NULL  list  false
c_text_list  NULL  false  true  false  true  0  NULL  list  false
c_int4_list_list  NULL  false  true  false  true  0  NULL  list  false
c_int4_list_list_list  NULL  false  true  false  true  0  NULL  list  false
c_int4_named_list  NULL  false  true  false  true  0  base  int4_named_list  false

# Test that pg_type.typelem is correctly populated for named list types.
# Named list types (created via CREATE TYPE) should have typelem pointing to their element type.

statement ok
CREATE TYPE int4_list AS LIST (ELEMENT TYPE = int4);

statement ok
CREATE TYPE text_list AS LIST (ELEMENT TYPE = text);

query TTI
SELECT typname, (SELECT typname FROM pg_type WHERE oid = t.typelem) as elem_name, typelem
FROM pg_type t
WHERE typname IN ('int4_list', 'text_list')
ORDER BY typname;
----
int4_list  int4  23
text_list  text  25

# Also verify the same for arrays
query TTI
SELECT typname, (SELECT typname FROM pg_type WHERE oid = t.typelem) as elem_name, typelem
FROM pg_type t
WHERE typname IN ('_int4', '_text')
ORDER BY typname;
----
_int4  int4  23
_text  text  25

# Verify that the anonymous list pseudo-type has typelem = 0
query TI
SELECT typname, typelem
FROM pg_type t
WHERE typname = 'list';
----
list  0
