# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

#
# Test Common subexpression elimination for Relations.
# PR https://github.com/MaterializeInc/materialize/pull/7715
#

statement ok
CREATE TABLE t1 (f1 INTEGER, f2 INTEGER);

statement ok
CREATE INDEX i1 ON t1 (f1);

statement ok
CREATE TABLE t2 (f1 INTEGER, f2 INTEGER);

##
## Tests around the placement of CSEs in the top-level query itself
##

# no CSE detection here, no predicates in query
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2;
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]A » %1:l0[×]A
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# Inner joins
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2, t1 AS a3;
----
Explained Query:
  Return // { arity: 6 }
    CrossJoin type=delta // { arity: 6 }
      implementation
        %0:l0 » %1:l0[×]A » %2:l0[×]A
        %1:l0 » %0:l0[×]A » %2:l0[×]A
        %2:l0 » %0:l0[×]A » %1:l0[×]A
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2 WHERE a1.f1 = 1 AND a2.f1 = 1;
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]Ae » %1:l0[×]Ae
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2, t1 AS a3 WHERE a1.f1 = 1 AND a2.f1 = 1 AND a3.f1 = 1;
----
Explained Query:
  Return // { arity: 6 }
    CrossJoin type=delta // { arity: 6 }
      implementation
        %0:l0 » %1:l0[×]Ae » %2:l0[×]Ae
        %1:l0 » %0:l0[×]Ae » %2:l0[×]Ae
        %2:l0 » %0:l0[×]Ae » %1:l0[×]Ae
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

#
# Outer join
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1) WHERE a1.f1 = 1 AND a2.f1 = 1;
----
Explained Query:
  Return // { arity: 3 }
    CrossJoin type=differential // { arity: 3 }
      implementation
        %0:l0[×]Ae » %1:l0[×]Ae
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Get l0 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#1) // { arity: 1 }
          Get l0 // { arity: 3 }
  With
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

#
# Subqueries
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1) AND f2 = (SELECT f1 FROM t1);
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #1) // { arity: 2 }
      Join on=(#0 = #2 AND #1 = #3) type=differential // { arity: 4 }
        implementation
          %0:t1[#0]KA » %1:l0[#0]KA » %2:l0[#0]KA
        ArrangeBy keys=[[#0]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        Get l0 // { arity: 1 }
        Get l0 // { arity: 1 }
  With
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#0) // { arity: 1 }
            Filter (#0) IS NOT NULL // { arity: 2 }
              Get materialize.public.t1 // { arity: 2 }
          Map (error("more than one record produced in subquery")) // { arity: 1 }
            Project () // { arity: 0 }
              Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                Reduce aggregates=[count(*)] // { arity: 1 }
                  Project () // { arity: 0 }
                    Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1 WHERE f1 = 1) AND f2 = (SELECT f1 FROM t1 WHERE f1 = 1);
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #1) // { arity: 2 }
      Join on=(#0 = #2 AND #1 = #3) type=differential // { arity: 4 }
        implementation
          %0:l0[#0]KA » %1:l2[#0]KA » %2:l2[#0]KA
        Get l0 // { arity: 2 }
        Get l2 // { arity: 1 }
        Get l2 // { arity: 1 }
  With
    cte l2 =
      ArrangeBy keys=[[#0]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l1 // { arity: 3 }
          Map (error("more than one record produced in subquery")) // { arity: 1 }
            Project () // { arity: 0 }
              Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                Reduce aggregates=[count(*)] // { arity: 1 }
                  Project () // { arity: 0 }
                    Get l1 // { arity: 3 }
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1) AND EXISTS (SELECT f1 FROM t1);
----
Explained Query:
  Project (#0, #1) // { arity: 2 }
    Join on=(#0 = #2) type=differential // { arity: 3 }
      implementation
        %0:t1[#0]KA » %1[#0]KA
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }
      ArrangeBy keys=[[#0]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#0) // { arity: 1 }
            Filter (#0) IS NOT NULL // { arity: 2 }
              Get materialize.public.t1 // { arity: 2 }
          Map (error("more than one record produced in subquery")) // { arity: 1 }
            Project () // { arity: 0 }
              Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                Reduce aggregates=[count(*)] // { arity: 1 }
                  Project () // { arity: 0 }
                    Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1) OR f2 = (SELECT f1 FROM t1);
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #1) // { arity: 2 }
      Filter ((#0 = #2) OR (#1 = #3)) // { arity: 4 }
        CrossJoin type=delta // { arity: 4 }
          implementation
            %0:t1 » %1:l1[×]A » %2:l1[×]A
            %1:l1 » %0:t1[×]A » %2:l1[×]A
            %2:l1 » %0:t1[×]A » %1:l1[×]A
          ArrangeBy keys=[[]] // { arity: 2 }
            Get materialize.public.t1 // { arity: 2 }
          Get l1 // { arity: 1 }
          Get l1 // { arity: 1 }
  With
    cte l1 =
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Get l0 // { arity: 1 }
          Map (null) // { arity: 1 }
            Union // { arity: 0 }
              Negate // { arity: 0 }
                Distinct // { arity: 0 }
                  Project () // { arity: 0 }
                    Get l0 // { arity: 1 }
              Constant // { arity: 0 }
                - ()
    cte l0 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs in derived tables
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT *
FROM (SELECT * FROM t1 WHERE f1 = 1) AS a1
JOIN (SELECT * FROM t1 WHERE f1 = 1) AS a2
ON TRUE
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]Ae » %1:l0[×]Ae
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT *
FROM (SELECT * FROM t1 WHERE f1 = 1) AS a1
, (SELECT * FROM t1 WHERE f1 = 1) AS a2
WHERE a1.f2 = 2
AND a2.f2 = 2
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]Aef » %1:l0[×]Aef
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Filter (#1 = 2) // { arity: 3 }
            ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

# No CSE with only partially-overlapping predicates
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT *
FROM (SELECT * FROM t1 WHERE f1 = 1) AS a1
, (SELECT * FROM t1 WHERE f1 = 1) AS a2
WHERE a1.f2 = 2
AND a2.f2 = 3
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]Aef » %1:l0[×]Aef
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Filter (#1 = 2) // { arity: 3 }
            Get l0 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Filter (#1 = 3) // { arity: 3 }
            Get l0 // { arity: 3 }
  With
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs in UNION branches
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1;
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1 UNION SELECT * FROM t1 WHERE f1 = 1;
----
Explained Query:
  Return // { arity: 2 }
    Project (#1, #0) // { arity: 2 }
      Map (1) // { arity: 2 }
        Distinct group_by=[#0] // { arity: 1 }
          Union // { arity: 1 }
            Get l0 // { arity: 1 }
            Get l0 // { arity: 1 }
            Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#1) // { arity: 1 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs in the SELECT list
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT (SELECT f1 FROM t1 WHERE f1 = 1) , (SELECT f1 FROM t1 WHERE f1 = 1) FROM t1;
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #0) // { arity: 2 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:t1[×]A » %1[×]A
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Union // { arity: 1 }
            Get l1 // { arity: 1 }
            Map (null) // { arity: 1 }
              Union // { arity: 0 }
                Negate // { arity: 0 }
                  Distinct // { arity: 0 }
                    Project () // { arity: 0 }
                      Get l1 // { arity: 1 }
                Constant // { arity: 0 }
                  - ()
  With
    cte l1 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT MIN((SELECT f1 FROM t1 WHERE f1 = 1)), MAX((SELECT f1 FROM t1 WHERE f1 = 1)) FROM t1;
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l3 // { arity: 2 }
      Map (null, null) // { arity: 2 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l3 // { arity: 2 }
          Constant // { arity: 0 }
            - ()
  With
    cte l3 =
      Reduce aggregates=[min(#0), max(#1)] // { arity: 2 }
        CrossJoin type=delta // { arity: 2 }
          implementation
            %0:t1 » %1:l2[×]A » %2:l2[×]A
            %1:l2 » %0:t1[×]A » %2:l2[×]A
            %2:l2 » %0:t1[×]A » %1:l2[×]A
          ArrangeBy keys=[[]] // { arity: 0 }
            Project () // { arity: 0 }
              Get materialize.public.t1 // { arity: 2 }
          Get l2 // { arity: 1 }
          Get l2 // { arity: 1 }
    cte l2 =
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Get l1 // { arity: 1 }
          Map (null) // { arity: 1 }
            Union // { arity: 0 }
              Negate // { arity: 0 }
                Distinct // { arity: 0 }
                  Project () // { arity: 0 }
                    Get l1 // { arity: 1 }
              Constant // { arity: 0 }
                - ()
    cte l1 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs at two distinct positions within the query
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT (SELECT f1 FROM t1 WHERE f1 = 1) FROM t1 WHERE EXISTS (SELECT f1 FROM t1 WHERE f1 = 1);
----
Explained Query:
  Return // { arity: 1 }
    CrossJoin type=delta // { arity: 1 }
      implementation
        %0:t1 » %1[×]UA » %2[×]A
        %1 » %0:t1[×]A » %2[×]A
        %2 » %1[×]UA » %0:t1[×]A
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get materialize.public.t1 // { arity: 2 }
      ArrangeBy keys=[[]] // { arity: 0 }
        Distinct // { arity: 0 }
          Get l1 // { arity: 0 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Get l2 // { arity: 1 }
          Map (null) // { arity: 1 }
            Union // { arity: 0 }
              Negate // { arity: 0 }
                Distinct // { arity: 0 }
                  Project () // { arity: 0 }
                    Get l2 // { arity: 1 }
              Constant // { arity: 0 }
                - ()
  With
    cte l2 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Get l1 // { arity: 0 }
    cte l1 =
      Project () // { arity: 0 }
        Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT (SELECT f1 FROM t1 WHERE f1 = 1) FROM t1
UNION ALL
SELECT f1 FROM t1 WHERE f1 = 1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:t1[×]A » %1[×]A
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Union // { arity: 1 }
            Get l2 // { arity: 1 }
            Map (null) // { arity: 1 }
              Union // { arity: 0 }
                Negate // { arity: 0 }
                  Distinct // { arity: 0 }
                    Project () // { arity: 0 }
                      Get l2 // { arity: 1 }
                Constant // { arity: 0 }
                  - ()
      Get l1 // { arity: 1 }
  With
    cte l2 =
      Union // { arity: 1 }
        Get l1 // { arity: 1 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get l0 // { arity: 3 }
    cte l1 =
      Project (#0) // { arity: 1 }
        Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

##
## Tests around the contents of the CSE itself
##

#
# CSE containing a join
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 AS a1, t1 AS a2
UNION ALL
SELECT * FROM t1 AS a1, t1 AS a2
----
Explained Query:
  Return // { arity: 4 }
    Union // { arity: 4 }
      Get l1 // { arity: 4 }
      Get l1 // { arity: 4 }
  With
    cte l1 =
      CrossJoin type=differential // { arity: 4 }
        implementation
          %0:l0[×]A » %1:l0[×]A
        Get l0 // { arity: 2 }
        Get l0 // { arity: 2 }
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)
UNION ALL
SELECT * FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)
----
Explained Query:
  Return // { arity: 3 }
    Union // { arity: 3 }
      Get l2 // { arity: 3 }
      Get l1 // { arity: 3 }
      Get l2 // { arity: 3 }
      Get l1 // { arity: 3 }
  With
    cte l2 =
      Map (null) // { arity: 3 }
        Union // { arity: 2 }
          Negate // { arity: 2 }
            Project (#0, #1) // { arity: 2 }
              Join on=(#0 = #2) type=differential // { arity: 3 }
                implementation
                  %1[#0]UKA » %0:l0[#0]KA
                Get l0 // { arity: 2 }
                ArrangeBy keys=[[#0]] // { arity: 1 }
                  Distinct group_by=[#0] // { arity: 1 }
                    Project (#0) // { arity: 1 }
                      Get l1 // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }
    cte l1 =
      Project (#0, #1, #3) // { arity: 3 }
        Filter (#0) IS NOT NULL // { arity: 4 }
          Join on=(#0 = #2) type=differential // { arity: 4 }
            implementation
              %0:l0[#0]KA » %1:l0[#0]KA
            Get l0 // { arity: 2 }
            Get l0 // { arity: 2 }
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) WHERE f1 = 1
UNION ALL
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) WHERE f1 = 2
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l1[×]Ae » %1:l1[×]Ae
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l1 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l1 // { arity: 3 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l2[×]Ae » %1:l2[×]Ae
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l2 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l2 // { arity: 3 }
  With
    cte l2 =
      ReadExistingIndex materialize.public.t1 lookup_value=(2)
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s1,
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s2
WHERE s1.f1 = 1 AND s2.f1 = 1
----
Explained Query:
  Return // { arity: 2 }
    CrossJoin type=delta // { arity: 2 }
      implementation
        %0:l1 » %1:l2[×]Ae » %2:l1[×]Ae » %3:l2[×]Ae
        %1:l2 » %0:l1[×]Ae » %2:l1[×]Ae » %3:l2[×]Ae
        %2:l1 » %0:l1[×]Ae » %1:l2[×]Ae » %3:l2[×]Ae
        %3:l2 » %0:l1[×]Ae » %1:l2[×]Ae » %2:l1[×]Ae
      Get l1 // { arity: 0 }
      Get l2 // { arity: 1 }
      Get l1 // { arity: 0 }
      Get l2 // { arity: 1 }
  With
    cte l2 =
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
    cte l1 =
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s1,
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s2
WHERE s1.f1 = 1 AND s2.f1 = 2
----
Explained Query:
  Return // { arity: 2 }
    CrossJoin type=delta // { arity: 2 }
      implementation
        %0:l1 » %1:l1[×]Ae » %2:l2[×]Ae » %3:l2[×]Ae
        %1:l1 » %0:l1[×]Ae » %2:l2[×]Ae » %3:l2[×]Ae
        %2:l2 » %0:l1[×]Ae » %1:l1[×]Ae » %3:l2[×]Ae
        %3:l2 » %0:l1[×]Ae » %1:l1[×]Ae » %2:l2[×]Ae
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get l1 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l1 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get l2 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l2 // { arity: 3 }
  With
    cte l2 =
      ReadExistingIndex materialize.public.t1 lookup_value=(2)
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a conjunction (AND)
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = 1 AND f2 = 2
UNION ALL
SELECT * FROM t1 WHERE f1 = 1 AND f2 = 2
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        Filter (#1 = 2) // { arity: 3 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a disjunction (OR)
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = 1 OR f1 = 2
UNION ALL
SELECT * FROM t1 WHERE f1 = 1 OR f1 = 2
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_values=[(1); (2)]

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a subquery
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1)
UNION ALL
SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1[×]UA » %0:t1[×]A
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Distinct // { arity: 0 }
            Project () // { arity: 0 }
              ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1 WHERE f1 = 1)
UNION ALL
SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l2 // { arity: 2 }
      Get l2 // { arity: 2 }
  With
    cte l2 =
      Project (#0, #1) // { arity: 2 }
        Join on=(#0 = #2) type=differential // { arity: 3 }
          implementation
            %0:l0[#0]KA » %1[#0]KA
          Get l0 // { arity: 2 }
          ArrangeBy keys=[[#0]] // { arity: 1 }
            Union // { arity: 1 }
              Project (#0) // { arity: 1 }
                Get l1 // { arity: 3 }
              Map (error("more than one record produced in subquery")) // { arity: 1 }
                Project () // { arity: 0 }
                  Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                    Reduce aggregates=[count(*)] // { arity: 1 }
                      Project () // { arity: 0 }
                        Get l1 // { arity: 3 }
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a derived table
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1 + 1 FROM (SELECT f1 + 2 AS f1 FROM t1)
UNION ALL
SELECT f1 + 1 FROM (SELECT f1 + 2 AS f1 FROM t1)
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#2) // { arity: 1 }
        Map (((#0 + 2) + 1)) // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs containing an aggregate
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT MIN(f1) FROM t1
UNION ALL
SELECT MIN(f1) FROM t1;
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l1 // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l1 // { arity: 1 }
  With
    cte l1 =
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l0 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
    cte l0 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT DISTINCT f1 FROM t1
UNION ALL
SELECT DISTINCT f1 FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Distinct group_by=[#0] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1, COUNT(*) FROM t1 GROUP BY f1
UNION ALL
SELECT f1, COUNT(*) FROM t1 GROUP BY f1
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Reduce group_by=[#0] aggregates=[count(*)] // { arity: 2 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs containing an expression / function

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1 + f1 + f1 + f1 FROM t1
UNION ALL
SELECT f1 + f1 + f1 + f1 FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#2) // { arity: 1 }
        Map ((((#0 + #0) + #0) + #0)) // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT ABS(f1) FROM t1
UNION ALL
SELECT ABS(f1) FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#2) // { arity: 1 }
        Map (abs(#0)) // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

##
## Nested CSEs
##

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1)
UNION ALL
(SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
UNION ALL
(SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1[×]UA » %0:t1[×]A
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Distinct // { arity: 0 }
            Project () // { arity: 0 }
              ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

##
## Deeper-placed CSEs (where a higher-level construct is not a CSE but a lower-level one is)
##

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT f1 FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
UNION ALL
(SELECT f2 FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Project (#0) // { arity: 1 }
        Get l0 // { arity: 2 }
      Project (#1) // { arity: 1 }
        Get l0 // { arity: 2 }
  With
    cte l0 =
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1[×]UA » %0:t1[×]A
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Distinct // { arity: 0 }
            Project () // { arity: 0 }
              ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
UNION ALL
(SELECT * FROM t2 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1:l0[×]UA » %0:t1[×]A
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        Get l0 // { arity: 0 }
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1:l0[×]UA » %0:t2[×]A
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t2 // { arity: 2 }
        Get l0 // { arity: 0 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 0 }
        Distinct // { arity: 0 }
          Project () // { arity: 0 }
            ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM
(SELECT f1 FROM t2 UNION ALL SELECT f1 FROM t1 WHERE f1 = 1) ,
(SELECT f2 FROM t2 UNION ALL SELECT f1 FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    CrossJoin type=differential // { arity: 2 }
      implementation
        %0[×]A » %1[×]A
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get materialize.public.t2 // { arity: 2 }
          Get l0 // { arity: 1 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#1) // { arity: 1 }
            Get materialize.public.t2 // { arity: 2 }
          Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#0) // { arity: 1 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

# Same predicate, different projections
query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1 FROM t1 WHERE f1 = 1
UNION ALL
SELECT f2 FROM t1 WHERE f1 = 1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Project (#0) // { arity: 1 }
        Get l0 // { arity: 3 }
      Project (#1) // { arity: 1 }
        Get l0 // { arity: 3 }
  With
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)

Used Indexes:
  - materialize.public.i1

EOF

##
## Negative cases - CSEs should not be identified where they do not exist
##

#
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1, t1 AS a2 WHERE a1.f1 = 1 AND a2.f1 = 2
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:t1[×]Ae » %1:t1[×]Ae
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1)
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(2)
  With
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 JOIN t1 AS a2 USING (f1)) WHERE f1 = 1
UNION ALL
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 JOIN t1 AS a2 USING (f1)) WHERE f1 = 2
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l1[×]Ae » %1:l1[×]Ae
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l1 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l1 // { arity: 3 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l2[×]Ae » %1:l2[×]Ae
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l2 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l2 // { arity: 3 }
  With
    cte l2 =
      ReadExistingIndex materialize.public.t1 lookup_value=(2)
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1)
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = 1
UNION ALL
SELECT * FROM t1 WHERE f1 = 2
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1)
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(2)
  With
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT MIN(f1) FROM t1
UNION ALL
SELECT MAX(f1) FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l1 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l1 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
      Get l2 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l2 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
  With
    cte l2 =
      Reduce aggregates=[max(#0)] // { arity: 1 }
        Get l0 // { arity: 1 }
    cte l1 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Get l0 // { arity: 1 }
    cte l0 =
      Project (#0) // { arity: 1 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT MIN(f1) FROM t1
UNION ALL
SELECT MIN(f2) FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l0 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
      Get l1 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l1 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
  With
    cte l1 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Project (#1) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }
    cte l0 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF
