# Copyright Materialize, Inc. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

statement ok
CREATE TABLE nation (
    n_nationkey  integer PRIMARY KEY,
    n_name       char(25) NOT NULL,
    n_regionkey  integer NOT NULL,
    n_comment    varchar(152)
)

statement ok
CREATE INDEX fk_nation_regionkey ON nation (n_regionkey ASC)

statement ok
CREATE TABLE region  (
    r_regionkey  integer PRIMARY KEY,
    r_name       char(25) NOT NULL,
    r_comment    varchar(152)
)

statement ok
CREATE TABLE part (
    p_partkey     integer PRIMARY KEY,
    p_name        varchar(55) NOT NULL,
    p_mfgr        char(25) NOT NULL,
    p_brand       char(10) NOT NULL,
    p_type        varchar(25) NOT NULL,
    p_size        integer NOT NULL,
    p_container   char(10) NOT NULL,
    p_retailprice decimal(15, 2) NOT NULL,
    p_comment     varchar(23) NOT NULL
)

statement ok
CREATE TABLE supplier (
    s_suppkey     integer PRIMARY KEY,
    s_name        char(25) NOT NULL,
    s_address     varchar(40) NOT NULL,
    s_nationkey   integer NOT NULL,
    s_phone       char(15) NOT NULL,
    s_acctbal     decimal(15, 2) NOT NULL,
    s_comment     varchar(101) NOT NULL
)

statement ok
CREATE INDEX fk_supplier_nationkey ON supplier (s_nationkey ASC)

statement ok
CREATE TABLE partsupp (
    ps_partkey     integer NOT NULL,
    ps_suppkey     integer NOT NULL,
    ps_availqty    integer NOT NULL,
    ps_supplycost  decimal(15, 2) NOT NULL,
    ps_comment     varchar(199) NOT NULL,
    PRIMARY KEY (ps_partkey, ps_suppkey)
)

statement ok
CREATE INDEX fk_partsupp_partkey ON partsupp (ps_partkey ASC)

statement ok
CREATE INDEX fk_partsupp_suppkey ON partsupp (ps_suppkey ASC)

statement ok
CREATE TABLE customer (
    c_custkey     integer PRIMARY KEY,
    c_name        varchar(25) NOT NULL,
    c_address     varchar(40) NOT NULL,
    c_nationkey   integer NOT NULL,
    c_phone       char(15) NOT NULL,
    c_acctbal     decimal(15, 2) NOT NULL,
    c_mktsegment  char(10) NOT NULL,
    c_comment     varchar(117) NOT NULL
)

statement ok
CREATE INDEX fk_customer_nationkey ON customer (c_nationkey ASC)

statement ok
CREATE TABLE orders (
    o_orderkey       integer PRIMARY KEY,
    o_custkey        integer NOT NULL,
    o_orderstatus    char(1) NOT NULL,
    o_totalprice     decimal(15, 2) NOT NULL,
    o_orderdate      DATE NOT NULL,
    o_orderpriority  char(15) NOT NULL,
    o_clerk          char(15) NOT NULL,
    o_shippriority   integer NOT NULL,
    o_comment        varchar(79) NOT NULL
)

statement ok
CREATE INDEX fk_orders_custkey ON orders (o_custkey ASC)

statement ok
CREATE TABLE lineitem (
    l_orderkey       integer NOT NULL,
    l_partkey        integer NOT NULL,
    l_suppkey        integer NOT NULL,
    l_linenumber     integer NOT NULL,
    l_quantity       decimal(15, 2) NOT NULL,
    l_extendedprice  decimal(15, 2) NOT NULL,
    l_discount       decimal(15, 2) NOT NULL,
    l_tax            decimal(15, 2) NOT NULL,
    l_returnflag     char(1) NOT NULL,
    l_linestatus     char(1) NOT NULL,
    l_shipdate       date NOT NULL,
    l_commitdate     date NOT NULL,
    l_receiptdate    date NOT NULL,
    l_shipinstruct   char(25) NOT NULL,
    l_shipmode       char(10) NOT NULL,
    l_comment        varchar(44) NOT NULL,
    PRIMARY KEY (l_orderkey, l_linenumber)
)

statement ok
CREATE INDEX fk_lineitem_orderkey ON lineitem (l_orderkey ASC)

statement ok
CREATE INDEX fk_lineitem_partkey ON lineitem (l_partkey ASC)

statement ok
CREATE INDEX fk_lineitem_suppkey ON lineitem (l_suppkey ASC)

statement ok
CREATE INDEX fk_lineitem_partsuppkey ON lineitem (l_partkey ASC, l_suppkey ASC)



query T multiline
-- Query 01
EXPLAIN PLAN FOR SELECT
	l_returnflag,
	l_linestatus,
	sum(l_quantity) AS sum_qty,
	sum(l_extendedprice) AS sum_base_price,
	sum(l_extendedprice * (1 - l_discount)) AS sum_disc_price,
	sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) AS sum_charge,
	avg(l_quantity) AS avg_qty,
	avg(l_extendedprice) AS avg_price,
	avg(l_discount) AS avg_disc,
	count(*) AS count_order
FROM
	lineitem
WHERE
	l_shipdate <= DATE '1998-12-01' -- - INTERVAL '60' day (fails with an error)
GROUP BY
	l_returnflag,
	l_linestatus
ORDER BY
	l_returnflag,
	l_linestatus
----
Project {
  outputs: [0 .. 5, 11 .. 13, 10],
  Map {
    scalars: [
      ((#2 * 10000000dec) / (i64todec #6 * 100dec)) * 10dec,
      ((#3 * 10000000dec) / (i64todec #7 * 100dec)) * 10dec,
      ((#8 * 10000000dec) / (i64todec #9 * 100dec)) * 10dec
    ],
    Reduce {
      group_key: [#8, #9],
      aggregates: [
        sum(#4),
        sum(#5),
        sum(#5 * (100dec - #6)),
        sum((#5 * (100dec - #6)) * (100dec + #7)),
        countall(null),
        countall(null),
        sum(#6),
        countall(null),
        countall(null)
      ],
      Filter {
        predicates: [#10 <= 1998-12-01],
        Get { materialize.public.lineitem (u21) }
      }
    }
  }
}


query T multiline
-- Query 02
EXPLAIN PLAN FOR SELECT
    s_acctbal,
    s_name,
    n_name,
    p_partkey,
    p_mfgr,
    s_address,
    s_phone,
    s_comment
FROM
    part, supplier, partsupp, nation, region
WHERE
    p_partkey = ps_partkey
    AND s_suppkey = ps_suppkey
    AND p_size = CAST (15 AS smallint)
    AND p_type LIKE '%BRASS'
    AND s_nationkey = n_nationkey
    AND n_regionkey = r_regionkey
    AND r_name = 'EUROPE'
    AND ps_supplycost
        = (
                SELECT
                    min(ps_supplycost)
                FROM
                    partsupp, supplier, nation, region
                WHERE
                    p_partkey = ps_partkey
                    AND s_suppkey = ps_suppkey
                    AND s_nationkey = n_nationkey
                    AND n_regionkey = r_regionkey
                    AND r_name = 'EUROPE'
            )
ORDER BY
    s_acctbal DESC, n_name, s_name, p_partkey
----
Let {
  l0 = Filter {
    predicates: [^.*BRASS$ ~ #4, #5 = 15, #26 = "EUROPE"],
    Join {
      variables: [
        [(0, 0), (2, 0)],
        [(1, 0), (2, 1)],
        [(1, 3), (3, 0)],
        [(3, 2), (4, 0)]
      ],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.part (u6) }
      },
      ArrangeBy {
        keys: [[#0], [#3]],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy {
        keys: [[#0], [#1]],
        Get { materialize.public.partsupp (u11) }
      },
      ArrangeBy {
        keys: [[#0], [#2]],
        Get { materialize.public.nation (u1) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.region (u4) }
      }
    }
  }
} in
Project {
  outputs: [14, 10, 22, 0, 2, 11, 13, 15],
  Join {
    variables: [[(0, 0), (1, 0)], [(0, 19), (1, 1)]],
    implementation: DifferentialLinear,
    Get { l0 },
    ArrangeBy {
      keys: [[#0, #1]],
      Reduce {
        group_key: [#0],
        aggregates: [min(#4)],
        Filter {
          predicates: [#18 = "EUROPE"],
          Join {
            variables: [
              [(0, 0), (1, 0)],
              [(1, 1), (2, 0)],
              [(2, 3), (3, 0)],
              [(3, 2), (4, 0)]
            ],
            implementation: DeltaQuery,
            ArrangeBy {
              keys: [[#0]],
              Distinct { group_key: [#0], Get { l0 } }
            },
            ArrangeBy {
              keys: [[#0], [#1]],
              Get { materialize.public.partsupp (u11) }
            },
            ArrangeBy {
              keys: [[#0], [#3]],
              Get { materialize.public.supplier (u8) }
            },
            ArrangeBy {
              keys: [[#0], [#2]],
              Get { materialize.public.nation (u1) }
            },
            ArrangeBy {
              keys: [[#0]],
              Get { materialize.public.region (u4) }
            }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 03
EXPLAIN PLAN FOR SELECT
    l_orderkey,
    sum(l_extendedprice * (1 - l_discount)) AS revenue,
    o_orderdate,
    o_shippriority
FROM
    customer,
    orders,
    lineitem
WHERE
    c_mktsegment = 'BUILDING'
    AND c_custkey = o_custkey
    AND l_orderkey = o_orderkey
    AND o_orderdate < DATE '1995-03-15'
    AND l_shipdate > DATE '1995-03-15'
GROUP BY
    l_orderkey,
    o_orderdate,
    o_shippriority
ORDER BY
    revenue DESC,
    o_orderdate
----
Project {
  outputs: [0, 3, 1, 2],
  Reduce {
    group_key: [#8, #12, #15],
    aggregates: [sum(#22 * (100dec - #23))],
    Filter {
      predicates: [
        #6 = "BUILDING",
        #12 < 1995-03-15,
        #27 > 1995-03-15
      ],
      Join {
        variables: [[(0, 0), (1, 1)], [(1, 0), (2, 0)]],
        implementation: DeltaQuery,
        ArrangeBy {
          keys: [[#0]],
          Get { materialize.public.customer (u15) }
        },
        ArrangeBy {
          keys: [[#0], [#1]],
          Get { materialize.public.orders (u18) }
        },
        ArrangeBy {
          keys: [[#0]],
          Get { materialize.public.lineitem (u21) }
        }
      }
    }
  }
}


query T multiline
-- Query 04
EXPLAIN PLAN FOR SELECT
    o_orderpriority,
    count(*) AS order_count
FROM
    orders
WHERE
    o_orderdate >= DATE '1993-07-01'
    AND o_orderdate < DATE '1993-07-01' + INTERVAL '3' month
    AND EXISTS (
        SELECT
            *
        FROM
            lineitem
        WHERE
            l_orderkey = o_orderkey
            AND l_commitdate < l_receiptdate
    )
GROUP BY
    o_orderpriority
ORDER BY
    o_orderpriority
----
Let {
  l0 = Filter {
    predicates: [datetots #4 < 1993-10-01 00:00:00, #4 >= 1993-07-01],
    Get { materialize.public.orders (u18) }
  }
} in
Reduce {
  group_key: [#5],
  aggregates: [countall(null)],
  Join {
    variables: [[(0, 0), (1, 0)]],
    implementation: DifferentialLinear,
    Get { l0 },
    ArrangeBy {
      keys: [[#0]],
      Distinct {
        group_key: [#0],
        Filter {
          predicates: [#20 < #21],
          Join {
            variables: [[(0, 0), (1, 0)]],
            implementation: DeltaQuery,
            ArrangeBy { keys: [[#0]], Get { l0 } },
            ArrangeBy {
              keys: [[#0]],
              Get { materialize.public.lineitem (u21) }
            }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 05
EXPLAIN PLAN FOR SELECT
    n_name,
    sum(l_extendedprice * (1 - l_discount)) AS revenue
FROM
    customer,
    orders,
    lineitem,
    supplier,
    nation,
    region
WHERE
    c_custkey = o_custkey
    AND l_orderkey = o_orderkey
    AND l_suppkey = s_suppkey
    AND c_nationkey = s_nationkey
    AND s_nationkey = n_nationkey
    AND n_regionkey = r_regionkey
    AND r_name = 'ASIA'
    AND o_orderdate >= DATE '1994-01-01'
    AND o_orderdate < DATE '1995-01-01'
GROUP BY
    n_name
ORDER BY
    revenue DESC
----
Reduce {
  group_key: [#41],
  aggregates: [sum(#22 * (100dec - #23))],
  Filter {
    predicates: [#45 = "ASIA", #12 < 1995-01-01, #12 >= 1994-01-01],
    Join {
      variables: [
        [(0, 0), (1, 0)],
        [(0, 2), (3, 0)],
        [(1, 1), (2, 0)],
        [(2, 3), (3, 3), (4, 0)],
        [(4, 2), (5, 0)]
      ],
      implementation: DifferentialLinear,
      Get { materialize.public.lineitem (u21) },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.orders (u18) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.customer (u15) }
      },
      ArrangeBy {
        keys: [[#0, #3]],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.nation (u1) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.region (u4) }
      }
    }
  }
}


query T multiline
-- Query 06
EXPLAIN PLAN FOR SELECT
    sum(l_extendedprice * l_discount) AS revenue
FROM
    lineitem
WHERE
    l_quantity < 24
    AND l_shipdate >= DATE '1994-01-01'
    AND l_shipdate < DATE '1994-01-01' + INTERVAL '1' year
    AND l_discount BETWEEN 0.06 - 0.01 AND 0.07
----
Let {
  l0 = Reduce {
    group_key: [],
    aggregates: [sum(#5 * #6)],
    Filter {
      predicates: [
        #4 < 2400dec,
        datetots #10 < 1995-01-01 00:00:00,
        #6 <= 7dec,
        #6 >= 5dec,
        #10 >= 1994-01-01
      ],
      Get { materialize.public.lineitem (u21) }
    }
  }
} in
Union {
  Get { l0 },
  Map {
    scalars: [null],
    Union {
      Project { outputs: [], Negate { Get { l0 } } },
      Constant [[]]
    }
  }
}


query T multiline
-- Query 07
EXPLAIN PLAN FOR SELECT
    supp_nation,
    cust_nation,
    l_year,
    sum(volume) AS revenue
FROM
    (
        SELECT
            n1.n_name AS supp_nation,
            n2.n_name AS cust_nation,
            extract(year FROM l_shipdate) AS l_year,
            l_extendedprice * (1 - l_discount) AS volume
        FROM
            supplier,
            lineitem,
            orders,
            customer,
            nation n1,
            nation n2
        WHERE
            s_suppkey = l_suppkey
            AND o_orderkey = l_orderkey
            AND c_custkey = o_custkey
            AND s_nationkey = n1.n_nationkey
            AND c_nationkey = n2.n_nationkey
            AND (
                (n1.n_name = 'FRANCE' AND n2.n_name = 'GERMANY')
                or (n1.n_name = 'GERMANY' AND n2.n_name = 'FRANCE')
            )
            AND l_shipdate BETWEEN DATE '1995-01-01' AND DATE '1996-12-31'
    ) AS shipping
GROUP BY
    supp_nation,
    cust_nation,
    l_year
ORDER BY
    supp_nation,
    cust_nation,
    l_year
----
Reduce {
  group_key: [#41, #45, tsextractyear datetots #17],
  aggregates: [sum(#12 * (100dec - #13))],
  Filter {
    predicates: [
      ((#41 = "FRANCE") && (#45 = "GERMANY"))
      ||
      ((#41 = "GERMANY") && (#45 = "FRANCE")),
      #17 <= 1996-12-31,
      #17 >= 1995-01-01
    ],
    Join {
      variables: [
        [(0, 0), (1, 2)],
        [(0, 3), (4, 0)],
        [(1, 0), (2, 0)],
        [(2, 1), (3, 0)],
        [(3, 3), (5, 0)]
      ],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#0], [#3]],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy {
        keys: [[#0], [#2]],
        Get { materialize.public.lineitem (u21) }
      },
      ArrangeBy {
        keys: [[#0], [#1]],
        Get { materialize.public.orders (u18) }
      },
      ArrangeBy {
        keys: [[#0], [#3]],
        Get { materialize.public.customer (u15) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.nation (u1) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.nation (u1) }
      }
    }
  }
}


query T multiline
-- Query 08
EXPLAIN PLAN FOR SELECT
    o_year,
    sum(case
        when nation = 'BRAZIL' then volume
        else 0
    end) / sum(volume) AS mkt_share
FROM
    (
        SELECT
            extract(year FROM o_orderdate) AS o_year,
            l_extendedprice * (1 - l_discount) AS volume,
            n2.n_name AS nation
        FROM
            part,
            supplier,
            lineitem,
            orders,
            customer,
            nation n1,
            nation n2,
            region
        WHERE
            p_partkey = l_partkey
            AND s_suppkey = l_suppkey
            AND l_orderkey = o_orderkey
            AND o_custkey = c_custkey
            AND c_nationkey = n1.n_nationkey
            AND n1.n_regionkey = r_regionkey
            AND r_name = 'AMERICA'
            AND s_nationkey = n2.n_nationkey
            AND o_orderdate BETWEEN DATE '1995-01-01' AND DATE '1996-12-31'
            AND p_type = 'ECONOMY ANODIZED STEEL'
    ) AS all_nations
GROUP BY
    o_year
ORDER BY
    o_year
----
Project {
  outputs: [0, 3],
  Map {
    scalars: [((#1 * 10000000dec) / #2) * 1000dec],
    Reduce {
      group_key: [tsextractyear datetots #36],
      aggregates: [
        sum(if #54 = "BRAZIL" then #21 * (100dec - #22) else 0dec),
        sum(#21 * (100dec - #22))
      ],
      Filter {
        predicates: [
          #4 = "ECONOMY ANODIZED STEEL",
          #58 = "AMERICA",
          #36 <= 1996-12-31,
          #36 >= 1995-01-01
        ],
        Join {
          variables: [
            [(0, 0), (2, 1)],
            [(1, 0), (2, 2)],
            [(1, 3), (6, 0)],
            [(2, 0), (3, 0)],
            [(3, 1), (4, 0)],
            [(4, 3), (5, 0)],
            [(5, 2), (7, 0)]
          ],
          implementation: DeltaQuery,
          ArrangeBy {
            keys: [[#0]],
            Get { materialize.public.part (u6) }
          },
          ArrangeBy {
            keys: [[#0], [#3]],
            Get { materialize.public.supplier (u8) }
          },
          ArrangeBy {
            keys: [[#0], [#1], [#2]],
            Get { materialize.public.lineitem (u21) }
          },
          ArrangeBy {
            keys: [[#0], [#1]],
            Get { materialize.public.orders (u18) }
          },
          ArrangeBy {
            keys: [[#0], [#3]],
            Get { materialize.public.customer (u15) }
          },
          ArrangeBy {
            keys: [[#0], [#2]],
            Get { materialize.public.nation (u1) }
          },
          ArrangeBy {
            keys: [[#0]],
            Get { materialize.public.nation (u1) }
          },
          ArrangeBy {
            keys: [[#0]],
            Get { materialize.public.region (u4) }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 09
EXPLAIN PLAN FOR SELECT
    nation,
    o_year,
    sum(amount) AS sum_profit
FROM
    (
        SELECT
            n_name AS nation,
            extract(year FROM o_orderdate) AS o_year,
            l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity AS amount
        FROM
            part,
            supplier,
            lineitem,
            partsupp,
            orders,
            nation
        WHERE
            s_suppkey = l_suppkey
            AND ps_suppkey = l_suppkey
            AND ps_partkey = l_partkey
            AND p_partkey = l_partkey
            AND o_orderkey = l_orderkey
            AND s_nationkey = n_nationkey
            AND p_name like 'green'
    ) AS profit
GROUP BY
    nation,
    o_year
ORDER BY
    nation,
    o_year DESC
----
Reduce {
  group_key: [#47, tsextractyear datetots #41],
  aggregates: [sum((#21 * (100dec - #22)) - (#35 * #20))],
  Filter {
    predicates: [^green$ ~ #1],
    Join {
      variables: [
        [(0, 0), (2, 1), (3, 0)],
        [(1, 0), (2, 2), (3, 1)],
        [(1, 3), (5, 0)],
        [(2, 0), (4, 0)]
      ],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.part (u6) }
      },
      ArrangeBy {
        keys: [[#0], [#3]],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy {
        keys: [[#0], [#1], [#1, #2], [#2]],
        Get { materialize.public.lineitem (u21) }
      },
      ArrangeBy {
        keys: [[#0, #1]],
        Get { materialize.public.partsupp (u11) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.orders (u18) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.nation (u1) }
      }
    }
  }
}


query T multiline
-- Query 10
EXPLAIN PLAN FOR SELECT
    c_custkey,
    c_name,
    sum(l_extendedprice * (1 - l_discount)) AS revenue,
    c_acctbal,
    n_name,
    c_address,
    c_phone,
    c_comment
FROM
    customer,
    orders,
    lineitem,
    nation
WHERE
    c_custkey = o_custkey
    AND l_orderkey = o_orderkey
    AND o_orderdate >= DATE '1993-10-01'
    AND o_orderdate < DATE '1994-01-01'
    AND o_orderdate < DATE '1993-10-01' + INTERVAL '3' month
    AND l_returnflag = 'R'
    AND c_nationkey = n_nationkey
GROUP BY
    c_custkey,
    c_name,
    c_acctbal,
    c_phone,
    n_name,
    c_address,
    c_comment
ORDER BY
    revenue DESC
----
Project {
  outputs: [0, 1, 7, 2, 4, 5, 3, 6],
  Reduce {
    group_key: [#0, #1, #5, #4, #34, #2, #7],
    aggregates: [sum(#22 * (100dec - #23))],
    Filter {
      predicates: [
        #25 = "R",
        #12 < 1994-01-01,
        datetots #12 < 1994-01-01 00:00:00,
        #12 >= 1993-10-01
      ],
      Join {
        variables: [
          [(0, 0), (1, 1)],
          [(0, 3), (3, 0)],
          [(1, 0), (2, 0)]
        ],
        implementation: DeltaQuery,
        ArrangeBy {
          keys: [[#0], [#3]],
          Get { materialize.public.customer (u15) }
        },
        ArrangeBy {
          keys: [[#0], [#1]],
          Get { materialize.public.orders (u18) }
        },
        ArrangeBy {
          keys: [[#0]],
          Get { materialize.public.lineitem (u21) }
        },
        ArrangeBy {
          keys: [[#0]],
          Get { materialize.public.nation (u1) }
        }
      }
    }
  }
}


query T multiline
-- Query 11
EXPLAIN PLAN FOR SELECT
    ps_partkey,
    sum(ps_supplycost * ps_availqty) AS value
FROM
    partsupp,
    supplier,
    nation
WHERE
    ps_suppkey = s_suppkey
    AND s_nationkey = n_nationkey
    AND n_name = 'GERMANY'
GROUP BY
    ps_partkey having
        sum(ps_supplycost * ps_availqty) > (
            SELECT
                sum(ps_supplycost * ps_availqty) * 0.0001
            FROM
                partsupp,
                supplier,
                nation
            WHERE
                ps_suppkey = s_suppkey
                AND s_nationkey = n_nationkey
                AND n_name = 'GERMANY'
        )
ORDER BY
    value DESC
----
Let {
  l0 = Filter {
    predicates: [#13 = "GERMANY"],
    Join {
      variables: [[(0, 1), (1, 0)], [(1, 3), (2, 0)]],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#1]],
        Get { materialize.public.partsupp (u11) }
      },
      ArrangeBy {
        keys: [[#0], [#3]],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.nation (u1) }
      }
    }
  }
} in
Project {
  outputs: [0, 1],
  Filter {
    predicates: [(#1 * 10000dec) > #3],
    Join {
      variables: [],
      implementation: DifferentialLinear,
      Reduce {
        group_key: [#0],
        aggregates: [sum(#3 * (i32todec #2 * 100dec))],
        Get { l0 }
      },
      ArrangeBy {
        keys: [[]],
        Map {
          scalars: [#0 * 1dec],
          Reduce {
            group_key: [],
            aggregates: [sum(#3 * (i32todec #2 * 100dec))],
            Get { l0 }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 12
EXPLAIN PLAN FOR SELECT
    l_shipmode,
    sum(case
        when o_orderpriority = '1-URGENT'
            or o_orderpriority = '2-HIGH'
            then 1
        else 0
    end) AS high_line_count,
    sum(case
        when o_orderpriority <> '1-URGENT'
            AND o_orderpriority <> '2-HIGH'
            then 1
        else 0
    end) AS low_line_count
FROM
    orders,
    lineitem
WHERE
    o_orderkey = l_orderkey
    AND l_shipmode IN ('MAIL', 'SHIP')
    AND l_commitdate < l_receiptdate
    AND l_shipdate < l_commitdate
    AND l_receiptdate >= DATE '1994-01-01'
    AND l_receiptdate < DATE '1994-01-01' + INTERVAL '1' year
GROUP BY
    l_shipmode
ORDER BY
    l_shipmode
----
Reduce {
  group_key: [#23],
  aggregates: [
    sum(if (#5 = "1-URGENT") || (#5 = "2-HIGH") then 1 else 0),
    sum(if (#5 != "1-URGENT") && (#5 != "2-HIGH") then 1 else 0)
  ],
  Filter {
    predicates: [
      (#23 = "MAIL") || (#23 = "SHIP"),
      #19 < #20,
      #20 < #21,
      datetots #21 < 1995-01-01 00:00:00,
      #21 >= 1994-01-01
    ],
    Join {
      variables: [[(0, 0), (1, 0)]],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.orders (u18) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.lineitem (u21) }
      }
    }
  }
}


query T multiline
-- Query 13
EXPLAIN PLAN FOR SELECT
    c_count,
    count(*) AS custdist
FROM
    (
        SELECT
            c_custkey,
            count(o_orderkey) c_count -- workaround for no column aliases
        FROM
            customer LEFT OUTER JOIN orders ON
                c_custkey = o_custkey
                AND o_comment NOT LIKE '%special%requests%'
        GROUP BY
            c_custkey
    ) AS c_orders -- (c_custkey, c_count) -- no column aliases yet
GROUP BY
    c_count
ORDER BY
    custdist DESC,
    c_count DESC
----
Let {
  l0 = Filter {
    predicates: [!(^.*special.*requests.*$ ~ #16)],
    Join {
      variables: [[(0, 0), (1, 1)]],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.customer (u15) }
      },
      ArrangeBy {
        keys: [[#1]],
        Get { materialize.public.orders (u18) }
      }
    }
  }
} in
Reduce {
  group_key: [#1],
  aggregates: [countall(null)],
  Reduce {
    group_key: [#0],
    aggregates: [count(#8)],
    Union {
      Get { l0 },
      Map {
        scalars: [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        Union {
          Negate {
            Distinct {
              group_key: [#0, #1, #2, #3, #4, #5, #6, #7],
              Get { l0 }
            }
          },
          Get { materialize.public.customer (u15) }
        }
      }
    }
  }
}


query T multiline
-- Query 14
EXPLAIN PLAN FOR SELECT
    100.00 * sum(case
        when p_type like 'PROMO%'
            then l_extendedprice * (1 - l_discount)
        else 0
    end) / sum(l_extendedprice * (1 - l_discount)) AS promo_revenue
FROM
    lineitem,
    part
WHERE
    l_partkey = p_partkey
    AND l_shipdate >= DATE '1996-01-01'
    AND l_shipdate < DATE '1996-01-01' + INTERVAL '1' month
----
Let {
  l0 = Reduce {
    group_key: [],
    aggregates: [
      sum(if ^PROMO.*$ ~ #20 then #5 * (100dec - #6) else 0dec),
      sum(#5 * (100dec - #6))
    ],
    Filter {
      predicates: [
        datetots #10 < 1996-02-01 00:00:00,
        #10 >= 1996-01-01
      ],
      Join {
        variables: [[(0, 1), (1, 0)]],
        implementation: DeltaQuery,
        ArrangeBy {
          keys: [[#1]],
          Get { materialize.public.lineitem (u21) }
        },
        ArrangeBy {
          keys: [[#0]],
          Get { materialize.public.part (u6) }
        }
      }
    }
  }
} in
Project {
  outputs: [2],
  Map {
    scalars: [(((10000dec * #0) * 10000000dec) / #1) * 1000dec],
    Union {
      Get { l0 },
      Map {
        scalars: [null, null],
        Union {
          Project { outputs: [], Negate { Get { l0 } } },
          Constant [[]]
        }
      }
    }
  }
}


statement ok
create view revenue (supplier_no, total_revenue) as
    SELECT
        l_suppkey,
        sum(l_extendedprice * (1 - l_discount))
    FROM
        lineitem
    WHERE
        l_shipdate >= DATE '1996-01-01'
        AND l_shipdate < DATE '1996-01-01' + INTERVAL '3' month
    GROUP BY
        l_suppkey

query T multiline
-- Query 15
EXPLAIN PLAN FOR SELECT
    s_suppkey,
    s_name,
    s_address,
    s_phone,
    total_revenue
FROM
    supplier,
    revenue
WHERE
    s_suppkey = supplier_no
    AND total_revenue = (
        SELECT
            max(total_revenue)
        FROM
            revenue
    )
ORDER BY
    s_suppkey
----
Project {
  outputs: [0 .. 2, 4, 8],
  Join {
    variables: [[(0, 0), (1, 0)], [(0, 1), (2, 0)]],
    implementation: DifferentialLinear,
    Filter {
      predicates: [!isnull #1],
      Get { materialize.public.revenue (u27) }
    },
    ArrangeBy {
      keys: [[#0]],
      Get { materialize.public.supplier (u8) }
    },
    ArrangeBy {
      keys: [[#0]],
      Filter {
        predicates: [!isnull #0],
        Reduce {
          group_key: [],
          aggregates: [max(#1)],
          Get { materialize.public.revenue (u27) }
        }
      }
    }
  }
}

statement ok
drop view revenue


query T multiline
-- Query 16
EXPLAIN PLAN FOR SELECT
    p_brand,
    p_type,
    p_size,
    count(DISTINCT ps_suppkey) AS supplier_cnt
FROM
    partsupp,
    part
WHERE
    p_partkey = ps_partkey
    AND p_brand <> 'Brand#45'
    AND p_type NOT LIKE 'MEDIUM POLISHED%'
    AND p_size IN (49, 14, 23, 45, 19, 3, 36, 9)
    AND ps_suppkey NOT IN (
        SELECT
            s_suppkey
        FROM
            supplier
        WHERE
            s_comment like '%Customer%Complaints%'
    )
GROUP BY
    p_brand,
    p_type,
    p_size
ORDER BY
    supplier_cnt DESC,
    p_brand,
    p_type,
    p_size
----
Let {
  l0 = Filter {
    predicates: [
      !(^MEDIUM POLISHED.*$ ~ #9),
      (
        (
          (
            ((((#10 = 49) || (#10 = 14)) || (#10 = 23)) || (#10 = 45))
            ||
            (#10 = 19)
          )
          ||
          (#10 = 3)
        )
        ||
        (#10 = 36)
      )
      ||
      (#10 = 9),
      #8 != "Brand#45"
    ],
    Join {
      variables: [[(0, 0), (1, 0)]],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.partsupp (u11) }
      },
      ArrangeBy { keys: [[#0]], Get { materialize.public.part (u6) } }
    }
  }
} in
Let { l1 = Distinct { group_key: [#1], Get { l0 } } } in
Let {
  l2 = Reduce {
    group_key: [#0],
    aggregates: [all(#0 != #1)],
    Join {
      variables: [],
      implementation: DifferentialLinear,
      Filter {
        predicates: [^.*Customer.*Complaints.*$ ~ #6],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy { keys: [[]], Get { l1 } }
    }
  }
} in
Reduce {
  group_key: [#8, #9, #10],
  aggregates: [count(distinct #1)],
  Join {
    variables: [[(0, 0), (1, 1)]],
    implementation: DifferentialLinear,
    Union {
      Filter { predicates: [#1], Get { l2 } },
      Map {
        scalars: [true],
        Union {
          Project { outputs: [0], Negate { Get { l2 } } },
          Get { l1 }
        }
      }
    },
    ArrangeBy { keys: [[#1]], Get { l0 } }
  }
}


query T multiline
-- Query 17
EXPLAIN PLAN FOR SELECT
  sum(l_extendedprice) / 7.0 AS avg_yearly
FROM
  lineitem,
  part
WHERE
  p_partkey = l_partkey
  AND p_brand = 'Brand#23'
  AND p_container = 'MED BOX'
  AND l_quantity < (
    SELECT
      0.2 * avg(l_quantity)
    FROM
      lineitem
    WHERE
      l_partkey = p_partkey
  )
----
Let {
  l0 = Filter {
    predicates: [#19 = "Brand#23", #22 = "MED BOX"],
    Join {
      variables: [[(0, 1), (1, 0)]],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#1]],
        Get { materialize.public.lineitem (u21) }
      },
      ArrangeBy { keys: [[#0]], Get { materialize.public.part (u6) } }
    }
  }
} in
Let {
  l1 = Reduce {
    group_key: [],
    aggregates: [sum(#5)],
    Filter {
      predicates: [(#4 * 10000000dec) < #28],
      Join {
        variables: [[(0, 1), (1, 0)]],
        implementation: DifferentialLinear,
        Get { l0 },
        ArrangeBy {
          keys: [[#0]],
          Map {
            scalars: [
              2dec
              *
              (((#1 * 10000000dec) / (i64todec #2 * 100dec)) * 10dec)
            ],
            Reduce {
              group_key: [#0],
              aggregates: [sum(#5), countall(null)],
              Join {
                variables: [[(0, 0), (1, 1)]],
                implementation: DeltaQuery,
                ArrangeBy {
                  keys: [[#0]],
                  Distinct { group_key: [#1], Get { l0 } }
                },
                ArrangeBy {
                  keys: [[#1]],
                  Get { materialize.public.lineitem (u21) }
                }
              }
            }
          }
        }
      }
    }
  }
} in
Project {
  outputs: [1],
  Map {
    scalars: [(#0 * 10000000dec) / 70dec],
    Union {
      Get { l1 },
      Map {
        scalars: [null],
        Union {
          Project { outputs: [], Negate { Get { l1 } } },
          Constant [[]]
        }
      }
    }
  }
}


query T multiline
-- Query 18
EXPLAIN PLAN FOR SELECT
    c_name,
    c_custkey,
    o_orderkey,
    o_orderdate,
    o_totalprice,
    sum(l_quantity)
FROM
    customer,
    orders,
    lineitem
WHERE
    o_orderkey IN (
        SELECT
            l_orderkey
        FROM
            lineitem
        GROUP BY
            l_orderkey having
                sum(l_quantity) > 300
    )
    AND c_custkey = o_custkey
    AND o_orderkey = l_orderkey
GROUP BY
    c_name,
    c_custkey,
    o_orderkey,
    o_orderdate,
    o_totalprice
ORDER BY
    o_totalprice DESC,
    o_orderdate
----
Let {
  l0 = Join {
    variables: [[(0, 0), (1, 1)], [(1, 0), (2, 0)]],
    implementation: DeltaQuery,
    ArrangeBy {
      keys: [[#0]],
      Get { materialize.public.customer (u15) }
    },
    ArrangeBy {
      keys: [[#0], [#1]],
      Get { materialize.public.orders (u18) }
    },
    ArrangeBy {
      keys: [[#0]],
      Get { materialize.public.lineitem (u21) }
    }
  }
} in
Reduce {
  group_key: [#1, #0, #8, #12, #11],
  aggregates: [sum(#21)],
  Join {
    variables: [[(0, 8), (1, 0)]],
    implementation: DifferentialLinear,
    Get { l0 },
    ArrangeBy {
      keys: [[#0]],
      Reduce {
        group_key: [#0],
        aggregates: [any(true)],
        Filter {
          predicates: [#2 > 30000dec],
          Reduce {
            group_key: [#0, #0],
            aggregates: [sum(#5)],
            Join {
              variables: [[(0, 0), (1, 0)]],
              implementation: DeltaQuery,
              ArrangeBy {
                keys: [[#0]],
                Distinct { group_key: [#8], Get { l0 } }
              },
              ArrangeBy {
                keys: [[#0]],
                Get { materialize.public.lineitem (u21) }
              }
            }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 19
EXPLAIN PLAN FOR SELECT
    sum(l_extendedprice* (1 - l_discount)) AS revenue
FROM
    lineitem,
    part
WHERE
    (
        p_partkey = l_partkey
        AND p_brand = 'Brand#12'
        AND p_container IN ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
        AND l_quantity >= CAST (1 AS smallint) AND l_quantity <= CAST (1 + 10 AS smallint)
        AND p_size BETWEEN CAST (1 AS smallint) AND CAST (5 AS smallint)
        AND l_shipmode IN ('AIR', 'AIR REG')
        AND l_shipinstruct = 'DELIVER IN PERSON'
    )
    or
    (
        p_partkey = l_partkey
        AND p_brand = 'Brand#23'
        AND p_container IN ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
        AND l_quantity >= CAST (10 AS smallint) AND l_quantity <= CAST (10 + 10 AS smallint)
        AND p_size BETWEEN CAST (1 AS smallint) AND CAST (10 AS smallint)
        AND l_shipmode IN ('AIR', 'AIR REG')
        AND l_shipinstruct = 'DELIVER IN PERSON'
    )
    or
    (
        p_partkey = l_partkey
        AND p_brand = 'Brand#34'
        AND p_container IN ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
        AND l_quantity >= CAST (20 AS smallint) AND l_quantity <= CAST (20 + 10 AS smallint)
        AND p_size BETWEEN CAST (1 AS smallint) AND CAST (15 AS smallint)
        AND l_shipmode IN ('AIR', 'AIR REG')
        AND l_shipinstruct = 'DELIVER IN PERSON'
    )
----
Let {
  l0 = Reduce {
    group_key: [],
    aggregates: [sum(#5 * (100dec - #6))],
    Filter {
      predicates: [
        (
          (
            (
              (
                (
                  (#19 = "Brand#12")
                  &&
                  (
                    (
                      ((#22 = "SM CASE") || (#22 = "SM BOX"))
                      ||
                      (#22 = "SM PACK")
                    )
                    ||
                    (#22 = "SM PKG")
                  )
                )
                &&
                (#4 >= 100dec)
              )
              &&
              (#4 <= 1100dec)
            )
            &&
            (#21 <= 5)
          )
          ||
          (
            (
              (
                (
                  (#19 = "Brand#23")
                  &&
                  (
                    (
                      ((#22 = "MED BAG") || (#22 = "MED BOX"))
                      ||
                      (#22 = "MED PKG")
                    )
                    ||
                    (#22 = "MED PACK")
                  )
                )
                &&
                (#4 >= 1000dec)
              )
              &&
              (#4 <= 2000dec)
            )
            &&
            (#21 <= 10)
          )
        )
        ||
        (
          (
            (
              (
                (#19 = "Brand#34")
                &&
                (
                  (
                    ((#22 = "LG CASE") || (#22 = "LG BOX"))
                    ||
                    (#22 = "LG PACK")
                  )
                  ||
                  (#22 = "LG PKG")
                )
              )
              &&
              (#4 >= 2000dec)
            )
            &&
            (#4 <= 3000dec)
          )
          &&
          (#21 <= 15)
        ),
        (#14 = "AIR") || (#14 = "AIR REG"),
        #13 = "DELIVER IN PERSON",
        #21 >= 1
      ],
      Join {
        variables: [[(0, 1), (1, 0)]],
        implementation: DeltaQuery,
        ArrangeBy {
          keys: [[#1]],
          Get { materialize.public.lineitem (u21) }
        },
        ArrangeBy {
          keys: [[#0]],
          Get { materialize.public.part (u6) }
        }
      }
    }
  }
} in
Union {
  Get { l0 },
  Map {
    scalars: [null],
    Union {
      Project { outputs: [], Negate { Get { l0 } } },
      Constant [[]]
    }
  }
}


query T multiline
-- Query 20
EXPLAIN PLAN FOR SELECT
    s_name,
    s_address
FROM
    supplier,
    nation
WHERE
    s_suppkey IN (
        SELECT
            ps_suppkey
        FROM
            partsupp
        WHERE
            ps_partkey IN (
                SELECT
                    p_partkey
                FROM
                    part
                WHERE
                    p_name like 'forest%'
            )
            AND ps_availqty > (
                SELECT
                    0.5 * sum(l_quantity)
                FROM
                    lineitem
                WHERE
                    l_partkey = ps_partkey
                    AND l_suppkey = ps_suppkey
                    AND l_shipdate >= DATE '1995-01-01'
                    AND l_shipdate < DATE '1995-01-01' + INTERVAL '1' year
            )
    )
    AND s_nationkey = n_nationkey
    AND n_name = 'CANADA'
ORDER BY
    s_name
----
Let {
  l0 = Filter {
    predicates: [#8 = "CANADA"],
    Join {
      variables: [[(0, 3), (1, 0)]],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#3]],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.nation (u1) }
      }
    }
  }
} in
Let {
  l1 = Join {
    variables: [],
    implementation: DifferentialLinear,
    Get { materialize.public.partsupp (u11) },
    ArrangeBy { keys: [[]], Get { l0 } }
  }
} in
Let {
  l2 = Map {
    scalars: [true],
    Filter {
      predicates: [^forest.*$ ~ #18],
      Join {
        variables: [[(0, 11), (1, 0), (2, 0)]],
        implementation: DifferentialLinear,
        Get { l1 },
        ArrangeBy {
          keys: [[#0]],
          Distinct { group_key: [#11], Get { l1 } }
        },
        ArrangeBy {
          keys: [[#0]],
          Get { materialize.public.part (u6) }
        }
      }
    }
  }
} in
Project {
  outputs: [1, 2],
  Join {
    variables: [[(0, 0), (1, 0)]],
    implementation: DifferentialLinear,
    Get { l0 },
    ArrangeBy {
      keys: [[#0]],
      Reduce {
        group_key: [#0],
        aggregates: [any(true)],
        Filter {
          predicates: [(i32todec #13 * 1000dec) > #30],
          Join {
            variables: [[(0, 11), (1, 0)], [(0, 12), (1, 1)]],
            implementation: DifferentialLinear,
            Filter { predicates: [#0 = #12], Get { l2 } },
            ArrangeBy {
              keys: [[#0, #1]],
              Map {
                scalars: [5dec * #2],
                Reduce {
                  group_key: [#0, #1],
                  aggregates: [sum(#6)],
                  Filter {
                    predicates: [
                      datetots #12 < 1996-01-01 00:00:00,
                      #12 >= 1995-01-01
                    ],
                    Join {
                      variables: [[(0, 0), (1, 1)], [(0, 1), (1, 2)]],
                      implementation: DeltaQuery,
                      ArrangeBy {
                        keys: [[#0, #1]],
                        Distinct { group_key: [#11, #12], Get { l2 } }
                      },
                      ArrangeBy {
                        keys: [[#1, #2]],
                        Get { materialize.public.lineitem (u21) }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 21
EXPLAIN PLAN FOR SELECT
    s_name,
    count(*) AS numwait
FROM
    supplier,
    lineitem l1,
    orders,
    nation
WHERE
    s_suppkey = l1.l_suppkey
    AND o_orderkey = l1.l_orderkey
    AND o_orderstatus = 'F'
    AND l1.l_receiptdate > l1.l_commitdate
    AND EXISTS (
        SELECT
            *
        FROM
            lineitem l2
        WHERE
            l2.l_orderkey = l1.l_orderkey
            AND l2.l_suppkey <> l1.l_suppkey
    )
    AND not EXISTS (
        SELECT
            *
        FROM
            lineitem l3
        WHERE
            l3.l_orderkey = l1.l_orderkey
            AND l3.l_suppkey <> l1.l_suppkey
            AND l3.l_receiptdate > l3.l_commitdate
    )
    AND s_nationkey = n_nationkey
    AND n_name = 'SAUDI ARABIA'
GROUP BY
    s_name
ORDER BY
    numwait DESC,
    s_name
----
Let {
  l0 = Filter {
    predicates: [#25 = "F", #33 = "SAUDI ARABIA", #19 > #18],
    Join {
      variables: [
        [(0, 0), (1, 2)],
        [(0, 3), (3, 0)],
        [(1, 0), (2, 0)]
      ],
      implementation: DeltaQuery,
      ArrangeBy {
        keys: [[#0], [#3]],
        Get { materialize.public.supplier (u8) }
      },
      ArrangeBy {
        keys: [[#0], [#2]],
        Get { materialize.public.lineitem (u21) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.orders (u18) }
      },
      ArrangeBy {
        keys: [[#0]],
        Get { materialize.public.nation (u1) }
      }
    }
  }
} in
Let {
  l1 = Map {
    scalars: [true],
    Join {
      variables: [[(0, 0), (1, 1)], [(0, 7), (1, 0)]],
      implementation: DifferentialLinear,
      Get { l0 },
      ArrangeBy {
        keys: [[#0, #1]],
        Distinct {
          group_key: [#0, #1],
          Filter {
            predicates: [#4 != #1],
            Join {
              variables: [[(0, 0), (1, 0)]],
              implementation: DifferentialLinear,
              Distinct { group_key: [#7, #0], Get { l0 } },
              ArrangeBy {
                keys: [[#0]],
                Get { materialize.public.lineitem (u21) }
              }
            }
          }
        }
      }
    }
  }
} in
Let { l2 = Distinct { group_key: [#7, #0], Get { l1 } } } in
Reduce {
  group_key: [#1],
  aggregates: [countall(null)],
  Join {
    variables: [[(0, 0), (1, 7)], [(0, 1), (1, 0)]],
    implementation: DifferentialLinear,
    Union {
      Project {
        outputs: [0, 1],
        Negate {
          Map {
            scalars: [true],
            Distinct {
              group_key: [#0, #1],
              Filter {
                predicates: [#4 != #1, #14 > #13],
                Join {
                  variables: [[(0, 0), (1, 0)]],
                  implementation: DifferentialLinear,
                  Get { l2 },
                  ArrangeBy {
                    keys: [[#0]],
                    Get { materialize.public.lineitem (u21) }
                  }
                }
              }
            }
          }
        }
      },
      Get { l2 }
    },
    ArrangeBy { keys: [[#7, #0]], Get { l1 } }
  }
}


query T multiline
-- Query 22
EXPLAIN PLAN FOR SELECT
    cntrycode,
    count(*) AS numcust,
    sum(c_acctbal) AS totacctbal
FROM
    (
        SELECT
            substring(c_phone, 1, 2) AS cntrycode, c_acctbal
        FROM
            customer
        WHERE
            substring(c_phone, 1, 2)
            IN (':1', ':2', ':3', ':4', ':5', ':6', ':7')
            AND c_acctbal
                > (
                        SELECT
                            avg(c_acctbal)
                        FROM
                            customer
                        WHERE
                            c_acctbal > 0.00
                            AND substring(c_phone, 1, 2)
                                IN (
                                        '13',
                                        '31',
                                        '23',
                                        '29',
                                        '30',
                                        '18',
                                        '17'
                                    )
                    )
            AND NOT
                    EXISTS(
                        SELECT
                            *
                        FROM
                            orders
                        WHERE
                            o_custkey = c_custkey
                    )
    )
        AS custsale
GROUP BY
    cntrycode
ORDER BY
    cntrycode
----
Let {
  l0 = Filter {
    predicates: [(#5 * 1000000dec) > #10],
    Join {
      variables: [],
      implementation: DifferentialLinear,
      Filter {
        predicates: [
          (
            (
              (
                (
                  (
                    (substr(#4, 1, 2) = ":1")
                    ||
                    (substr(#4, 1, 2) = ":2")
                  )
                  ||
                  (substr(#4, 1, 2) = ":3")
                )
                ||
                (substr(#4, 1, 2) = ":4")
              )
              ||
              (substr(#4, 1, 2) = ":5")
            )
            ||
            (substr(#4, 1, 2) = ":6")
          )
          ||
          (substr(#4, 1, 2) = ":7")
        ],
        Get { materialize.public.customer (u15) }
      },
      ArrangeBy {
        keys: [[]],
        Map {
          scalars: [
            ((#0 * 10000000dec) / (i64todec #1 * 100dec)) * 10dec
          ],
          Reduce {
            group_key: [],
            aggregates: [sum(#5), countall(null)],
            Filter {
              predicates: [
                (
                  (
                    (
                      (
                        (
                          (substr(#4, 1, 2) = "13")
                          ||
                          (substr(#4, 1, 2) = "31")
                        )
                        ||
                        (substr(#4, 1, 2) = "23")
                      )
                      ||
                      (substr(#4, 1, 2) = "29")
                    )
                    ||
                    (substr(#4, 1, 2) = "30")
                  )
                  ||
                  (substr(#4, 1, 2) = "18")
                )
                ||
                (substr(#4, 1, 2) = "17"),
                #5 > 0dec
              ],
              Get { materialize.public.customer (u15) }
            }
          }
        }
      }
    }
  }
} in
Reduce {
  group_key: [substr(#4, 1, 2)],
  aggregates: [countall(null), sum(#5)],
  Join {
    variables: [[(0, 0), (1, 0)]],
    implementation: DifferentialLinear,
    Union {
      Project {
        outputs: [0],
        Negate {
          Map {
            scalars: [true],
            Distinct {
              group_key: [#0],
              Join {
                variables: [[(0, 0), (1, 1)]],
                implementation: DeltaQuery,
                ArrangeBy { keys: [[#0]], Get { l0 } },
                ArrangeBy {
                  keys: [[#1]],
                  Get { materialize.public.orders (u18) }
                }
              }
            }
          }
        }
      },
      Project { outputs: [0], Get { l0 } }
    },
    ArrangeBy { keys: [[#0]], Get { l0 } }
  }
}
