# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

mode cockroach

statement ok
CREATE TABLE t1(f1 int, f2 int)

statement ok
CREATE TABLE t2(f1 int, f2 int)

statement ok
INSERT INTO t1 VALUES (1, 2)

# regression test for #7049: a filter on COUNT aggregation must not trigger the outer to inner join conversion
query T multiline
EXPLAIN select t1.f1, count(t2.f1) from t1 LEFT JOIN t2 ON t1.f1 = t2.f1 group by t1.f1 having count(t2.f1) >= 0;
----
%0 =
| Get materialize.public.t1 (u1)
| Filter !(isnull(#0))
| ArrangeBy (#0)

%1 =
| Get materialize.public.t2 (u3)
| Filter !(isnull(#0))

%2 = Let l0 =
| Join %0 %1 (= #0 #2)
| | implementation = Differential %1 %0.(#0)
| | demand = (#0)

%3 =
| Get materialize.public.t1 (u1)

%4 =
| Get %2 (l0)
| Distinct group=(#0)
| ArrangeBy (#0)

%5 =
| Join %3 %4 (= #0 #2)
| | implementation = Differential %3 %4.(#0)
| | demand = (#0)
| Negate
| Project (#0, #1)

%6 =
| Get materialize.public.t1 (u1)

%7 =
| Union %5 %6
| Map null, null

%8 =
| Get %2 (l0)
| Project (#0, #1, #0, #3)

%9 =
| Union %7 %8
| Reduce group=(#0)
| | agg count(#2)
| Filter (#1 >= 0)

EOF

query II
select t1.f1, count(t2.f1) from t1 LEFT JOIN t2 ON t1.f1 = t2.f1 group by t1.f1 having count(t2.f1) >= 0;
----
1 0

# ... but a filter on any other aggregation should convert a left join into an inner join if its parameter comes from the non-preserving side
query T multiline
EXPLAIN select t1.f1, sum(t2.f1) from t1 LEFT JOIN t2 ON t1.f1 = t2.f1 group by t1.f1 having sum(t2.f1) >= 0;
----
%0 =
| Get materialize.public.t1 (u1)
| Filter !(isnull(#0))
| ArrangeBy (#0)

%1 =
| Get materialize.public.t2 (u3)
| Filter !(isnull(#0))

%2 =
| Join %0 %1 (= #0 #2)
| | implementation = Differential %1 %0.(#0)
| | demand = (#0)
| Reduce group=(#0)
| | agg sum(#0)
| Filter (#1 >= 0)

EOF

query II
select t1.f1, sum(t2.f1) from t1 LEFT JOIN t2 ON t1.f1 = t2.f1 group by t1.f1 having sum(t2.f1) >= 0;
----

# multiple aggregations
query T multiline
EXPLAIN select t1.f1, count(t2.f1), sum(t2.f1), max(t2.f1), min(t2.f1), count(t1.f2), sum(t1.f2), min(t1.f2), max(t1.f2) from t1 LEFT JOIN t2 ON t1.f1 = t2.f1 group by t1.f1;
----
%0 =
| Get materialize.public.t1 (u1)
| Filter !(isnull(#0))
| ArrangeBy (#0)

%1 =
| Get materialize.public.t2 (u3)
| Filter !(isnull(#0))

%2 = Let l0 =
| Join %0 %1 (= #0 #2)
| | implementation = Differential %1 %0.(#0)
| | demand = (#0, #1)

%3 =
| Get materialize.public.t1 (u1)

%4 =
| Get %2 (l0)
| Distinct group=(#0)
| ArrangeBy (#0)

%5 =
| Join %3 %4 (= #0 #2)
| | implementation = Differential %3 %4.(#0)
| | demand = (#0, #1)
| Negate
| Project (#0, #1)

%6 =
| Get materialize.public.t1 (u1)

%7 =
| Union %5 %6
| Map null, null

%8 =
| Get %2 (l0)
| Project (#0, #1, #0, #3)

%9 =
| Union %7 %8
| Reduce group=(#0)
| | agg count(#2)
| | agg sum(#2)
| | agg max(#2)
| | agg min(#2)
| | agg count(#1)
| | agg sum(#1)
| | agg min(#1)
| | agg max(#1)

EOF

query T multiline
EXPLAIN select t1.f1, count(t2.f1), sum(t2.f1), max(t2.f1), min(t2.f1), count(t1.f2), sum(t1.f2), min(t1.f2), max(t1.f2) from t1 LEFT JOIN t2 ON t1.f1 = t2.f1 group by t1.f1 having sum(t1.f2) >= 0;
----
%0 =
| Get materialize.public.t1 (u1)
| Filter !(isnull(#0))
| ArrangeBy (#0)

%1 =
| Get materialize.public.t2 (u3)
| Filter !(isnull(#0))

%2 = Let l0 =
| Join %0 %1 (= #0 #2)
| | implementation = Differential %1 %0.(#0)
| | demand = (#0, #1)

%3 =
| Get materialize.public.t1 (u1)

%4 =
| Get %2 (l0)
| Distinct group=(#0)
| ArrangeBy (#0)

%5 =
| Join %3 %4 (= #0 #2)
| | implementation = Differential %3 %4.(#0)
| | demand = (#0, #1)
| Negate
| Project (#0, #1)

%6 =
| Get materialize.public.t1 (u1)

%7 =
| Union %5 %6
| Map null, null

%8 =
| Get %2 (l0)
| Project (#0, #1, #0, #3)

%9 =
| Union %7 %8
| Reduce group=(#0)
| | agg count(#2)
| | agg sum(#2)
| | agg max(#2)
| | agg min(#2)
| | agg count(#1)
| | agg sum(#1)
| | agg min(#1)
| | agg max(#1)
| Filter (#6 >= 0)

EOF

query T multiline
EXPLAIN select t1.f1, count(t2.f1), sum(t2.f1), max(t2.f1), min(t2.f1), count(t1.f2), sum(t1.f2), min(t1.f2), max(t1.f2) from t1 LEFT JOIN t2 ON t1.f1 = t2.f1 group by t1.f1 having sum(t2.f1) >= 0;
----
%0 =
| Get materialize.public.t1 (u1)
| Filter !(isnull(#0))
| ArrangeBy (#0)

%1 =
| Get materialize.public.t2 (u3)
| Filter !(isnull(#0))

%2 =
| Join %0 %1 (= #0 #2)
| | implementation = Differential %1 %0.(#0)
| | demand = (#0, #1)
| Reduce group=(#0)
| | agg count(#0)
| | agg sum(#0)
| | agg max(#0)
| | agg min(#0)
| | agg count(#1)
| | agg sum(#1)
| | agg min(#1)
| | agg max(#1)
| Filter (#2 >= 0)

EOF

# count is never null, predicate removed
query T multiline
EXPLAIN select t1.f1, count(t1.f2) from t1 group by t1.f1 having count(t1.f2) is not null;
----
%0 =
| Get materialize.public.t1 (u1)
| Reduce group=(#0)
| | agg count(#1)

EOF

query T multiline
EXPLAIN select t1.f1, sum(t1.f2) from t1 group by t1.f1 having sum(t1.f2) is not null;
----
%0 =
| Get materialize.public.t1 (u1)
| Reduce group=(#0)
| | agg sum(#1)
| Filter !(isnull(#1))

EOF

# regression test for #7047
statement ok
drop table t1

statement ok
create table t1(f1 integer)

statement ok
insert into t1 values (0), (1)

query T multiline
EXPLAIN SELECT * FROM (SELECT 123, COUNT(right_table.f1) AS aggregate FROM t1 AS left_table LEFT JOIN t1 AS right_table ON FALSE GROUP BY 1) AS subquery, t1 AS outer_table WHERE outer_table.f1 = subquery.aggregate;
----
%0 =
| Get materialize.public.t1 (u5)
| Reduce group=()
| | agg count(null)
| ArrangeBy (#0)

%1 =
| Get materialize.public.t1 (u5)
| Filter !(isnull(i32toi64(#0)))

%2 =
| Join %0 %1 (= #0 i32toi64(#1))
| | implementation = Differential %1 %0.(#0)
| | demand = (#0, #1)
| Map 123
| Project (#2, #0, #1)

EOF

query III
SELECT * FROM (SELECT 123, COUNT(right_table.f1) AS aggregate FROM t1 AS left_table LEFT JOIN t1 AS right_table ON FALSE GROUP BY 1) AS subquery, t1 AS outer_table WHERE outer_table.f1 = subquery.aggregate;
----
123  0  0
