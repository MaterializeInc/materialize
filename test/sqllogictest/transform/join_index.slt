# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

statement ok
DROP TABLE IF EXISTS foo;

statement ok
DROP TABLE IF EXISTS bar;

statement ok
CREATE TABLE foo(a int, b int)

statement ok
INSERT INTO foo VALUES (1, 2), (-1, 4), (null, 3)

statement ok
CREATE TABLE bar(a int, b int)

statement ok
INSERT INTO bar VALUES (1, 3), (-1, null), (null, 5)

# no indexes other than the default foo(a,b) and bar(a,b)
query T multiline
EXPLAIN WITH(arity, join_impls) select * from foo inner join bar on foo.a = bar.a where foo.a = 1
----
Explained Query:
  CrossJoin type=differential // { arity: 4 }
    implementation
      %1:bar[×] » %0:foo[×]Aef
    ArrangeBy keys=[[]] // { arity: 2 }
      Filter (#0 = 1) // { arity: 2 }
        Get materialize.public.foo // { arity: 2 }
    ArrangeBy keys=[[]] // { arity: 2 }
      Filter (#0 = 1) // { arity: 2 }
        Get materialize.public.bar // { arity: 2 }

Source materialize.public.foo
  filter=((#0 = 1))
Source materialize.public.bar
  filter=((#0 = 1))

EOF

query IIII
select * from foo inner join bar on foo.a = bar.a where foo.a = 1
----
1
2
1
3

# no indexes other than the default foo(a,b) and bar(a,b)
query T multiline
EXPLAIN WITH(arity, join_impls) select * from foo inner join bar on foo.a = abs(bar.a) where mod(foo.a, 2) = 1
----
Explained Query:
  Join on=(#0 = abs(#2)) type=differential // { arity: 4 }
    implementation
      %1:bar[abs(#0)] » %0:foo[#0]KAef
    ArrangeBy keys=[[#0]] // { arity: 2 }
      Filter (1 = (#0 % 2)) // { arity: 2 }
        Get materialize.public.foo // { arity: 2 }
    ArrangeBy keys=[[abs(#0)]] // { arity: 2 }
      Filter (1 = (abs(#0) % 2)) // { arity: 2 }
        Get materialize.public.bar // { arity: 2 }

Source materialize.public.foo
  filter=((1 = (#0 % 2)))
Source materialize.public.bar
  filter=((1 = (abs(#0) % 2)))

EOF

query IIII
select * from foo inner join bar on foo.a = abs(bar.a) where mod(foo.a, 2) = 1
----
1
2
-1
NULL
1
2
1
3

# Test that column knowledge can propagate across inputs of a join.
# no indexes other than the default foo(a,b) and bar(a,b)
query T multiline
EXPLAIN WITH(arity, join_impls) select * from (select * from foo where a = 1) filtered_foo, bar where filtered_foo.a = bar.a
----
Explained Query:
  CrossJoin type=differential // { arity: 4 }
    implementation
      %1:bar[×] » %0:foo[×]Aef
    ArrangeBy keys=[[]] // { arity: 2 }
      Filter (#0 = 1) // { arity: 2 }
        Get materialize.public.foo // { arity: 2 }
    ArrangeBy keys=[[]] // { arity: 2 }
      Filter (#0 = 1) // { arity: 2 }
        Get materialize.public.bar // { arity: 2 }

Source materialize.public.foo
  filter=((#0 = 1))
Source materialize.public.bar
  filter=((#0 = 1))

EOF

query IIII
select * from (select * from foo where a = 1) filtered_foo, bar where filtered_foo.a = bar.a
----
1
2
1
3

statement ok
CREATE INDEX foo_idx on foo(a);

statement ok
CREATE INDEX bar_idx on bar(a);

statement ok
CREATE TABLE baz(a int primary key, b int)

statement ok
INSERT INTO baz VALUES (3, 0), (5, 2)

# indexes exist on foo(a), bar(a), and baz(a). baz(a) is a unique key
query T multiline
EXPLAIN WITH(arity, join_impls)
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
Explained Query:
  Project (#0, #5) // { arity: 2 }
    Join on=(#0 = #2 AND #3 = #4) type=differential // { arity: 6 }
      implementation
        %1:bar[#1] » %2:baz[#0]UKA » %0:foo[#0]KA
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.foo // { arity: 2 }
      ArrangeBy keys=[[#1]] // { arity: 2 }
        Filter (#0) IS NOT NULL AND (#1) IS NOT NULL // { arity: 2 }
          Get materialize.public.bar // { arity: 2 }
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.baz // { arity: 2 }

Used Indexes:
  - materialize.public.foo_idx
  - materialize.public.bar_idx

EOF

query II
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
1
0

statement ok
DROP TABLE baz

statement ok
CREATE TABLE baz(a int, b int)

statement ok
INSERT INTO baz VALUES (3, 0), (5, 2), (null, 6)

statement ok
CREATE INDEX baz_idx on baz(a);

# indexes exist on foo(a), bar(a), and baz(a)
query T multiline
EXPLAIN WITH(arity, join_impls)
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
Explained Query:
  Project (#0, #5) // { arity: 2 }
    Filter (#0) IS NOT NULL AND (#3) IS NOT NULL // { arity: 6 }
      Join on=(#0 = #2 AND #3 = #4) type=differential // { arity: 6 }
        implementation
          %1:bar[#0] » %0:foo[#0]KA » %2:baz[#0]KA
        ArrangeBy keys=[[#0]] // { arity: 2 }
          Get materialize.public.foo // { arity: 2 }
        ArrangeBy keys=[[#0]] // { arity: 2 }
          Get materialize.public.bar // { arity: 2 }
        ArrangeBy keys=[[#0]] // { arity: 2 }
          Get materialize.public.baz // { arity: 2 }

Used Indexes:
  - materialize.public.foo_idx
  - materialize.public.bar_idx
  - materialize.public.baz_idx

EOF

query II
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
1
0

statement ok
CREATE INDEX foo_idx2 on foo(nullif(a, 0));

statement ok
CREATE INDEX bar_idx2 on bar(-a);

# Test that when join planning uses indexes on expressions.
# Protects against regression of #4170.
query T multiline
EXPLAIN WITH(arity, join_impls)
select foo.b, bar.b
from foo, bar
where nullif(foo.a, 0) = -bar.a
----
Explained Query:
  Project (#1, #3) // { arity: 2 }
    Filter (#2) IS NOT NULL AND (case when (#0 = 0) then null else #0 end) IS NOT NULL // { arity: 4 }
      Join on=(-(#2) = if (#0 = 0) then {null} else {#0}) type=differential // { arity: 4 }
        implementation
          %1:bar[-(#0)] » %0:foo[case when (#0 = 0) then null else #0 end]KA
        ArrangeBy keys=[[case when (#0 = 0) then null else #0 end]] // { arity: 2 }
          Get materialize.public.foo // { arity: 2 }
        ArrangeBy keys=[[-(#0)]] // { arity: 2 }
          Get materialize.public.bar // { arity: 2 }

Used Indexes:
  - materialize.public.foo_idx2
  - materialize.public.bar_idx2

EOF

query II
select foo.b, bar.b
from foo, bar
where nullif(foo.a, 0) = -bar.a
----
2
NULL
4
3

statement ok
DROP INDEX bar_idx;

statement ok
CREATE INDEX bar_idx3 on bar(a + 4);

# In this test, there exists an index on bar(a + 4)
# but not bar(a). Check that bar(a+4) is not inappropriately
# substituted for bar(a) in the first equivalence.
query T multiline
EXPLAIN WITH(arity, join_impls)
select foo.b, bar.b, baz.b
FROM bar, foo, baz
where foo.a = bar.a
  and bar.a + 4 = baz.a
----
Explained Query:
  Project (#3, #1, #5) // { arity: 3 }
    Filter (#0) IS NOT NULL AND (#4) IS NOT NULL // { arity: 6 }
      Join on=(#0 = #2 AND #4 = (#0 + 4)) type=differential // { arity: 6 }
        implementation
          %2:baz[#0] » %0:bar[(#0 + 4)]KA » %1:foo[#0]KA
        ArrangeBy keys=[[(#0 + 4)]] // { arity: 2 }
          Get materialize.public.bar // { arity: 2 }
        ArrangeBy keys=[[#0]] // { arity: 2 }
          Get materialize.public.foo // { arity: 2 }
        ArrangeBy keys=[[#0]] // { arity: 2 }
          Get materialize.public.baz // { arity: 2 }

Used Indexes:
  - materialize.public.foo_idx
  - materialize.public.baz_idx
  - materialize.public.bar_idx3

EOF

query III
select foo.b, bar.b, baz.b
FROM bar, foo, baz
where foo.a = bar.a
  and bar.a + 4 = baz.a
----
4
NULL
0
2
3
2

# tests that equalities involving multi-input equalities become join conditions.

query T multiline
explain with(arity, join_impls) select foo.b, bar.b from foo, bar, (select 1 as a) const where foo.a / bar.a = const.a
----
Explained Query:
  Project (#1, #3) // { arity: 2 }
    Join on=(1 = (#0 / #2)) type=differential // { arity: 4 }
      implementation
        %1:bar[×] » %0:foo[×]A
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.foo // { arity: 2 }
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.bar // { arity: 2 }

Used Indexes:
  - materialize.public.foo_idx
  - materialize.public.bar_idx2

EOF

query II
select foo.b, bar.b from foo, bar, (select 1 as a) const where foo.a / bar.a = const.a
----
4
NULL
2
3

query T multiline
explain with(arity, join_impls)
select foo.b, bar.b
from foo, bar, (select -1 as a) const
where foo.a / bar.a = const.a
and bar.b - foo.b = foo.a / bar.a
----
Explained Query:
  Project (#1, #3) // { arity: 2 }
    Join on=(eq(-1, (#3 - #1), (#0 / #2))) type=differential // { arity: 4 }
      implementation
        %1:bar[×] » %0:foo[×]A
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.foo // { arity: 2 }
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.bar // { arity: 2 }

Used Indexes:
  - materialize.public.foo_idx
  - materialize.public.bar_idx2

EOF

query II
select foo.b, bar.b
from foo, bar, (select -1 as a) const
where foo.a / bar.a = const.a
and bar.b - foo.b = foo.a / bar.a
----
4
3

statement ok
DROP INDEX baz_idx

# materialize#8002: it would be nice if this join used the indexes on foo(a)
# and bar(a+4)

query T multiline
EXPLAIN WITH(arity, join_impls)
select foo.b, bar.b, baz.b
FROM foo, bar, baz
where foo.a = bar.a
  and foo.a + 4 = baz.a
----
Explained Query:
  Project (#1, #3, #5) // { arity: 3 }
    Join on=(#0 = #2 AND #4 = (#0 + 4)) type=differential // { arity: 6 }
      implementation
        %2:baz[#0] » %0:foo[(#0 + 4)]KA » %1:bar[#0]KA
      ArrangeBy keys=[[(#0 + 4)]] // { arity: 2 }
        Filter (#0) IS NOT NULL // { arity: 2 }
          Get materialize.public.foo // { arity: 2 }
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Filter (#0) IS NOT NULL // { arity: 2 }
          Get materialize.public.bar // { arity: 2 }
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Filter (#0) IS NOT NULL // { arity: 2 }
          Get materialize.public.baz // { arity: 2 }

Source materialize.public.baz
  filter=((#0) IS NOT NULL)

Used Indexes:
  - materialize.public.foo_idx
  - materialize.public.bar_idx2

EOF

query III
select foo.b, bar.b, baz.b
FROM bar, foo, baz
where foo.a = bar.a
  and bar.a + 4 = baz.a
----
4
NULL
0
2
3
2

statement ok
CREATE TABLE t1 (f1 DOUBLE PRECISION, f2 DOUBLE PRECISION NOT NULL);

statement ok
CREATE INDEX t1i1 ON t1(f1);

statement ok
CREATE INDEX t1i2 ON t1(f2, f1);

# one NULL row in t1

statement ok
INSERT INTO t1 VALUES (NULL, 0);

# values 1 and 2 have 2 rows each in t1

statement ok
INSERT INTO t1 VALUES (1, 1), (1, 1), (2, 2), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8);

# value 9 not present in either table

statement ok
CREATE TABLE t2 (f1 DOUBLE PRECISION, f2 DOUBLE PRECISION NOT NULL);

statement ok
CREATE INDEX t2i1 ON t2(f1);

statement ok
CREATE INDEX i2i2 ON t2(f2, f1);

# two NULL rows in t2

statement ok
INSERT INTO t2 VALUES (NULL, 0), (NULL, 0), (1, 1);

# value 2 has 2 rows in t2
statement ok
INSERT INTO t2 VALUES (2, 2), (2, 2);

# value 3 has no rows in t2
statement ok
INSERT INTO t2 VALUES (4, 4), (5, 5), (6, 6), (7, 7), (8, 8);

query RRR
SELECT *
  FROM (
        SELECT AVG(f1) + 10000 AS agg1
          FROM t1
       ) a1,
       t1 a2
 WHERE a2.f2 > a1.agg1;
----

query RR rowsort
SELECT a2.f2, agg1
  FROM (
        SELECT AVG(f1)  AS agg1 FROM t1
       ) a1 ,
       t1 a2
 WHERE a2.f2 < a1.agg1;
----
0.000
3.900
1.000
3.900
1.000
3.900
2.000
3.900
2.000
3.900
3.000
3.900

query
SELECT  FROM (  SELECT  AVG ( f2  ) f2  FROM t2  )  JOIN (  SELECT a2 .f1  FROM t1  JOIN t1 a2  ON  TRUE  )  ON  TRUE  WHERE  TRUE  AND f1  = f2   ;
----

query B
SELECT a1 .f1  FROM (  SELECT  TRUE f1  , MAX ( f1  ) f2  FROM t2  ) a1  RIGHT  JOIN (  SELECT f1  FROM t2  )  ON f2  IN (  1  , f2  )   ;
----
true
true
true
true
true
true
true
true
true
true

query R
SELECT f1  FROM (  SELECT  2 f1  , MIN ( f2  ) f2  FROM t1  ) a1  RIGHT  JOIN (  SELECT f2  FROM t2  )  ON f1  = a1 .f2   ;
----
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL

# FilterCharacteristics and IndexedFilter

statement ok
CREATE TABLE big(a int not null, b int not null, c int not null, d int not null, e int not null, f int not null, g int not null, h int not null, i int not null, j int not null, k int not null, x int, y int, s string);

statement ok
CREATE INDEX big_idx_a on big(a);

statement ok
CREATE INDEX big_idx_b on big(b);

statement ok
CREATE INDEX big_idx_c on big(c);

statement ok
CREATE INDEX big_idx_d on big(d);

statement ok
CREATE INDEX big_idx_e on big(e);

statement ok
CREATE INDEX big_idx_f on big(f);

statement ok
CREATE INDEX big_idx_g on big(g);

statement ok
CREATE INDEX big_idx_h on big(h);

statement ok
CREATE INDEX big_idx_i on big(i);

statement ok
CREATE INDEX big_idx_j on big(j);

statement ok
CREATE INDEX big_idx_k on big(k);

statement ok
CREATE INDEX big_idx_y on big(y);

# In the last Delta path (%10):
# - From %9 to %5, there are decreasing FilterCharacteristics.
# - %2 to %4 are all in the any_filter category.
# - %0 and %1 don't have any filters.
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM big as t0, big as t1, big as t2, big as t3, big as t4, big as t5, big as t6, big as t7, big as t8, big as t9, big as t10
WHERE
t0.a = t1.b AND
t1.b = t2.c AND
t2.c = t3.d AND
t3.d = t4.e AND
t4.e = t5.f AND
t5.f = t6.g AND
t6.g = t7.h AND
t7.h = t8.i AND
t8.i = t9.j AND
t9.j = t10.k AND
t9.x = 71 AND
t8.s LIKE 'a%' AND
t7.x IS NULL AND
t6.x BETWEEN 3 AND 8 AND
t5.x > 5 AND
t4.s NOT LIKE 'b%' AND
t3.x != t3.y AND
(NOT (t2.x = t2.y))
;
----
Explained Query:
  Project (#0..=#14, #0, #16..=#29, #0, #31..=#44, #0, #46..=#59, #0, #61..=#74, #0, #76..=#89, #0, #91..=#104, #0, #106..=#119, #0, #121..=#134, #0, #136..=#149, #0, #151..=#153) // { arity: 154 }
    Filter (#109) IS NULL AND "a%" ~~(#125) AND (#137 = 71) AND (#95 <= 8) AND (#81 > 5) AND (#95 >= 3) AND NOT("b%" ~~(#69)) AND (#39 != #40) AND (#53 != #54) // { arity: 154 }
      Join on=(eq(#0, #15, #30, #45, #60, #75, #90, #105, #120, #135, #150)) type=delta // { arity: 154 }
        implementation
          %0:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %1:big[#1]KA » %10:big[#10]KA
          %1:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %10:big[#10]KA
          %2:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %3:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %4:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %5:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %6:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %7:big » %9:big[#9]KAef » %8:big[#8]KAlf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %8:big » %9:big[#9]KAef » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %9:big » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA » %10:big[#10]KA
          %10:big » %9:big[#9]KAef » %8:big[#8]KAlf » %7:big[#7]KAnf » %6:big[#6]KAiif » %5:big[#5]KAif » %2:big[#2]KAf » %3:big[#3]KAf » %4:big[#4]KAf » %0:big[#0]KA » %1:big[#1]KA
        ArrangeBy keys=[[#0]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#1]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#2]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#3]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#4]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#5]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#6]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#7]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#8]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#9]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#10]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }

Used Indexes:
  - materialize.public.big_idx_a
  - materialize.public.big_idx_b
  - materialize.public.big_idx_c
  - materialize.public.big_idx_d
  - materialize.public.big_idx_e
  - materialize.public.big_idx_f
  - materialize.public.big_idx_g
  - materialize.public.big_idx_h
  - materialize.public.big_idx_i
  - materialize.public.big_idx_j
  - materialize.public.big_idx_k

EOF

# IndexedFilter should
# - come before like (i.e., same category as literal_equality)
# - not prevent planning a Delta join
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM big as t0, big as t1, big as t2
WHERE
t0.a = t1.b AND
t1.b = t2.c AND
t1.y = 42 AND
t0.s LIKE 'a%'
;
----
Explained Query:
  Project (#0..=#14, #0, #16..=#27, #29, #30, #0, #32..=#42) // { arity: 42 }
    Filter "a%" ~~(#13) // { arity: 43 }
      Join on=(eq(#0, #15, #31)) type=delta // { arity: 43 }
        implementation
          %0:big » %1:big[#1]KAe » %2:big[#2]KA
          %1:big » %0:big[#0]KAlf » %2:big[#2]KA
          %2:big » %1:big[#1]KAe » %0:big[#0]KAlf
        ArrangeBy keys=[[#0]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[#1]] // { arity: 15 }
          ReadExistingIndex materialize.public.big lookup_value=(42)
        ArrangeBy keys=[[#2]] // { arity: 14 }
          Get materialize.public.big // { arity: 14 }

Used Indexes:
  - materialize.public.big_idx_a
  - materialize.public.big_idx_c
  - materialize.public.big_idx_y

EOF

# FilterCharacteristics from behind a Get. %2 should come at the first or second position in every Delta path,
# and %2 should have an "e", indicating the join ordering code's awareness of the equality filter.
# The magic that makes this work is as follows:
# - inline_mfp has to be true on the last RelationCSE call before JoinImplementation (i.e., in logical_cleanup_pass);
# - There shouldn't be a RelationCSE between the CanonicalizeMfp that is before JoinImplementation and JoinImplementation.
query T multiline
EXPLAIN WITH(arity, join_impls)
WITH t(x) AS (
  SELECT a
  FROM big
  WHERE a = 5
)
(
  SELECT b1.a
  FROM big as b1, big as b2, t
)
UNION ALL
(SELECT * FROM t);
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      CrossJoin type=delta // { arity: 1 }
        implementation
          %0:big » %2:l0[×]Ae » %1:big[×]A
          %1:big » %2:l0[×]Ae » %0:big[×]A
          %2:l0 » %0:big[×]A » %1:big[×]A
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get materialize.public.big // { arity: 14 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l0 // { arity: 15 }
      Project (#0) // { arity: 1 }
        Get l0 // { arity: 15 }
  With
    cte l0 =
      ReadExistingIndex materialize.public.big lookup_value=(5)

Used Indexes:
  - materialize.public.big_idx_a

EOF
