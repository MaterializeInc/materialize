# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

#
# Test Common subexpression elimination for Relations.
# PR https://github.com/MaterializeInc/materialize/pull/7715
#

simple conn=mz_system,user=mz_system
ALTER SYSTEM SET enable_with_mutually_recursive = true
----
COMPLETE 0

statement ok
CREATE TABLE t1 (f1 INTEGER, f2 INTEGER);

statement ok
CREATE INDEX i1 ON t1 (f1);

statement ok
CREATE TABLE t2 (f1 INTEGER, f2 INTEGER);

##
## Tests around the placement of CSEs in the top-level query itself
##

# no CSE detection here, no predicates in query
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2;
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×] » %1:l0[×]
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# Inner joins
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2, t1 AS a3;
----
Explained Query:
  Return // { arity: 6 }
    CrossJoin type=delta // { arity: 6 }
      implementation
        %0:l0 » %1:l0[×]A » %2:l0[×]A
        %1:l0 » %0:l0[×]A » %2:l0[×]A
        %2:l0 » %0:l0[×]A » %1:l0[×]A
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2 WHERE a1.f1 = 1 AND a2.f1 = 1;
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]e » %1:l0[×]e
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 , t1 AS a2, t1 AS a3 WHERE a1.f1 = 1 AND a2.f1 = 1 AND a3.f1 = 1;
----
Explained Query:
  Return // { arity: 6 }
    CrossJoin type=delta // { arity: 6 }
      implementation
        %0:l0 » %1:l0[×]Ae » %2:l0[×]Ae
        %1:l0 » %0:l0[×]Ae » %2:l0[×]Ae
        %2:l0 » %0:l0[×]Ae » %1:l0[×]Ae
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

#
# Outer join
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1) WHERE a1.f1 = 1 AND a2.f1 = 1;
----
Explained Query:
  Return // { arity: 3 }
    CrossJoin type=differential // { arity: 3 }
      implementation
        %0:l0[×]e » %1:l0[×]e
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Get l0 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#1) // { arity: 1 }
          Get l0 // { arity: 3 }
  With
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

#
# Subqueries
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1) AND f2 = (SELECT f1 FROM t1);
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #1) // { arity: 2 }
      Filter (#0) IS NOT NULL AND (#1) IS NOT NULL // { arity: 4 }
        Join on=(#0 = #2 AND #1 = #3) type=differential // { arity: 4 }
          implementation
            %0:t1[#0]KA » %1:l0[#0]K » %2:l0[#0]K
          ArrangeBy keys=[[#0]] // { arity: 2 }
            Get materialize.public.t1 // { arity: 2 }
          Get l0 // { arity: 1 }
          Get l0 // { arity: 1 }
  With
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#0) // { arity: 1 }
            Filter (#0) IS NOT NULL // { arity: 2 }
              Get materialize.public.t1 // { arity: 2 }
          Map (error("more than one record produced in subquery")) // { arity: 1 }
            Project () // { arity: 0 }
              Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                Reduce aggregates=[count(*)] // { arity: 1 }
                  Project () // { arity: 0 }
                    Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1 WHERE f1 = 1) AND f2 = (SELECT f1 FROM t1 WHERE f1 = 1);
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #1) // { arity: 2 }
      Filter (#0) IS NOT NULL AND (#1) IS NOT NULL // { arity: 4 }
        Join on=(#0 = #2 AND #1 = #3) type=differential // { arity: 4 }
          implementation
            %0:l0[#0]KA » %1:l2[#0]K » %2:l2[#0]K
          Get l0 // { arity: 2 }
          Get l2 // { arity: 1 }
          Get l2 // { arity: 1 }
  With
    cte l2 =
      ArrangeBy keys=[[#0]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l1 // { arity: 3 }
          Map (error("more than one record produced in subquery")) // { arity: 1 }
            Project () // { arity: 0 }
              Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                Reduce aggregates=[count(*)] // { arity: 1 }
                  Project () // { arity: 0 }
                    Get l1 // { arity: 3 }
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1) AND EXISTS (SELECT f1 FROM t1);
----
Explained Query:
  Project (#0, #1) // { arity: 2 }
    Filter (#0) IS NOT NULL // { arity: 3 }
      Join on=(#0 = #2) type=differential // { arity: 3 }
        implementation
          %0:t1[#0]KA » %1[#0]K
        ArrangeBy keys=[[#0]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[#0]] // { arity: 1 }
          Union // { arity: 1 }
            Project (#0) // { arity: 1 }
              Filter (#0) IS NOT NULL // { arity: 2 }
                Get materialize.public.t1 // { arity: 2 }
            Map (error("more than one record produced in subquery")) // { arity: 1 }
              Project () // { arity: 0 }
                Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                  Reduce aggregates=[count(*)] // { arity: 1 }
                    Project () // { arity: 0 }
                      Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1) OR f2 = (SELECT f1 FROM t1);
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #1) // { arity: 2 }
      Filter ((#0 = #2) OR (#1 = #3)) // { arity: 4 }
        CrossJoin type=delta // { arity: 4 }
          implementation
            %0:t1 » %1:l1[×]A » %2:l1[×]A
            %1:l1 » %0:t1[×]A » %2:l1[×]A
            %2:l1 » %0:t1[×]A » %1:l1[×]A
          ArrangeBy keys=[[]] // { arity: 2 }
            Get materialize.public.t1 // { arity: 2 }
          Get l1 // { arity: 1 }
          Get l1 // { arity: 1 }
  With
    cte l1 =
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Get l0 // { arity: 1 }
          Map (null) // { arity: 1 }
            Union // { arity: 0 }
              Negate // { arity: 0 }
                Distinct // { arity: 0 }
                  Project () // { arity: 0 }
                    Get l0 // { arity: 1 }
              Constant // { arity: 0 }
                - ()
    cte l0 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs in derived tables
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT *
FROM (SELECT * FROM t1 WHERE f1 = 1) AS a1
JOIN (SELECT * FROM t1 WHERE f1 = 1) AS a2
ON TRUE
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]e » %1:l0[×]e
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT *
FROM (SELECT * FROM t1 WHERE f1 = 1) AS a1
, (SELECT * FROM t1 WHERE f1 = 1) AS a2
WHERE a1.f2 = 2
AND a2.f2 = 2
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]ef » %1:l0[×]ef
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Filter (#1 = 2) // { arity: 3 }
            ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

# No CSE with only partially-overlapping predicates
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT *
FROM (SELECT * FROM t1 WHERE f1 = 1) AS a1
, (SELECT * FROM t1 WHERE f1 = 1) AS a2
WHERE a1.f2 = 2
AND a2.f2 = 3
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:l0[×]ef » %1:l0[×]ef
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Filter (#1 = 2) // { arity: 3 }
            Get l0 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          Filter (#1 = 3) // { arity: 3 }
            Get l0 // { arity: 3 }
  With
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs in UNION branches
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1;
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1 UNION SELECT * FROM t1 WHERE f1 = 1;
----
Explained Query:
  Return // { arity: 2 }
    Project (#1, #0) // { arity: 2 }
      Map (1) // { arity: 2 }
        Distinct group_by=[#0] // { arity: 1 }
          Union // { arity: 1 }
            Get l0 // { arity: 1 }
            Get l0 // { arity: 1 }
            Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#1) // { arity: 1 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs in the SELECT list
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT (SELECT f1 FROM t1 WHERE f1 = 1) , (SELECT f1 FROM t1 WHERE f1 = 1) FROM t1;
----
Explained Query:
  Return // { arity: 2 }
    Project (#0, #0) // { arity: 2 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:t1[×] » %1[×]
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Union // { arity: 1 }
            Get l1 // { arity: 1 }
            Map (null) // { arity: 1 }
              Union // { arity: 0 }
                Negate // { arity: 0 }
                  Distinct // { arity: 0 }
                    Project () // { arity: 0 }
                      Get l1 // { arity: 1 }
                Constant // { arity: 0 }
                  - ()
  With
    cte l1 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT MIN((SELECT f1 FROM t1 WHERE f1 = 1)), MAX((SELECT f1 FROM t1 WHERE f1 = 1)) FROM t1;
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l3 // { arity: 2 }
      Map (null, null) // { arity: 2 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l3 // { arity: 2 }
          Constant // { arity: 0 }
            - ()
  With
    cte l3 =
      Reduce aggregates=[min(#0), max(#1)] // { arity: 2 }
        CrossJoin type=delta // { arity: 2 }
          implementation
            %0:t1 » %1:l2[×]A » %2:l2[×]A
            %1:l2 » %0:t1[×]A » %2:l2[×]A
            %2:l2 » %0:t1[×]A » %1:l2[×]A
          ArrangeBy keys=[[]] // { arity: 0 }
            Project () // { arity: 0 }
              Get materialize.public.t1 // { arity: 2 }
          Get l2 // { arity: 1 }
          Get l2 // { arity: 1 }
    cte l2 =
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Get l1 // { arity: 1 }
          Map (null) // { arity: 1 }
            Union // { arity: 0 }
              Negate // { arity: 0 }
                Distinct // { arity: 0 }
                  Project () // { arity: 0 }
                    Get l1 // { arity: 1 }
              Constant // { arity: 0 }
                - ()
    cte l1 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs at two distinct positions within the query
#

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT (SELECT f1 FROM t1 WHERE f1 = 1) FROM t1 WHERE EXISTS (SELECT f1 FROM t1 WHERE f1 = 1);
----
Explained Query:
  Return // { arity: 1 }
    CrossJoin type=delta // { arity: 1 }
      implementation
        %0:t1 » %1[×]UA » %2[×]A
        %1 » %0:t1[×]A » %2[×]A
        %2 » %1[×]UA » %0:t1[×]A
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get materialize.public.t1 // { arity: 2 }
      ArrangeBy keys=[[]] // { arity: 0 }
        Distinct // { arity: 0 }
          Get l1 // { arity: 0 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Get l2 // { arity: 1 }
          Map (null) // { arity: 1 }
            Union // { arity: 0 }
              Negate // { arity: 0 }
                Distinct // { arity: 0 }
                  Project () // { arity: 0 }
                    Get l2 // { arity: 1 }
              Constant // { arity: 0 }
                - ()
  With
    cte l2 =
      Union // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Get l1 // { arity: 0 }
    cte l1 =
      Project () // { arity: 0 }
        Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT (SELECT f1 FROM t1 WHERE f1 = 1) FROM t1
UNION ALL
SELECT f1 FROM t1 WHERE f1 = 1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:t1[×] » %1[×]
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Union // { arity: 1 }
            Get l2 // { arity: 1 }
            Map (null) // { arity: 1 }
              Union // { arity: 0 }
                Negate // { arity: 0 }
                  Distinct // { arity: 0 }
                    Project () // { arity: 0 }
                      Get l2 // { arity: 1 }
                Constant // { arity: 0 }
                  - ()
      Get l1 // { arity: 1 }
  With
    cte l2 =
      Union // { arity: 1 }
        Get l1 // { arity: 1 }
        Map (error("more than one record produced in subquery")) // { arity: 1 }
          Project () // { arity: 0 }
            Filter (#0 > 1) // { arity: 1 }
              Reduce aggregates=[count(*)] // { arity: 1 }
                Project () // { arity: 0 }
                  Get l0 // { arity: 3 }
    cte l1 =
      Project (#0) // { arity: 1 }
        Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

##
## Tests around the contents of the CSE itself
##

#
# CSE containing a join
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 AS a1, t1 AS a2
UNION ALL
SELECT * FROM t1 AS a1, t1 AS a2
----
Explained Query:
  Return // { arity: 4 }
    Union // { arity: 4 }
      Get l1 // { arity: 4 }
      Get l1 // { arity: 4 }
  With
    cte l1 =
      CrossJoin type=differential // { arity: 4 }
        implementation
          %0:l0[×] » %1:l0[×]
        Get l0 // { arity: 2 }
        Get l0 // { arity: 2 }
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)
UNION ALL
SELECT * FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)
----
Explained Query:
  Return // { arity: 3 }
    Union // { arity: 3 }
      Get l2 // { arity: 3 }
      Get l1 // { arity: 3 }
      Get l2 // { arity: 3 }
      Get l1 // { arity: 3 }
  With
    cte l2 =
      Map (null) // { arity: 3 }
        Union // { arity: 2 }
          Negate // { arity: 2 }
            Project (#0, #1) // { arity: 2 }
              Join on=(#0 = #2) type=differential // { arity: 3 }
                implementation
                  %1[#0]UKA » %0:l0[#0]KA
                Get l0 // { arity: 2 }
                ArrangeBy keys=[[#0]] // { arity: 1 }
                  Distinct group_by=[#0] // { arity: 1 }
                    Project (#0) // { arity: 1 }
                      Get l1 // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }
    cte l1 =
      Project (#0, #1, #3) // { arity: 3 }
        Filter (#0) IS NOT NULL // { arity: 4 }
          Join on=(#0 = #2) type=differential // { arity: 4 }
            implementation
              %0:l0[#0]KA » %1:l0[#0]KA
            Get l0 // { arity: 2 }
            Get l0 // { arity: 2 }
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) WHERE f1 = 1
UNION ALL
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) WHERE f1 = 2
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l1[×]e » %1:l1[×]e
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l1 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l1 // { arity: 3 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l2[×]e » %1:l2[×]e
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l2 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l2 // { arity: 3 }
  With
    cte l2 =
      ReadExistingIndex materialize.public.t1 lookup_value=(2) // { arity: 3 }
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s1,
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s2
WHERE s1.f1 = 1 AND s2.f1 = 1
----
Explained Query:
  Return // { arity: 2 }
    CrossJoin type=delta // { arity: 2 }
      implementation
        %0:l1 » %1:l2[×]Ae » %2:l1[×]Ae » %3:l2[×]Ae
        %1:l2 » %0:l1[×]Ae » %2:l1[×]Ae » %3:l2[×]Ae
        %2:l1 » %0:l1[×]Ae » %1:l2[×]Ae » %3:l2[×]Ae
        %3:l2 » %0:l1[×]Ae » %1:l2[×]Ae » %2:l1[×]Ae
      Get l1 // { arity: 0 }
      Get l2 // { arity: 1 }
      Get l1 // { arity: 0 }
      Get l2 // { arity: 1 }
  With
    cte l2 =
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l0 // { arity: 3 }
    cte l1 =
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get l0 // { arity: 3 }
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s1,
(SELECT a2.f1 AS f1 FROM t1 AS a1 LEFT JOIN t1 AS a2 USING (f1)) AS s2
WHERE s1.f1 = 1 AND s2.f1 = 2
----
Explained Query:
  Return // { arity: 2 }
    CrossJoin type=delta // { arity: 2 }
      implementation
        %0:l1 » %1:l1[×]Ae » %2:l2[×]Ae » %3:l2[×]Ae
        %1:l1 » %0:l1[×]Ae » %2:l2[×]Ae » %3:l2[×]Ae
        %2:l2 » %0:l1[×]Ae » %1:l1[×]Ae » %3:l2[×]Ae
        %3:l2 » %0:l1[×]Ae » %1:l1[×]Ae » %2:l2[×]Ae
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get l1 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l1 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 0 }
        Project () // { arity: 0 }
          Get l2 // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get l2 // { arity: 3 }
  With
    cte l2 =
      ReadExistingIndex materialize.public.t1 lookup_value=(2) // { arity: 3 }
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a conjunction (AND)
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = 1 AND f2 = 2
UNION ALL
SELECT * FROM t1 WHERE f1 = 1 AND f2 = 2
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        Filter (#1 = 2) // { arity: 3 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a disjunction (OR)
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = 1 OR f1 = 2
UNION ALL
SELECT * FROM t1 WHERE f1 = 1 OR f1 = 2
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_values=[(1); (2)] // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a subquery
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1)
UNION ALL
SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1[×]UA » %0:t1[×]
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Distinct // { arity: 0 }
            Project () // { arity: 0 }
              ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1 WHERE f1 = 1)
UNION ALL
SELECT * FROM t1 WHERE f1 = (SELECT f1 FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l2 // { arity: 2 }
      Get l2 // { arity: 2 }
  With
    cte l2 =
      Project (#0, #1) // { arity: 2 }
        Filter (#0) IS NOT NULL // { arity: 3 }
          Join on=(#0 = #2) type=differential // { arity: 3 }
            implementation
              %0:l0[#0]KA » %1[#0]K
            Get l0 // { arity: 2 }
            ArrangeBy keys=[[#0]] // { arity: 1 }
              Union // { arity: 1 }
                Project (#0) // { arity: 1 }
                  Get l1 // { arity: 3 }
                Map (error("more than one record produced in subquery")) // { arity: 1 }
                  Project () // { arity: 0 }
                    Filter error("more than one record produced in subquery") AND (#0 > 1) // { arity: 1 }
                      Reduce aggregates=[count(*)] // { arity: 1 }
                        Project () // { arity: 0 }
                          Get l1 // { arity: 3 }
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSE containing a derived table
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1 + 1 FROM (SELECT f1 + 2 AS f1 FROM t1)
UNION ALL
SELECT f1 + 1 FROM (SELECT f1 + 2 AS f1 FROM t1)
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#2) // { arity: 1 }
        Map (((#0 + 2) + 1)) // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs containing an aggregate
#

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT MIN(f1) FROM t1
UNION ALL
SELECT MIN(f1) FROM t1;
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l1 // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l1 // { arity: 1 }
  With
    cte l1 =
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l0 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
    cte l0 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT DISTINCT f1 FROM t1
UNION ALL
SELECT DISTINCT f1 FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Distinct group_by=[#0] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1, COUNT(*) FROM t1 GROUP BY f1
UNION ALL
SELECT f1, COUNT(*) FROM t1 GROUP BY f1
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Reduce group_by=[#0] aggregates=[count(*)] // { arity: 2 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

#
# CSEs containing an expression / function

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1 + f1 + f1 + f1 FROM t1
UNION ALL
SELECT f1 + f1 + f1 + f1 FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#2) // { arity: 1 }
        Map ((((#0 + #0) + #0) + #0)) // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT ABS(f1) FROM t1
UNION ALL
SELECT ABS(f1) FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#2) // { arity: 1 }
        Map (abs(#0)) // { arity: 3 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

##
## Nested CSEs
##

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1)
UNION ALL
(SELECT * FROM t1 WHERE f1 = 1 UNION ALL SELECT * FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
UNION ALL
(SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Get l0 // { arity: 2 }
      Get l0 // { arity: 2 }
  With
    cte l0 =
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1[×]UA » %0:t1[×]
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Distinct // { arity: 0 }
            Project () // { arity: 0 }
              ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

##
## Deeper-placed CSEs (where a higher-level construct is not a CSE but a lower-level one is)
##

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT f1 FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
UNION ALL
(SELECT f2 FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Project (#0) // { arity: 1 }
        Get l0 // { arity: 2 }
      Project (#1) // { arity: 1 }
        Get l0 // { arity: 2 }
  With
    cte l0 =
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1[×]UA » %0:t1[×]
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        ArrangeBy keys=[[]] // { arity: 0 }
          Distinct // { arity: 0 }
            Project () // { arity: 0 }
              ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
(SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
UNION ALL
(SELECT * FROM t2 WHERE EXISTS (SELECT * FROM t1 WHERE f1 = 1))
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1:l0[×]UA » %0:t1[×]
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t1 // { arity: 2 }
        Get l0 // { arity: 0 }
      CrossJoin type=differential // { arity: 2 }
        implementation
          %1:l0[×]UA » %0:t2[×]
        ArrangeBy keys=[[]] // { arity: 2 }
          Get materialize.public.t2 // { arity: 2 }
        Get l0 // { arity: 0 }
  With
    cte l0 =
      ArrangeBy keys=[[]] // { arity: 0 }
        Distinct // { arity: 0 }
          Project () // { arity: 0 }
            ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM
(SELECT f1 FROM t2 UNION ALL SELECT f1 FROM t1 WHERE f1 = 1) ,
(SELECT f2 FROM t2 UNION ALL SELECT f1 FROM t1 WHERE f1 = 1)
----
Explained Query:
  Return // { arity: 2 }
    CrossJoin type=differential // { arity: 2 }
      implementation
        %0[×] » %1[×]
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get materialize.public.t2 // { arity: 2 }
          Get l0 // { arity: 1 }
      ArrangeBy keys=[[]] // { arity: 1 }
        Union // { arity: 1 }
          Project (#1) // { arity: 1 }
            Get materialize.public.t2 // { arity: 2 }
          Get l0 // { arity: 1 }
  With
    cte l0 =
      Project (#0) // { arity: 1 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

# Same predicate, different projections
query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT f1 FROM t1 WHERE f1 = 1
UNION ALL
SELECT f2 FROM t1 WHERE f1 = 1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Project (#0) // { arity: 1 }
        Get l0 // { arity: 3 }
      Project (#1) // { arity: 1 }
        Get l0 // { arity: 3 }
  With
    cte l0 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }

Used Indexes:
  - materialize.public.i1

EOF

##
## Negative cases - CSEs should not be identified where they do not exist
##

#
query T multiline
EXPLAIN WITH(arity, join_impls) SELECT * FROM t1 AS a1, t1 AS a2 WHERE a1.f1 = 1 AND a2.f1 = 2
----
Explained Query:
  Return // { arity: 4 }
    CrossJoin type=differential // { arity: 4 }
      implementation
        %0:t1[×]e » %1:t1[×]e
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }
      ArrangeBy keys=[[]] // { arity: 2 }
        Project (#0, #1) // { arity: 2 }
          ReadExistingIndex materialize.public.t1 lookup_value=(2) // { arity: 3 }
  With
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 JOIN t1 AS a2 USING (f1)) WHERE f1 = 1
UNION ALL
SELECT * FROM (SELECT a2.f1 AS f1 FROM t1 AS a1 JOIN t1 AS a2 USING (f1)) WHERE f1 = 2
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l1[×]e » %1:l1[×]e
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l1 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l1 // { arity: 3 }
      CrossJoin type=differential // { arity: 1 }
        implementation
          %0:l2[×]e » %1:l2[×]e
        ArrangeBy keys=[[]] // { arity: 0 }
          Project () // { arity: 0 }
            Get l2 // { arity: 3 }
        ArrangeBy keys=[[]] // { arity: 1 }
          Project (#0) // { arity: 1 }
            Get l2 // { arity: 3 }
  With
    cte l2 =
      ReadExistingIndex materialize.public.t1 lookup_value=(2) // { arity: 3 }
    cte l1 =
      ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT * FROM t1 WHERE f1 = 1
UNION ALL
SELECT * FROM t1 WHERE f1 = 2
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(1) // { arity: 3 }
      Project (#0, #1) // { arity: 2 }
        ReadExistingIndex materialize.public.t1 lookup_value=(2) // { arity: 3 }
  With
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT MIN(f1) FROM t1
UNION ALL
SELECT MAX(f1) FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l1 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l1 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
      Get l2 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l2 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
  With
    cte l2 =
      Reduce aggregates=[max(#0)] // { arity: 1 }
        Get l0 // { arity: 1 }
    cte l1 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Get l0 // { arity: 1 }
    cte l0 =
      Project (#0) // { arity: 1 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT MIN(f1) FROM t1
UNION ALL
SELECT MIN(f2) FROM t1
----
Explained Query:
  Return // { arity: 1 }
    Union // { arity: 1 }
      Get l0 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l0 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
      Get l1 // { arity: 1 }
      Map (null) // { arity: 1 }
        Union // { arity: 0 }
          Negate // { arity: 0 }
            Project () // { arity: 0 }
              Get l1 // { arity: 1 }
          Constant // { arity: 0 }
            - ()
  With
    cte l1 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Project (#1) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }
    cte l0 =
      Reduce aggregates=[min(#0)] // { arity: 1 }
        Project (#0) // { arity: 1 }
          Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF


# WITH MUTUALLY RECURSIVE support
# -------------------------------

# Basic support for recursive queries.
# Note that some opportunities arising from the appearance of the same
# sub-expression under different WMR bindings are not exploited at the moment:
# (1) a Filter (#1 > 7) over l0 appears twice.
# (2) l2 is equivalent to l5.
# (3) l1 is not equivalent (although structurally equal) to l4.
query T multiline
EXPLAIN WITH(arity, join_impls)
WITH MUTUALLY RECURSIVE
  c0(f1 INTEGER, f2 INTEGER) AS (
    SELECT f1, f2 FROM t1
    UNION ALL
    SELECT f1, f2 FROM t1
  ),
  c1(f1 INTEGER, f2 INTEGER) AS (
    SELECT * FROM c0 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c1 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c1 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c2 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c2 WHERE f2 > 7
  ),
  c2(f1 INTEGER, f2 INTEGER) AS (
    SELECT * FROM c0 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c1 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c1 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c2 WHERE f2 > 7
    UNION ALL
    SELECT * FROM c2 WHERE f2 > 7
  )
SELECT * FROM c0 WHERE f1 > 7
UNION ALL
SELECT * FROM c1 WHERE f1 > 7
UNION ALL
SELECT * FROM c2 WHERE f1 > 7
----
Explained Query:
  Return // { arity: 2 }
    Union // { arity: 2 }
      Filter (#0 > 7) // { arity: 2 }
        Get l0 // { arity: 2 }
      Filter (#0 > 7) // { arity: 2 }
        Get l3 // { arity: 2 }
      Filter (#0 > 7) // { arity: 2 }
        Get l6 // { arity: 2 }
  With Mutually Recursive
    cte l6 =
      Union // { arity: 2 }
        Filter (#1 > 7) // { arity: 2 }
          Get l0 // { arity: 2 }
        Get l4 // { arity: 2 }
        Get l4 // { arity: 2 }
        Get l5 // { arity: 2 }
        Get l5 // { arity: 2 }
    cte l5 =
      Filter (#1 > 7) // { arity: 2 }
        Get l6 // { arity: 2 }
    cte l4 =
      Filter (#1 > 7) // { arity: 2 }
        Get l3 // { arity: 2 }
    cte l3 =
      Union // { arity: 2 }
        Filter (#1 > 7) // { arity: 2 }
          Get l0 // { arity: 2 }
        Get l1 // { arity: 2 }
        Get l1 // { arity: 2 }
        Get l2 // { arity: 2 }
        Get l2 // { arity: 2 }
    cte l2 =
      Filter (#1 > 7) // { arity: 2 }
        Get l6 // { arity: 2 }
    cte l1 =
      Filter (#1 > 7) // { arity: 2 }
        Get l3 // { arity: 2 }
    cte l0 =
      Union // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }
        Get materialize.public.t1 // { arity: 2 }

Used Indexes:
  - materialize.public.i1

EOF

# Correlated WMR block.
query T multiline
EXPLAIN WITH(arity, join_impls)
SELECT bound, (
    WITH MUTUALLY RECURSIVE
        numbers (n int) as (
            VALUES (1)
            UNION ALL
            (
                WITH rebound AS (SELECT * FROM numbers)
                SELECT distinct t1.n + t2.n AS n
                FROM rebound AS t1, rebound AS t2
                WHERE t1.n <= bound AND t2.n <= bound
            )
        )
    SELECT count(*) FROM numbers
)
FROM (
    SELECT generate_series AS bound FROM generate_series(1, 10)
);
----
Explained Query:
  Return // { arity: 2 }
    Return // { arity: 2 }
      Project (#0, #3) // { arity: 2 }
        Join on=(eq(#0, #1, #2)) type=delta // { arity: 4 }
          implementation
            %0 » %1:l3[#0]UKA » %2[#0]KA
            %1:l3 » %0[#0]UKA » %2[#0]KA
            %2 » %0[#0]UKA » %1:l3[#0]UKA
          ArrangeBy keys=[[#0]] // { arity: 1 }
            Constant // { arity: 1 }
              - (1)
              - (2)
              - (3)
              - (4)
              - (5)
              - (6)
              - (7)
              - (8)
              - (9)
              - (10)
          Get l3 // { arity: 1 }
          ArrangeBy keys=[[#0]] // { arity: 2 }
            Union // { arity: 2 }
              Get l5 // { arity: 2 }
              Project (#0, #2) // { arity: 2 }
                Map (null) // { arity: 3 }
                  Join on=(#0 = #1) type=differential // { arity: 2 }
                    implementation
                      %1:l3[#0]UK » %0[#0]K
                    ArrangeBy keys=[[#0]] // { arity: 1 }
                      Union // { arity: 1 }
                        Negate // { arity: 1 }
                          Distinct group_by=[#0] // { arity: 1 }
                            Project (#0) // { arity: 1 }
                              Get l5 // { arity: 2 }
                        Constant // { arity: 1 }
                          - (1)
                          - (2)
                          - (3)
                          - (4)
                          - (5)
                          - (6)
                          - (7)
                          - (8)
                          - (9)
                          - (10)
                    Get l3 // { arity: 1 }
    With
      cte l5 =
        Union // { arity: 2 }
          Get l4 // { arity: 2 }
          Map (error("more than one record produced in subquery")) // { arity: 2 }
            Project (#0) // { arity: 1 }
              Filter (#1 > 1) // { arity: 2 }
                Reduce group_by=[#0] aggregates=[count(*)] // { arity: 2 }
                  Project (#0) // { arity: 1 }
                    Get l4 // { arity: 2 }
      cte l4 =
        Union // { arity: 2 }
          Get l2 // { arity: 2 }
          Project (#0, #2) // { arity: 2 }
            Map (0) // { arity: 3 }
              Join on=(#0 = #1) type=differential // { arity: 2 }
                implementation
                  %1:l3[#0]UK » %0[#0]K
                ArrangeBy keys=[[#0]] // { arity: 1 }
                  Union // { arity: 1 }
                    Negate // { arity: 1 }
                      Project (#0) // { arity: 1 }
                        Get l2 // { arity: 2 }
                    Constant // { arity: 1 }
                      - (1)
                      - (2)
                      - (3)
                      - (4)
                      - (5)
                      - (6)
                      - (7)
                      - (8)
                      - (9)
                      - (10)
                Get l3 // { arity: 1 }
      cte l3 =
        ArrangeBy keys=[[#0]] // { arity: 1 }
          Constant // { arity: 1 }
            - (1)
            - (2)
            - (3)
            - (4)
            - (5)
            - (6)
            - (7)
            - (8)
            - (9)
            - (10)
      cte l2 =
        Reduce group_by=[#0] aggregates=[count(*)] monotonic // { arity: 2 }
          Project (#0) // { arity: 1 }
            Get l1 // { arity: 2 }
  With Mutually Recursive
    cte l1 =
      Union // { arity: 2 }
        Distinct group_by=[#0, (#1 + #2)] monotonic // { arity: 2 }
          Project (#0, #1, #3) // { arity: 3 }
            Join on=(#0 = #2) type=differential // { arity: 4 }
              implementation
                %0:l0[#0]Kf » %1:l0[#0]Kf
              Get l0 // { arity: 2 }
              Get l0 // { arity: 2 }
        Constant // { arity: 2 }
          - (1, 1)
          - (2, 1)
          - (3, 1)
          - (4, 1)
          - (5, 1)
          - (6, 1)
          - (7, 1)
          - (8, 1)
          - (9, 1)
          - (10, 1)
    cte l0 =
      ArrangeBy keys=[[#0]] // { arity: 2 }
        Filter (#1 <= #0) // { arity: 2 }
          Get l1 // { arity: 2 }

EOF
