# Copyright 2019 Materialize, Inc. All rights reserved.
#
# This file is part of Materialize. Materialize may not be used or
# distributed without the express permission of Materialize, Inc.

statement ok
CREATE TABLE nation (
    n_nationkey  integer PRIMARY KEY,
    n_name       char(25) NOT NULL,
    n_regionkey  integer NOT NULL,
    n_comment    varchar(152)
)

statement ok
CREATE TABLE region  (
    r_regionkey  integer PRIMARY KEY,
    r_name       char(25) NOT NULL,
    r_comment    varchar(152)
)

statement ok
CREATE TABLE part (
    p_partkey     integer PRIMARY KEY,
    p_name        varchar(55) NOT NULL,
    p_mfgr        char(25) NOT NULL,
    p_brand       char(10) NOT NULL,
    p_type        varchar(25) NOT NULL,
    p_size        integer NOT NULL,
    p_container   char(10) NOT NULL,
    p_retailprice decimal(15,2) NOT NULL,
    p_comment     varchar(23) NOT NULL
)

statement ok
CREATE TABLE supplier (
    s_suppkey     integer PRIMARY KEY,
    s_name        char(25) NOT NULL,
    s_address     varchar(40) NOT NULL,
    s_nationkey   integer NOT NULL,
    s_phone       char(15) NOT NULL,
    s_acctbal     decimal(15,2) NOT NULL,
    s_comment     varchar(101) NOT NULL
)

statement ok
CREATE TABLE partsupp (
    ps_partkey     integer NOT NULL,
    ps_suppkey     integer NOT NULL,
    ps_availqty    integer NOT NULL,
    ps_supplycost  decimal(15,2) NOT NULL,
    ps_comment     varchar(199) NOT NULL,
    PRIMARY KEY (ps_partkey, ps_suppkey)
)

statement ok
CREATE TABLE customer (
    c_custkey     integer PRIMARY KEY,
    c_name        varchar(25) NOT NULL,
    c_address     varchar(40) NOT NULL,
    c_nationkey   integer NOT NULL,
    c_phone       char(15) NOT NULL,
    c_acctbal     decimal(15,2) NOT NULL,
    c_mktsegment  char(10) NOT NULL,
    c_comment     varchar(117) NOT NULL
)

statement ok
CREATE TABLE orders (
    o_orderkey       integer PRIMARY KEY,
    o_custkey        integer NOT NULL,
    o_orderstatus    char(1) NOT NULL,
    o_totalprice     decimal(15,2) NOT NULL,
    o_orderdate      date NOT NULL,
    o_orderpriority  char(15) NOT NULL,
    o_clerk          char(15) NOT NULL,
    o_shippriority   integer NOT NULL,
    o_comment        varchar(79) NOT NULL
)

statement ok
CREATE TABLE lineitem (
    l_orderkey       integer NOT NULL,
    l_partkey        integer NOT NULL,
    l_suppkey        integer NOT NULL,
    l_linenumber     integer NOT NULL,
    l_quantity       decimal(15,2) NOT NULL,
    l_extendedprice  decimal(15,2) NOT NULL,
    l_discount       decimal(15,2) NOT NULL,
    l_tax            decimal(15,2) NOT NULL,
    l_returnflag     char(1) NOT NULL,
    l_linestatus     char(1) NOT NULL,
    l_shipdate       date NOT NULL,
    l_commitdate     date NOT NULL,
    l_receiptdate    date NOT NULL,
    l_shipinstruct   char(25) NOT NULL,
    l_shipmode       char(10) NOT NULL,
    l_comment        varchar(44) NOT NULL,
    PRIMARY KEY (l_orderkey, l_linenumber)
)

query T multiline
-- Query 01
EXPLAIN PLAN FOR SELECT
	l_returnflag,
	l_linestatus,
	sum(l_quantity) as sum_qty,
	sum(l_extendedprice) as sum_base_price,
	sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,
	sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,
	avg(l_quantity) as avg_qty,
	avg(l_extendedprice) as avg_price,
	avg(l_discount) as avg_disc,
	count(*) as count_order
FROM
	lineitem
WHERE
	l_shipdate <= date '1998-12-01' -- - interval '60' day (fails with an error)
GROUP BY
	l_returnflag,
	l_linestatus
ORDER BY
	l_returnflag,
	l_linestatus
----
Project {
  outputs: [0 .. 5, 11 .. 13, 10],
  Map {
    scalars: [
      ((#2 * 10000000dec) / (i64todec #6 * 100dec)) * 10dec,
      ((#3 * 10000000dec) / (i64todec #7 * 100dec)) * 10dec,
      ((#8 * 10000000dec) / (i64todec #9 * 100dec)) * 10dec
    ],
    Reduce {
      group_key: [8, 9],
      aggregates: [
        sum(#4),
        sum(#5),
        sum(#5 * (100dec - #6)),
        sum((#5 * (100dec - #6)) * (100dec + #7)),
        countall(null),
        countall(null),
        sum(#6),
        countall(null),
        countall(null)
      ],
      Filter {
        predicates: [#10 <= 1998-12-01],
        Get { lineitem (u15) }
      }
    }
  }
}


query T multiline
-- Query 02
EXPLAIN PLAN FOR SELECT
    s_acctbal,
    s_name,
    n_name,
    p_partkey,
    p_mfgr,
    s_address,
    s_phone,
    s_comment
FROM
    part, supplier, partsupp, nation, region
WHERE
    p_partkey = ps_partkey
    AND s_suppkey = ps_suppkey
    AND p_size = cast(15 as smallint)
    AND p_type LIKE '%BRASS'
    AND s_nationkey = n_nationkey
    AND n_regionkey = r_regionkey
    AND r_name = 'EUROPE'
    AND ps_supplycost
        = (
                SELECT
                    min(ps_supplycost)
                FROM
                    partsupp, supplier, nation, region
                WHERE
                    p_partkey = ps_partkey
                    AND s_suppkey = ps_suppkey
                    AND s_nationkey = n_nationkey
                    AND n_regionkey = r_regionkey
                    AND r_name = 'EUROPE'
            )
ORDER BY
    s_acctbal DESC, n_name, s_name, p_partkey;
----
Let {
  l0 = Join {
    variables: [
      [(0, 0), (1, 0)],
      [(1, 1), (2, 0)],
      [(2, 3), (3, 0)],
      [(3, 2), (4, 0)]
    ],
    Filter {
      predicates: [#5 = 15, #4 ~ ^.*BRASS$],
      Get { part (u5) }
    },
    Get { partsupp (u9) },
    Get { supplier (u7) },
    Get { nation (u1) },
    Filter { predicates: [#1 = "EUROPE"], Get { region (u3) } }
  }
} in
Let { l3 = Distinct { group_key: [0], Get { l0 } } } in
Project {
  outputs: [19, 15, 22, 0, 2, 16, 18, 20],
  Join {
    variables: [[(0, 0), (1, 0)], [(0, 12), (1, 1)]],
    Get { l0 },
    Reduce {
      group_key: [0],
      aggregates: [min(#7)],
      Join {
        variables: [
          [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)],
          [(4, 1), (5, 0)],
          [(5, 3), (6, 0)],
          [(6, 2), (7, 0)]
        ],
        Get { l3 },
        Get { l3 },
        Get { l3 },
        Get { l3 },
        Get { partsupp (u9) },
        Get { supplier (u7) },
        Get { nation (u1) },
        Filter { predicates: [#1 = "EUROPE"], Get { region (u3) } }
      }
    }
  }
}


query T multiline
-- Query 03
EXPLAIN PLAN FOR SELECT
    l_orderkey,
    sum(l_extendedprice * (1 - l_discount)) as revenue,
    o_orderdate,
    o_shippriority
from
    customer,
    orders,
    lineitem
where
    c_mktsegment = 'BUILDING'
    and c_custkey = o_custkey
    and l_orderkey = o_orderkey
    and o_orderdate < date '1995-03-15'
    and l_shipdate > date '1995-03-15'
group by
    l_orderkey,
    o_orderdate,
    o_shippriority
order by
    revenue desc,
    o_orderdate;
----
Project {
  outputs: [0, 3, 1, 2],
  Reduce {
    group_key: [8, 12, 15],
    aggregates: [sum(#22 * (100dec - #23))],
    Join {
      variables: [[(0, 0), (1, 1)], [(1, 0), (2, 0)]],
      Filter {
        predicates: [#6 = "BUILDING"],
        Get { customer (u11) }
      },
      Filter { predicates: [#4 < 1995-03-15], Get { orders (u13) } },
      Filter {
        predicates: [#10 > 1995-03-15],
        Get { lineitem (u15) }
      }
    }
  }
}


query T multiline
-- Query 04
EXPLAIN PLAN FOR SELECT
    o_orderpriority,
    count(*) as order_count
from
    orders
where
    o_orderdate >= date '1993-07-01'
    and o_orderdate < date '1993-07-01' + interval '3' month
    and exists (
        select
            *
        from
            lineitem
        where
            l_orderkey = o_orderkey
            and l_commitdate < l_receiptdate
    )
group by
    o_orderpriority
order by
    o_orderpriority;
----
Let {
  l0 = Filter {
    predicates: [datetots #4 < 1993-10-01 00:00:00, #4 >= 1993-07-01],
    Get { orders (u13) }
  }
} in
Reduce {
  group_key: [5],
  aggregates: [countall(null)],
  Map {
    scalars: [true],
    Join {
      variables: [[(0, 0), (1, 0)]],
      Get { l0 },
      Distinct {
        group_key: [16],
        Join {
          variables: [[(0, 0), (1, 0)]],
          Filter { predicates: [#11 < #12], Get { lineitem (u15) } },
          Distinct { group_key: [0], Get { l0 } }
        }
      }
    }
  }
}


query T multiline
-- Query 05
EXPLAIN PLAN FOR SELECT
    n_name,
    sum(l_extendedprice * (1 - l_discount)) as revenue
from
    customer,
    orders,
    lineitem,
    supplier,
    nation,
    region
where
    c_custkey = o_custkey
    and l_orderkey = o_orderkey
    and l_suppkey = s_suppkey
    and c_nationkey = s_nationkey
    and s_nationkey = n_nationkey
    and n_regionkey = r_regionkey
    and r_name = 'ASIA'
    and o_orderdate >= date '1994-01-01'
    and o_orderdate < date '1995-01-01'
group by
    n_name
order by
    revenue desc;
----
Reduce {
  group_key: [9],
  aggregates: [sum(#27 * (100dec - #28))],
  Join {
    variables: [
      [(0, 0), (5, 1)],
      [(0, 3), (1, 0), (3, 3)],
      [(1, 2), (2, 0)],
      [(3, 0), (4, 2)],
      [(4, 0), (5, 0)]
    ],
    Get { customer (u11) },
    Get { nation (u1) },
    Filter { predicates: [#1 = "ASIA"], Get { region (u3) } },
    Get { supplier (u7) },
    Get { lineitem (u15) },
    Filter {
      predicates: [#4 < 1995-01-01, #4 >= 1994-01-01],
      Get { orders (u13) }
    }
  }
}


query T multiline
-- Query 06
EXPLAIN PLAN FOR SELECT
    sum(l_extendedprice * l_discount) as revenue
from
    lineitem
where
    l_quantity < 24
    and l_shipdate >= date '1994-01-01'
    and l_shipdate < date '1994-01-01' + interval '1' year
    and l_discount between 0.06 - 0.01 and 0.07
    ;
----
Let {
  l0 = Reduce {
    group_key: [],
    aggregates: [sum(#5 * #6)],
    Filter {
      predicates: [
        #4 < 2400dec,
        datetots #10 < 1995-01-01 00:00:00,
        #6 <= 7dec,
        #6 >= 5dec,
        #10 >= 1994-01-01
      ],
      Get { lineitem (u15) }
    }
  }
} in
Union {
  Get { l0 },
  Map {
    scalars: [null],
    Union {
      Project { outputs: [], Negate { Get { l0 } } },
      Constant [[]]
    }
  }
}


query T multiline
-- Query 07
EXPLAIN PLAN FOR SELECT
    supp_nation,
    cust_nation,
    l_year,
    sum(volume) as revenue
from
    (
        select
            n1.n_name as supp_nation,
            n2.n_name as cust_nation,
            extract(year from l_shipdate) as l_year,
            l_extendedprice * (1 - l_discount) as volume
        from
            supplier,
            lineitem,
            orders,
            customer,
            nation n1,
            nation n2
        where
            s_suppkey = l_suppkey
            and o_orderkey = l_orderkey
            and c_custkey = o_custkey
            and s_nationkey = n1.n_nationkey
            and c_nationkey = n2.n_nationkey
            and (
                (n1.n_name = 'FRANCE' and n2.n_name = 'GERMANY')
                or (n1.n_name = 'GERMANY' and n2.n_name = 'FRANCE')
            )
            and l_shipdate between date '1995-01-01' and date '1996-12-31'
    ) as shipping
group by
    supp_nation,
    cust_nation,
    l_year
order by
    supp_nation,
    cust_nation,
    l_year;
----
Reduce {
  group_key: [8, 45, 48],
  aggregates: [sum(#49)],
  Map {
    scalars: [tsextractyear datetots #21, #16 * (100dec - #17)],
    Filter {
      predicates: [
        ((#8 = "FRANCE") && (#45 = "GERMANY"))
        ||
        ((#8 = "GERMANY") && (#45 = "FRANCE"))
      ],
      Join {
        variables: [
          [(0, 0), (2, 2)],
          [(0, 3), (1, 0)],
          [(2, 0), (3, 0)],
          [(3, 1), (4, 0)],
          [(4, 3), (5, 0)]
        ],
        Get { supplier (u7) },
        Get { nation (u1) },
        Filter {
          predicates: [#10 <= 1996-12-31, #10 >= 1995-01-01],
          Get { lineitem (u15) }
        },
        Get { orders (u13) },
        Get { customer (u11) },
        Get { nation (u1) }
      }
    }
  }
}


query T multiline
-- Query 08
EXPLAIN PLAN FOR SELECT
    o_year,
    sum(case
        when nation = 'BRAZIL' then volume
        else 0
    end) / sum(volume) as mkt_share
from
    (
        select
            extract(year from o_orderdate) as o_year,
            l_extendedprice * (1 - l_discount) as volume,
            n2.n_name as nation
        from
            part,
            supplier,
            lineitem,
            orders,
            customer,
            nation n1,
            nation n2,
            region
        where
            p_partkey = l_partkey
            and s_suppkey = l_suppkey
            and l_orderkey = o_orderkey
            and o_custkey = c_custkey
            and c_nationkey = n1.n_nationkey
            and n1.n_regionkey = r_regionkey
            and r_name = 'AMERICA'
            and s_nationkey = n2.n_nationkey
            and o_orderdate between date '1995-01-01' and date '1996-12-31'
            and p_type = 'ECONOMY ANODIZED STEEL'
    ) as all_nations
group by
    o_year
order by
    o_year;
----
Project {
  outputs: [0, 3],
  Map {
    scalars: [((#1 * 10000000dec) / #2) * 1000dec],
    Reduce {
      group_key: [60],
      aggregates: [
        sum(if #57 = "BRAZIL" then #61 else 0dec),
        sum(#61)
      ],
      Map {
        scalars: [tsextractyear datetots #29, #14 * (100dec - #15)],
        Join {
          variables: [
            [(0, 0), (1, 1)],
            [(1, 0), (2, 0)],
            [(1, 2), (6, 0)],
            [(2, 1), (3, 0)],
            [(3, 3), (4, 0)],
            [(4, 2), (5, 0)],
            [(6, 3), (7, 0)]
          ],
          Filter {
            predicates: [#4 = "ECONOMY ANODIZED STEEL"],
            Get { part (u5) }
          },
          Get { lineitem (u15) },
          Filter {
            predicates: [#4 <= 1996-12-31, #4 >= 1995-01-01],
            Get { orders (u13) }
          },
          Get { customer (u11) },
          Get { nation (u1) },
          Filter {
            predicates: [#1 = "AMERICA"],
            Get { region (u3) }
          },
          Get { supplier (u7) },
          Get { nation (u1) }
        }
      }
    }
  }
}


query T multiline
-- Query 09
EXPLAIN PLAN FOR SELECT
    nation,
    o_year,
    sum(amount) as sum_profit
from
    (
        select
            n_name as nation,
            extract(year from o_orderdate) as o_year,
            l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount
        from
            part,
            supplier,
            lineitem,
            partsupp,
            orders,
            nation
        where
            s_suppkey = l_suppkey
            and ps_suppkey = l_suppkey
            and ps_partkey = l_partkey
            and p_partkey = l_partkey
            and o_orderkey = l_orderkey
            and s_nationkey = n_nationkey
            and p_name like 'green'
    ) as profit
group by
    nation,
    o_year
order by
    nation,
    o_year desc;
----
Reduce {
  group_key: [47, 50],
  aggregates: [sum(#51)],
  Map {
    scalars: [
      tsextractyear datetots #34,
      (#19 * (100dec - #20)) - (#12 * #18)
    ],
    Join {
      variables: [
        [(0, 0), (1, 0), (2, 1)],
        [(1, 1), (2, 2), (4, 0)],
        [(2, 0), (3, 0)],
        [(4, 3), (5, 0)]
      ],
      Filter { predicates: [#1 ~ ^green$], Get { part (u5) } },
      Get { partsupp (u9) },
      Get { lineitem (u15) },
      Get { orders (u13) },
      Get { supplier (u7) },
      Get { nation (u1) }
    }
  }
}


query T multiline
-- Query 10
EXPLAIN PLAN FOR SELECT
    c_custkey,
    c_name,
    sum(l_extendedprice * (1 - l_discount)) as revenue,
    c_acctbal,
    n_name,
    c_address,
    c_phone,
    c_comment
from
    customer,
    orders,
    lineitem,
    nation
where
    c_custkey = o_custkey
    and l_orderkey = o_orderkey
    and o_orderdate >= date '1993-10-01'
    and o_orderdate < date '1994-01-01'
    and o_orderdate < date '1993-10-01' + interval '3' month
    and l_returnflag = 'R'
    and c_nationkey = n_nationkey
group by
    c_custkey,
    c_name,
    c_acctbal,
    c_phone,
    n_name,
    c_address,
    c_comment
order by
    revenue desc;
----
Project {
  outputs: [0, 1, 7, 2, 4, 5, 3, 6],
  Reduce {
    group_key: [0, 1, 5, 4, 9, 2, 7],
    aggregates: [sum(#26 * (100dec - #27))],
    Join {
      variables: [
        [(0, 0), (2, 1)],
        [(0, 3), (1, 0)],
        [(2, 0), (3, 0)]
      ],
      Get { customer (u11) },
      Get { nation (u1) },
      Filter {
        predicates: [
          #4 < 1994-01-01,
          datetots #4 < 1994-01-01 00:00:00,
          #4 >= 1993-10-01
        ],
        Get { orders (u13) }
      },
      Filter { predicates: [#8 = "R"], Get { lineitem (u15) } }
    }
  }
}


query T multiline
-- Query 11
EXPLAIN PLAN FOR SELECT
    ps_partkey,
    sum(ps_supplycost * ps_availqty) as value
from
    partsupp,
    supplier,
    nation
where
    ps_suppkey = s_suppkey
    and s_nationkey = n_nationkey
    and n_name = 'GERMANY'
group by
    ps_partkey having
        sum(ps_supplycost * ps_availqty) > (
            select
                sum(ps_supplycost * ps_availqty) * 0.0001
            from
                partsupp,
                supplier,
                nation
            where
                ps_suppkey = s_suppkey
                and s_nationkey = n_nationkey
                and n_name = 'GERMANY'
        )
order by
    value desc;
----
Let {
  l0 = Join {
    variables: [[(0, 1), (1, 0)], [(1, 3), (2, 0)]],
    Get { partsupp (u9) },
    Get { supplier (u7) },
    Filter { predicates: [#1 = "GERMANY"], Get { nation (u1) } }
  }
} in
Project {
  outputs: [0, 1],
  Filter {
    predicates: [(#1 * 10000dec) > #3],
    Join {
      variables: [],
      Reduce {
        group_key: [0],
        aggregates: [sum(#3 * (i64todec #2 * 100dec))],
        Get { l0 }
      },
      Map {
        scalars: [#0 * 1dec],
        Reduce {
          group_key: [],
          aggregates: [sum(#3 * (i64todec #2 * 100dec))],
          Get { l0 }
        }
      }
    }
  }
}


query T multiline
-- Query 12
EXPLAIN PLAN FOR SELECT
    l_shipmode,
    sum(case
        when o_orderpriority = '1-URGENT'
            or o_orderpriority = '2-HIGH'
            then 1
        else 0
    end) as high_line_count,
    sum(case
        when o_orderpriority <> '1-URGENT'
            and o_orderpriority <> '2-HIGH'
            then 1
        else 0
    end) as low_line_count
from
    orders,
    lineitem
where
    o_orderkey = l_orderkey
    and l_shipmode in ('MAIL', 'SHIP')
    and l_commitdate < l_receiptdate
    and l_shipdate < l_commitdate
    and l_receiptdate >= date '1994-01-01'
    and l_receiptdate < date '1994-01-01' + interval '1' year
group by
    l_shipmode
order by
    l_shipmode;
----
Reduce {
  group_key: [23],
  aggregates: [
    sum(if (#5 = "1-URGENT") || (#5 = "2-HIGH") then 1 else 0),
    sum(if (#5 != "1-URGENT") && (#5 != "2-HIGH") then 1 else 0)
  ],
  Join {
    variables: [[(0, 0), (1, 0)]],
    Get { orders (u13) },
    Filter {
      predicates: [
        (#14 = "MAIL") || (#14 = "SHIP"),
        #10 < #11,
        #11 < #12,
        datetots #12 < 1995-01-01 00:00:00,
        #12 >= 1994-01-01
      ],
      Get { lineitem (u15) }
    }
  }
}


query T multiline
-- Query 13
EXPLAIN PLAN FOR SELECT
    c_count,
    count(*) as custdist
from
    (
        select
            c_custkey,
            count(o_orderkey) c_count -- workaround for no column aliases
        from
            customer left outer join orders on
                c_custkey = o_custkey
                and o_comment not like '%special%requests%'
        group by
            c_custkey
    ) as c_orders -- (c_custkey, c_count) -- no column aliases yet
group by
    c_count
order by
    custdist desc,
    c_count desc;
----
Let {
  l0 = Join {
    variables: [[(0, 0), (1, 1)]],
    Get { customer (u11) },
    Filter {
      predicates: [!(#8 ~ ^.*special.*requests.*$)],
      Get { orders (u13) }
    }
  }
} in
Reduce {
  group_key: [1],
  aggregates: [countall(null)],
  Reduce {
    group_key: [0],
    aggregates: [count(#8)],
    Union {
      Project { outputs: [0 .. 8, 0, 10 .. 16], Get { l0 } },
      Map {
        scalars: [
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null,
          null
        ],
        Union {
          Negate { Distinct { group_key: [0 .. 7], Get { l0 } } },
          Get { customer (u11) }
        }
      }
    }
  }
}


query T multiline
-- Query 14
EXPLAIN PLAN FOR SELECT
    100.00 * sum(case
        when p_type like 'PROMO%'
            then l_extendedprice * (1 - l_discount)
        else 0
    end) / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
from
    lineitem,
    part
where
    l_partkey = p_partkey
    and l_shipdate >= date '1996-01-01'
    and l_shipdate < date '1996-01-01' + interval '1' month
----
Let {
  l0 = Reduce {
    group_key: [],
    aggregates: [
      sum(if #20 ~ ^PROMO.*$ then #5 * (100dec - #6) else 0dec),
      sum(#5 * (100dec - #6))
    ],
    Join {
      variables: [[(0, 1), (1, 0)]],
      Filter {
        predicates: [
          datetots #10 < 1996-02-01 00:00:00,
          #10 >= 1996-01-01
        ],
        Get { lineitem (u15) }
      },
      Get { part (u5) }
    }
  }
} in
Project {
  outputs: [2],
  Map {
    scalars: [(((10000dec * #0) * 10000000dec) / #1) * 1000dec],
    Union {
      Get { l0 },
      Map {
        scalars: [null, null],
        Union {
          Project { outputs: [], Negate { Get { l0 } } },
          Constant [[]]
        }
      }
    }
  }
}


statement ok
create view revenue (supplier_no, total_revenue) as
    select
        l_suppkey,
        sum(l_extendedprice * (1 - l_discount))
    from
        lineitem
    where
        l_shipdate >= date '1996-01-01'
        and l_shipdate < date '1996-04-01'
        and l_shipdate < date '1996-01-01' + interval '3' month
    group by
        l_suppkey;

query T multiline
-- Query 15
EXPLAIN PLAN FOR SELECT
    s_suppkey,
    s_name,
    s_address,
    s_phone,
    total_revenue
from
    supplier,
    revenue
where
    s_suppkey = supplier_no
    and total_revenue = (
        select
            max(total_revenue)
        from
            revenue
    )
order by
    s_suppkey;
----
Project {
  outputs: [0 .. 2, 4, 8],
  Join {
    variables: [[(0, 0), (1, 0)], [(1, 1), (2, 0)]],
    Get { supplier (u7) },
    Filter { predicates: [!isnull #1], Get { revenue (u17) } },
    Filter {
      predicates: [!isnull #0],
      Reduce {
        group_key: [],
        aggregates: [max(#1)],
        Get { revenue (u17) }
      }
    }
  }
}

statement ok
drop view revenue;


query T multiline
-- Query 16
EXPLAIN PLAN FOR SELECT
    p_brand,
    p_type,
    p_size,
    count(distinct ps_suppkey) as supplier_cnt
from
    partsupp,
    part
where
    p_partkey = ps_partkey
    and p_brand <> 'Brand#45'
    and p_type not like 'MEDIUM POLISHED%'
    and p_size in (49, 14, 23, 45, 19, 3, 36, 9)
    and ps_suppkey not in (
        select
            s_suppkey
        from
            supplier
        where
            s_comment like '%Customer%Complaints%'
    )
group by
    p_brand,
    p_type,
    p_size
order by
    supplier_cnt desc,
    p_brand,
    p_type,
    p_size;
----
Let {
  l0 = Join {
    variables: [[(0, 0), (1, 0)]],
    Get { partsupp (u9) },
    Filter {
      predicates: [
        !(#4 ~ ^MEDIUM POLISHED.*$),
        (
          (
            (
              ((((#5 = 49) || (#5 = 14)) || (#5 = 23)) || (#5 = 45))
              ||
              (#5 = 19)
            )
            ||
            (#5 = 3)
          )
          ||
          (#5 = 36)
        )
        ||
        (#5 = 9),
        #3 != "Brand#45"
      ],
      Get { part (u5) }
    }
  }
} in
Let { l3 = Distinct { group_key: [1], Get { l0 } } } in
Let {
  l2 = Reduce {
    group_key: [0],
    aggregates: [all(#0 != #1)],
    Join {
      variables: [],
      Get { l3 },
      Filter {
        predicates: [#6 ~ ^.*Customer.*Complaints.*$],
        Get { supplier (u7) }
      }
    }
  }
} in
Reduce {
  group_key: [8 .. 10],
  aggregates: [count(distinct #1)],
  Join {
    variables: [[(0, 1), (1, 0)]],
    Get { l0 },
    Union {
      Filter { predicates: [#1], Get { l2 } },
      Map {
        scalars: [true],
        Union {
          Project { outputs: [0], Negate { Get { l2 } } },
          Get { l3 }
        }
      }
    }
  }
}


query T multiline
-- Query 17
EXPLAIN PLAN FOR SELECT
  sum(l_extendedprice) / 7.0 as avg_yearly
from
  lineitem,
  part
where
  p_partkey = l_partkey
  and p_brand = 'Brand#23'
  and p_container = 'MED BOX'
  and l_quantity < (
    select
      0.2 * avg(l_quantity)
    from
      lineitem
    where
      l_partkey = p_partkey
  );
----
Let {
  l1 = Join {
    variables: [[(0, 1), (1, 0)]],
    Get { lineitem (u15) },
    Filter {
      predicates: [#3 = "Brand#23", #6 = "MED BOX"],
      Get { part (u5) }
    }
  }
} in
Let {
  l0 = Reduce {
    group_key: [],
    aggregates: [sum(#5)],
    Filter {
      predicates: [(#4 * 10000000dec) < #28],
      Join {
        variables: [[(0, 1), (1, 0)]],
        Get { l1 },
        Map {
          scalars: [
            2dec
            *
            (((#1 * 10000000dec) / (i64todec #2 * 100dec)) * 10dec)
          ],
          Reduce {
            group_key: [16],
            aggregates: [sum(#4), countall(null)],
            Join {
              variables: [[(0, 1), (1, 0)]],
              Get { lineitem (u15) },
              Distinct { group_key: [1], Get { l1 } }
            }
          }
        }
      }
    }
  }
} in
Project {
  outputs: [1],
  Map {
    scalars: [(#0 * 10000000dec) / 70dec],
    Union {
      Get { l0 },
      Map {
        scalars: [null],
        Union {
          Project { outputs: [], Negate { Get { l0 } } },
          Constant [[]]
        }
      }
    }
  }
}


query T multiline
-- Query 18
EXPLAIN PLAN FOR SELECT
    c_name,
    c_custkey,
    o_orderkey,
    o_orderdate,
    o_totalprice,
    sum(l_quantity)
from
    customer,
    orders,
    lineitem
where
    o_orderkey in (
        select
            l_orderkey
        from
            lineitem
        group by
            l_orderkey having
                sum(l_quantity) > 300
    )
    and c_custkey = o_custkey
    and o_orderkey = l_orderkey
group by
    c_name,
    c_custkey,
    o_orderkey,
    o_orderdate,
    o_totalprice
order by
    o_totalprice desc,
    o_orderdate;
----
Let {
  l0 = Join {
    variables: [[(0, 0), (1, 1)], [(1, 0), (2, 0)]],
    Get { customer (u11) },
    Get { orders (u13) },
    Get { lineitem (u15) }
  }
} in
Reduce {
  group_key: [1, 0, 8, 12, 11],
  aggregates: [sum(#21)],
  Join {
    variables: [[(0, 8), (1, 0)]],
    Get { l0 },
    Reduce {
      group_key: [0],
      aggregates: [any(true)],
      Filter {
        predicates: [#2 > 30000dec],
        Reduce {
          group_key: [16, 16],
          aggregates: [sum(#4)],
          Join {
            variables: [[(0, 0), (1, 0)]],
            Get { lineitem (u15) },
            Distinct { group_key: [8], Get { l0 } }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 19
EXPLAIN PLAN FOR SELECT
    sum(l_extendedprice* (1 - l_discount)) as revenue
from
    lineitem,
    part
where
    (
        p_partkey = l_partkey
        and p_brand = 'Brand#12'
        and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
        and l_quantity >= cast(1 as smallint) and l_quantity <= cast(1 + 10 as smallint)
        and p_size between cast(1 as smallint) and cast(5 as smallint)
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
    )
    or
    (
        p_partkey = l_partkey
        and p_brand = 'Brand#23'
        and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
        and l_quantity >= cast(10 as smallint) and l_quantity <= cast(10 + 10 as smallint)
        and p_size between cast(1 as smallint) and cast(10 as smallint)
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
    )
    or
    (
        p_partkey = l_partkey
        and p_brand = 'Brand#34'
        and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
        and l_quantity >= cast(20 as smallint) and l_quantity <= cast(20 + 10 as smallint)
        and p_size between cast(1 as smallint) and cast(15 as smallint)
        and l_shipmode in ('AIR', 'AIR REG')
        and l_shipinstruct = 'DELIVER IN PERSON'
    );
----
Let {
  l0 = Reduce {
    group_key: [],
    aggregates: [sum(#5 * (100dec - #6))],
    Filter {
      predicates: [
        (
          (
            (
              (
                (
                  (#19 = "Brand#12")
                  &&
                  (
                    (
                      ((#22 = "SM CASE") || (#22 = "SM BOX"))
                      ||
                      (#22 = "SM PACK")
                    )
                    ||
                    (#22 = "SM PKG")
                  )
                )
                &&
                (#4 >= 100dec)
              )
              &&
              (#4 <= 1100dec)
            )
            &&
            (#21 <= 5)
          )
          ||
          (
            (
              (
                (
                  (#19 = "Brand#23")
                  &&
                  (
                    (
                      ((#22 = "MED BAG") || (#22 = "MED BOX"))
                      ||
                      (#22 = "MED PKG")
                    )
                    ||
                    (#22 = "MED PACK")
                  )
                )
                &&
                (#4 >= 1000dec)
              )
              &&
              (#4 <= 2000dec)
            )
            &&
            (#21 <= 10)
          )
        )
        ||
        (
          (
            (
              (
                (#19 = "Brand#34")
                &&
                (
                  (
                    ((#22 = "LG CASE") || (#22 = "LG BOX"))
                    ||
                    (#22 = "LG PACK")
                  )
                  ||
                  (#22 = "LG PKG")
                )
              )
              &&
              (#4 >= 2000dec)
            )
            &&
            (#4 <= 3000dec)
          )
          &&
          (#21 <= 15)
        )
      ],
      Join {
        variables: [[(0, 1), (1, 0)]],
        Filter {
          predicates: [
            (#14 = "AIR") || (#14 = "AIR REG"),
            #13 = "DELIVER IN PERSON"
          ],
          Get { lineitem (u15) }
        },
        Filter { predicates: [#5 >= 1], Get { part (u5) } }
      }
    }
  }
} in
Union {
  Get { l0 },
  Map {
    scalars: [null],
    Union {
      Project { outputs: [], Negate { Get { l0 } } },
      Constant [[]]
    }
  }
}


query T multiline
-- Query 20
EXPLAIN PLAN FOR SELECT
    s_name,
    s_address
from
    supplier,
    nation
where
    s_suppkey in (
        select
            ps_suppkey
        from
            partsupp
        where
            ps_partkey in (
                select
                    p_partkey
                from
                    part
                where
                    p_name like 'forest%'
            )
            and ps_availqty > (
                select
                    0.5 * sum(l_quantity)
                from
                    lineitem
                where
                    l_partkey = ps_partkey
                    and l_suppkey = ps_suppkey
                    and l_shipdate >= date '1995-01-01'
                    and l_shipdate < date '1995-01-01' + interval '1' year
            )
    )
    and s_nationkey = n_nationkey
    and n_name = 'CANADA'
order by
    s_name;
----
Let {
  l0 = Join {
    variables: [[(0, 3), (1, 0)]],
    Get { supplier (u7) },
    Filter { predicates: [#1 = "CANADA"], Get { nation (u1) } }
  }
} in
Let {
  l4 = Join {
    variables: [],
    Distinct { group_key: [0], Get { l0 } },
    Get { partsupp (u9) }
  }
} in
Let {
  l3 = Join {
    variables: [[(0, 1), (1, 0)]],
    Get { l4 },
    Reduce {
      group_key: [9],
      aggregates: [any(true)],
      Join {
        variables: [[(0, 0), (1, 0)]],
        Filter { predicates: [#1 ~ ^forest.*$], Get { part (u5) } },
        Distinct { group_key: [1], Get { l4 } }
      }
    }
  }
} in
Project {
  outputs: [1, 2],
  Join {
    variables: [[(0, 0), (1, 0)]],
    Get { l0 },
    Reduce {
      group_key: [0],
      aggregates: [any(true)],
      Filter {
        predicates: [(i64todec #3 * 1000dec) > #11],
        Join {
          variables: [[(0, 1), (1, 0)], [(0, 2), (1, 1)]],
          Filter { predicates: [#0 = #2], Get { l3 } },
          Map {
            scalars: [5dec * #2],
            Reduce {
              group_key: [16, 17],
              aggregates: [sum(#4)],
              Join {
                variables: [[(0, 1), (1, 0)], [(0, 2), (1, 1)]],
                Filter {
                  predicates: [
                    datetots #10 < 1996-01-01 00:00:00,
                    #10 >= 1995-01-01
                  ],
                  Get { lineitem (u15) }
                },
                Distinct { group_key: [1, 2], Get { l3 } }
              }
            }
          }
        }
      }
    }
  }
}


query T multiline
-- Query 21
EXPLAIN PLAN FOR SELECT
    s_name,
    count(*) as numwait
from
    supplier,
    lineitem l1,
    orders,
    nation
where
    s_suppkey = l1.l_suppkey
    and o_orderkey = l1.l_orderkey
    and o_orderstatus = 'F'
    and l1.l_receiptdate > l1.l_commitdate
    and exists (
        select
            *
        from
            lineitem l2
        where
            l2.l_orderkey = l1.l_orderkey
            and l2.l_suppkey <> l1.l_suppkey
    )
    and not exists (
        select
            *
        from
            lineitem l3
        where
            l3.l_orderkey = l1.l_orderkey
            and l3.l_suppkey <> l1.l_suppkey
            and l3.l_receiptdate > l3.l_commitdate
    )
    and s_nationkey = n_nationkey
    and n_name = 'SAUDI ARABIA'
group by
    s_name
order by
    numwait desc,
    s_name;
----
Let {
  l1 = Join {
    variables: [[(0, 0), (2, 2)], [(0, 3), (1, 0)], [(2, 0), (3, 0)]],
    Get { supplier (u7) },
    Filter { predicates: [#1 = "SAUDI ARABIA"], Get { nation (u1) } },
    Filter { predicates: [#12 > #11], Get { lineitem (u15) } },
    Filter { predicates: [#2 = "F"], Get { orders (u13) } }
  }
} in
Let {
  l0 = Map {
    scalars: [true],
    Join {
      variables: [[(0, 11), (1, 0)], [(0, 0), (1, 1)]],
      Get { l1 },
      Distinct {
        group_key: [0, 1],
        Filter {
          predicates: [#4 != #1],
          Join {
            variables: [[(0, 0), (1, 0)]],
            Distinct { group_key: [11, 0], Get { l1 } },
            Get { lineitem (u15) }
          }
        }
      }
    }
  }
} in
Let { l5 = Distinct { group_key: [11, 0], Get { l0 } } } in
Let {
  l4 = Map {
    scalars: [true],
    Distinct {
      group_key: [0, 1],
      Filter {
        predicates: [#4 != #1],
        Join {
          variables: [[(0, 0), (1, 0)]],
          Get { l5 },
          Filter { predicates: [#12 > #11], Get { lineitem (u15) } }
        }
      }
    }
  }
} in
Reduce {
  group_key: [1],
  aggregates: [countall(null)],
  Join {
    variables: [[(0, 11), (1, 0)], [(0, 0), (1, 1)]],
    Get { l0 },
    Union {
      Filter { predicates: [!#2], Get { l4 } },
      Map {
        scalars: [false],
        Union {
          Project { outputs: [0, 1], Negate { Get { l4 } } },
          Get { l5 }
        }
      }
    }
  }
}


query T multiline
-- Query 22
EXPLAIN PLAN FOR SELECT
    cntrycode,
    count(*) AS numcust,
    sum(c_acctbal) AS totacctbal
FROM
    (
        SELECT
            substring(c_phone, 1, 2) AS cntrycode, c_acctbal
        FROM
            customer
        WHERE
            substring(c_phone, 1, 2)
            IN (':1', ':2', ':3', ':4', ':5', ':6', ':7')
            AND c_acctbal
                > (
                        SELECT
                            avg(c_acctbal)
                        FROM
                            customer
                        WHERE
                            c_acctbal > 0.00
                            AND substring(c_phone, 1, 2)
                                IN (
                                        '13',
                                        '31',
                                        '23',
                                        '29',
                                        '30',
                                        '18',
                                        '17'
                                    )
                    )
            AND NOT
                    EXISTS(
                        SELECT
                            *
                        FROM
                            orders
                        WHERE
                            o_custkey = c_custkey
                    )
    )
        AS custsale
GROUP BY
    cntrycode
ORDER BY
    cntrycode;
----
Let {
  l0 = Filter {
    predicates: [(#5 * 1000000dec) > #10],
    Join {
      variables: [],
      Filter {
        predicates: [
          (
            (
              (
                (
                  (
                    (substr(#4, 1, 2) = ":1")
                    ||
                    (substr(#4, 1, 2) = ":2")
                  )
                  ||
                  (substr(#4, 1, 2) = ":3")
                )
                ||
                (substr(#4, 1, 2) = ":4")
              )
              ||
              (substr(#4, 1, 2) = ":5")
            )
            ||
            (substr(#4, 1, 2) = ":6")
          )
          ||
          (substr(#4, 1, 2) = ":7")
        ],
        Get { customer (u11) }
      },
      Map {
        scalars: [
          ((#0 * 10000000dec) / (i64todec #1 * 100dec)) * 10dec
        ],
        Reduce {
          group_key: [],
          aggregates: [sum(#5), countall(null)],
          Filter {
            predicates: [
              (
                (
                  (
                    (
                      (
                        (substr(#4, 1, 2) = "13")
                        ||
                        (substr(#4, 1, 2) = "31")
                      )
                      ||
                      (substr(#4, 1, 2) = "23")
                    )
                    ||
                    (substr(#4, 1, 2) = "29")
                  )
                  ||
                  (substr(#4, 1, 2) = "30")
                )
                ||
                (substr(#4, 1, 2) = "18")
              )
              ||
              (substr(#4, 1, 2) = "17"),
              #5 > 0dec
            ],
            Get { customer (u11) }
          }
        }
      }
    }
  }
} in
Let { l4 = Distinct { group_key: [0], Get { l0 } } } in
Let {
  l3 = Map {
    scalars: [true],
    Distinct {
      group_key: [9],
      Join {
        variables: [[(0, 1), (1, 0)]],
        Get { orders (u13) },
        Get { l4 }
      }
    }
  }
} in
Reduce {
  group_key: [13],
  aggregates: [countall(null), sum(#5)],
  Map {
    scalars: [substr(#4, 1, 2)],
    Join {
      variables: [[(0, 0), (1, 0)]],
      Get { l0 },
      Union {
        Filter { predicates: [!#1], Get { l3 } },
        Map {
          scalars: [false],
          Union {
            Project { outputs: [0], Negate { Get { l3 } } },
            Get { l4 }
          }
        }
      }
    }
  }
}
